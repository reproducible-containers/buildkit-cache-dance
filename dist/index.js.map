{"mappings":"A,U,M,I,A,W,M,I,A,W,M,M,A,W,M,M,A,W,M,O,A,W,M,K,A,W,M,K,A,W,M,Q,A,W,M,Q,A,W,M,M,A,W,M,e,E,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,OCAA,OAAA,OAAA,CAAA,EAEA,AAAA,YAAA,OAAA,QAAA,OAAA,GAAA,EACA,OAAA,WACA,OAAA,CAEA,EAGE,CAIA,EAAA,CAAA,QAAI,CAAK,SACP,CAAA,CAAA,CAAA,CAAA,CADF,CAAA,CAAA,EAEE,IAAA,EAAM,EAAA,kDACD,EAAA,EAAA,MACL,EAAA,EAAA,MACA,EAAI,EAAY,cAAiB,CAAA,GAGjC,EAAM,EAAA,qBACR,EAAA,EAAA,sBACF,EAAA,EAAA,aCtBA,ADwBA,CAAA,eACK,CAAK,EACF,IAAA,EAAa,AAAC,CAAA,E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CAAA,EAAA,EAClB,EAAC,CAKO,EAAO,MAAA,CAAO,GAAA,CAAO,CAAA,EAAM,KAAA,GAAQ,CAAA,CAAA,CAAO,EAAA,CAAwB,OAAA,CAAI,ECHlF,EAAA,CAAA,iDAAA,OAAA,EAAA,CAAA,QAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EACE,EAAA,cAAY,CAAQ,SAAQ,CAAA,EAC1B,OAAA,GACE,EAAA,UAAQ,CAAA,EACR,CAMF,QAAO,CACL,CACA,EACE,EAAA,iBAAO,CAAA,SAAP,CAAA,EACF,OAAA,cAAA,CAAA,EAAA,aAAA,CACF,MAAA,CAAA,CACF,EAEA,EACF,EAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,E,OAEA,OAAQ,IAAM,CAAA,GAAG,OAAc,CAAE,SAAQ,CAAE,EAClC,YAAA,GAAqB,AAAA,eAAA,GAA5B,OAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,EAAA,IACE,OAAA,cAAA,CAAA,EAAA,EAAA,CACA,WAAA,CAAA,EACF,IAAA,WACF,OAAA,CAAA,CAAA,EAAA,A,C,E,G,C,E,E,M,C,S,C,C,C,C,C,E,O,c,C,E,E,C,W,C,E,I,C,E,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,IE0CA,EAFA,E,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,E,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,E,G,G,E,U,C,O,E,I,E,C,E,G,A,M,E,I,I,K,E,A,Y,G,O,c,C,I,C,E,I,E,E,E,G,O,E,E,G,C,E,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,CA1EA,CACA,SAAA,EAAA,CAAA,M,CACA,C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A,mBAAA,CAAA,GAAA,aAAA,MAAA,EAAA,QAAA,GAAA,E,E,E,M,CAQA,SAAA,CAAA,CAAA,EAAA,CAAA,CAAA,E,E,Y,C,S,E,mB,C,G,a,M,E,Q,G,E,EAWA,EAAA,IAAA,CAHE,SAAA,CAAM,EACR,QAAA,MAAA,CAAA,KAAA,CAAA,EAAA,EAAA,GAAA,CAFA,E,E,U,C,EAsBE,EAAA,QAAA,CAAA,EAuBA,EAAA,KAAA,CAdD,SAAA,CAAA,CAAA,CAAA,EAZD,OAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,gBAeA,EADA,EAAA,GAEA,GAAA,CAEA,EAAA,MAAA,G,Q,C,G,C,O,CAMA,EACA,E,E,S,CASG,SACa,CAAS,CAAA,CADtB,EAED,EAAO,YAAY,CAAA,aAAgB,CACrC,KAAA,CAFA,EAAA,EAIA,EAOQ,EAAA,QAAA,C,S,C,EAAR,OAAA,QAAA,GAAA,CAAA,CAAA,MADG,EAAA,EAAA,CAAA,CAAA,EAAA,EACK,E,E,U,CAAA,SAAA,CAAA,EAAA,OAAA,EAAA,IAAA,CAAA,KAAO,EAAP,KAAA,EAAA,YAAO,OAAA,MAAA,EAAA,UAAA,CAAA,UAAA,CAAA,EAAA,EAEf,EAGQ,IAAA,EAAA,EAAA,oBAAA,OAAA,cAAA,CAAA,EAAA,UAAA,CAAA,WAAA,CAAA,EAAe,IAAA,WAAA,OAAA,EAAA,OAAA,A,C,G,I,E,E,oB,O,c,C,E,kB,C,W,C,E,I,W,O,E,e,A,C,E,E,C,iB,Q,mB,Q,mB,Q,kB,K,iB,O,kB,Q,iB,O,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,E,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,E,G,G,E,U,C,O,EElXvB,IAAA,EAAA,CAAA,EACA,GAAA,AAAA,MAAA,EAWA,IAAA,IAAA,KAAA,EAAA,AAAA,YAAA,GAAA,OAAA,cAAA,CAAA,IAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,G,O,E,E,G,C,E,O,c,C,E,a,C,M,C,C,G,E,K,C,E,Y,C,K,EASG,IACH,EAAA,EAAgB,EACd,qBAIA,EAAY,EAAI,oBAehB,SAAA,EAA6B,CAAA,CAA6B,CAA1D,CAAA,CAAA,EACE,IAAA,EAAK,IAAA,EACH,EADF,EAAA,GAIA,QAAI,MAAC,CAAA,KAAL,CAAA,EAAA,QAAA,GAAA,EAAA,GAAA,CACA,CACA,EAAA,YAAY,CAAG,EAMf,EAAA,KAAI,CALN,SAAA,CAAA,CAAA,EAAA,EAAA,EAEA,EAAA,EAAA,CAAA,EAAA,EACE,CAIE,OAAA,EACA,YAAK,CAAM,CAAA,CAAY,CAAA,CAAU,CAC/B,CACE,AAAA,GAAM,CAAA,EAAU,iBAAgB,EAChC,IAAA,CAAA,OAAI,CAAA,EACF,IAAA,CAAA,UAAA,CAAI,EAGF,IAAA,CAAA,OAAA,CAAA,CAGF,CACD,UAAA,KE/DX,E,EFgES,IAAA,EAAA,AAdH,KAcG,IAAA,CAAA,OAAA,CAEJ,GAAA,IAAA,CAAA,UAAA,EAAA,OAAA,IAAA,CAAA,IAAA,CAAA,UAAA,EAAA,MAAA,CAAA,EAAA,CAED,GAAa,IACb,IAAA,EAAA,CAAA,EACF,IAAA,IAAA,KAAA,IAAA,CAAA,UAAA,CAAA,GAAA,IAAA,CAAA,UAAA,CAAA,cAAA,CAAA,GAAA,CACD,IAAA,EAAA,IAAA,CAAA,UAAA,CAAA,EAAA,CAEmB,IACX,EAAA,EACJ,CAAA,EAGL,GAAA,IAES,GAAT,CAAA,EAAA,EAAA,CAAA,EEhFA,EFgFA,E,E,c,C,G,O,C,K,O,O,C,M,O,O,C,M,O,O,C,K,O,O,C,K,OAAA,CAAA,CAOA,C,C,O,E,K,E,I,C,O,C,E,c,C,G,O,C,K,O,O,C,M,O,O,C,M,Q,AE7FA,CACA,CAUE,EAAA,CAAA,mBAAc,KAAQ,mBAAU,OAC9B,EADF,CAAA,MAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAMF,OAAA,cAAA,CAAA,EAAA,aAAA,CAPA,MAAA,CAAA,CASA,G,E,mB,C,E,c,C,K,EAgBI,EAAA,cAAM,CAVV,SAAgB,CACd,SAEA,AAAI,MAAA,EACF,GAGF,AAAA,UAAA,OAAA,GAAA,aAAA,OAAA,EACE,KAAO,SAAA,CAAA,EACP,E,E,mB,CATJ,SAAA,CAAA,S,A,O,I,C,G,M,C,C,M,E,K,CEzBA,KAAA,EAAA,IAAuC,C,K,E,S,C,Q,E,O,C,I,E,W,C,U,E,S,A,E,C,C,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,e,E,C,O,M,C,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,O,c,C,E,E,C,W,C,E,I,W,O,C,C,E,A,C,E,E,S,C,C,C,C,C,C,C,E,A,K,I,G,C,E,C,E,C,C,E,C,C,C,E,A,C,E,E,I,E,I,C,kB,E,C,O,M,C,S,C,C,C,E,O,c,C,E,U,C,W,C,E,M,C,E,E,S,C,C,C,E,E,O,C,C,C,E,E,I,E,I,C,Y,E,S,C,E,G,G,E,U,C,O,EAEvC,IAAA,EAAA,CAAA,EACA,GAAA,AAAA,MAAA,EAGA,IAAA,IAAA,KAAA,EAAA,AAAA,YAAA,GAAA,OAAA,cAAA,CAAA,IAAA,CAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAIE,OADF,EAA6B,EAAiB,GACtC,CACN,EAKA,OAAA,cAAQ,CAAU,EAAC,aACP,CAGZ,MAAG,CAAA,CACD,GACD,EAAA,YAAA,CAAA,KAAA,EAbH,IAAA,EAAA,EAAA,EAAA,qB,E,E,E,qB,E,E,mB,C,E,Y,C,S,C,C,C,E,I,E,Q,G,C,C,O,E,E,C,C,C,G,C,E,M,A,M,C,qD,E,E,C,E,G,C,E,U,C,G,M,A,M,C,sB,E,E,C,E,E,c,C,E,C,E,E,c,C,G,E,E,G,C,C,C,C,S,M,E,C,E,C,mB,K,mB,K,iB,O,E,C,M,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,CENA,CACA,SAAA,EAAA,CAAA,M,CACA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,KAAA,EA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,OAAA,IACJ,CACA,EAoBA,EAAA,uBAAwB,CAlBpB,MACJ,YAAA,CAAA,CAAA,CACA,IAAA,CAAA,KAAA,CAAA,CACI,CAGR,eAAQ,CAAA,CAAA,CACR,EAAA,OAAA,CAAA,aAAA,CAAA,UAAA,IAAA,CAAA,KAAA,AACI,CAEA,wBAAA,CAAA,CAAA,CACA,MAAA,CAAA,CACA,CACA,qBAAe,CAAf,CAAA,CAAA,CAAA,CAAA,CAAA,CACI,OAAA,IAEJ,CACA,E,E,oC,CAEI,MACJ,YAAA,CAAA,CAAA,CACA,IAAA,CAAA,KAAA,CAAA,CACI,CAGR,eAAQ,CAAA,CAAA,C,E,O,C,a,C,S,O,I,C,O,I,C,K,E,Q,C,S,C,wB,C,C,C,M,C,C,C,qB,C,C,C,C,C,C,C,O,I,C,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,E,I,E,I,E,I,C,S,E,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,CEzDR,CACA,SAAA,EAAA,CAAA,M,CACO,CAAA,EAAQ,IAAA,CAAU,EAAE,EAAU,KAAG,EAAA,A,C,C,EAAxC,EAAA,KAAA,Y,E,E,I,E,S,C,E,E,E,E,EAAA,IAAA,CAAA,EAAA,EAEa,CACA,EAAA,AAAA,CAAA,EAAgB,EAAhB,KAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,IAAA,GAgDb,EAIE,EACE,OAAA,cAAY,CAAA,EAAZ,aAAA,CACF,MAAA,CAAA,CAEA,G,E,O,C,E,e,C,E,gB,C,E,e,C,K,E,I,E,E,oB,E,E,oB,C,O,C,C,W,C,C,U,C,C,C,E,Q,AAKG,CAAA,EACW,eADX,CAAA,sB,E,gB,C,4GChEL,IAAA,EAAQ,IDkEJ,MAIA,aAAA,CACA,IAAA,CAAA,OAAK,CAAA,EAML,CASA,UAAO,CACT,OAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,YAAC,GAAA,IAAA,CAAA,SAAA,CAAA,OAAA,IAAA,CAAA,SAAA,CAED,IAAA,EAAA,QAAA,GAAA,CAAA,EAAA,eAAA,CAAA,C,G,C,E,M,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","sources":["<anon>","src/index.ts","src/inject-cache.ts","src/opts.ts","node_modules/.pnpm/mri@1.2.0/node_modules/mri/lib/index.mjs","node_modules/.pnpm/@parcel+transformer-js@2.15.1_@parcel+core@2.15.1_@swc+helpers@0.5.17_/node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/core.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/core.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/command.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/command.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/utils.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/utils.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/file-command.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/file-command.ts","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/oidc-utils.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/oidc-utils.ts","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/index.js","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/proxy.js","node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js","node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js","node_modules/.pnpm/@actions+http-client@1.0.11/node_modules/@actions/http-client/auth.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/lib/summary.js","node_modules/.pnpm/@actions+core@1.8.0/node_modules/@actions/core/src/summary.ts","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/argument.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/jsonArgument.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/comment.js","node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/line.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/util.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/parser.js","node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/umd/main.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/parserDirective.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/heredoc.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/variable.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/add.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/jsonInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/modifiableInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/flag.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/flagOption.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/arg.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/property.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/propertyInstruction.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/cmd.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/copy.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/env.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/entrypoint.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/from.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/healthcheck.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/label.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/onbuild.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/run.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/shell.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/stopsignal.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/workdir.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/user.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/instructions/volume.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/dockerfile.js","node_modules/.pnpm/dockerfile-ast@0.7.0/node_modules/dockerfile-ast/lib/imageTemplate.js","src/run.ts","node_modules/.pnpm/spawn-please@3.0.0/node_modules/spawn-please/src/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js","node_modules/.pnpm/which@2.0.2/node_modules/which/which.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js","node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js","node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js","node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js","node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js","node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js","src/extract-cache.ts"],"sourcesContent":["import * as __parcelExternal0 from \"fs\";\nimport * as __parcelExternal1 from \"os\";\nimport * as __parcelExternal2 from \"path\";\nimport * as __parcelExternal3 from \"http\";\nimport * as __parcelExternal4 from \"https\";\nimport * as __parcelExternal5 from \"net\";\nimport * as __parcelExternal6 from \"tls\";\nimport * as __parcelExternal7 from \"events\";\nimport * as __parcelExternal8 from \"assert\";\nimport * as __parcelExternal9 from \"util\";\nimport * as __parcelExternal10 from \"child_process\";\n// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"7sz5b\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nvar _fs = require(\"fs\");\nvar _os = require(\"os\");\nvar _osDefault = parcelHelpers.interopDefault(_os);\nvar _injectCacheJs = require(\"./inject-cache.js\");\nvar _extractCacheJs = require(\"./extract-cache.js\");\nvar _optsJs = require(\"./opts.js\");\nasync function main(args) {\n    const opts = (0, _optsJs.parseOpts)(args);\n    if (opts.help) return (0, _optsJs.help)();\n    if (opts.extract) // Run the post step\n    await (0, _extractCacheJs.extractCaches)(opts);\n    else {\n        // Otherwise, this is the main step\n        if (process.env.GITHUB_STATE !== undefined) await (0, _fs.promises).appendFile(process.env.GITHUB_STATE, `POST=true${(0, _osDefault.default).EOL}`);\n        await (0, _injectCacheJs.injectCaches)(opts);\n    }\n}\nmain(process.argv).catch((err)=>{\n    console.error(err);\n    if (err instanceof Error) console.error(err.stack);\n    process.exit(1);\n});\n\n},{\"fs\":\"fs\",\"os\":\"os\",\"./inject-cache.js\":\"g8Odb\",\"./extract-cache.js\":\"14eXt\",\"./opts.js\":\"bjlzi\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"g8Odb\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"injectCaches\", ()=>injectCaches);\nvar _fs = require(\"fs\");\nvar _path = require(\"path\");\nvar _pathDefault = parcelHelpers.interopDefault(_path);\nvar _optsJs = require(\"./opts.js\");\nvar _runJs = require(\"./run.js\");\nvar _coreJs = require(\"@actions/core/lib/core.js\");\nasync function injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder) {\n    // Clean Scratch Directory\n    await (0, _fs.promises).rm(scratchDir, {\n        recursive: true,\n        force: true\n    });\n    await (0, _fs.promises).mkdir(scratchDir, {\n        recursive: true\n    });\n    // Prepare Cache Source Directory\n    await (0, _fs.promises).mkdir(cacheSource, {\n        recursive: true\n    });\n    // Prepare Timestamp for Layer Cache Busting\n    const date = new Date().toISOString();\n    await (0, _fs.promises).writeFile((0, _pathDefault.default).join(cacheSource, 'buildstamp'), date);\n    const targetPath = (0, _optsJs.getTargetPath)(cacheOptions);\n    const mountArgs = (0, _optsJs.getMountArgsString)(cacheOptions);\n    // If UID OR GID are set, then add chown to restore files ownership.\n    let ownershipCommand = \"\";\n    const uid = (0, _optsJs.getUID)(cacheOptions);\n    const gid = (0, _optsJs.getGID)(cacheOptions);\n    if (uid !== \"\" || gid !== \"\") ownershipCommand = `&& chown -R ${uid}:${gid} ${targetPath}`;\n    // Prepare Dancefile to Access Caches\n    const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    --mount=type=bind,source=.,target=/var/dance-cache \\\n    cp -p -R /var/dance-cache/. ${targetPath} ${ownershipCommand} || true\n`;\n    await (0, _fs.promises).writeFile((0, _pathDefault.default).join(scratchDir, 'Dancefile.inject'), dancefileContent);\n    console.log(dancefileContent);\n    // Inject Data into Docker Cache\n    await (0, _runJs.run)('docker', [\n        'buildx',\n        'build',\n        '--builder',\n        builder,\n        '-f',\n        (0, _pathDefault.default).join(scratchDir, 'Dancefile.inject'),\n        '--tag',\n        'dance:inject',\n        cacheSource\n    ]);\n    // Clean Directories\n    try {\n        await (0, _fs.promises).rm(cacheSource, {\n            recursive: true,\n            force: true\n        });\n    } catch (err) {\n        // Ignore Cleaning Errors\n        (0, _coreJs.notice)(`Error while cleaning cache source directory: ${err}. Ignoring...`);\n    }\n}\nasync function injectCaches(opts) {\n    const cacheMap = await (0, _optsJs.getCacheMap)(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = (0, _optsJs.getBuilder)(opts);\n    // Inject Caches for each source-target pair\n    for (const [cacheSource, cacheOptions] of Object.entries(cacheMap))await injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder);\n}\n\n},{\"fs\":\"fs\",\"path\":\"path\",\"./opts.js\":\"bjlzi\",\"./run.js\":\"kHqLa\",\"@actions/core/lib/core.js\":\"k7YnK\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"bjlzi\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"parseOpts\", ()=>parseOpts);\nparcelHelpers.export(exports, \"help\", ()=>help);\nparcelHelpers.export(exports, \"getCacheMap\", ()=>getCacheMap);\nparcelHelpers.export(exports, \"getTargetPath\", ()=>getTargetPath);\nparcelHelpers.export(exports, \"getUID\", ()=>getUID);\nparcelHelpers.export(exports, \"getGID\", ()=>getGID);\n/**\n * Convert a cache options to a string that is passed to --mount=\n * @param CacheOptions The cache options to convert to a string\n */ parcelHelpers.export(exports, \"getMountArgsString\", ()=>getMountArgsString);\nparcelHelpers.export(exports, \"getBuilder\", ()=>getBuilder);\nvar _mri = require(\"mri\");\nvar _mriDefault = parcelHelpers.interopDefault(_mri);\nvar _fs = require(\"fs\");\nvar _coreJs = require(\"@actions/core/lib/core.js\");\nvar _dockerfileAst = require(\"dockerfile-ast\");\nfunction parseOpts(args) {\n    const opts = (0, _mriDefault.default)(args, {\n        default: {\n            \"cache-map\": (0, _coreJs.getInput)(\"cache-map\") || \"{}\",\n            \"dockerfile\": (0, _coreJs.getInput)(\"dockerfile\") || \"Dockerfile\",\n            \"cache-dir\": (0, _coreJs.getInput)(\"cache-dir\") || null,\n            \"scratch-dir\": (0, _coreJs.getInput)(\"scratch-dir\") || \"scratch\",\n            \"skip-extraction\": ((0, _coreJs.getInput)(\"skip-extraction\") || \"false\") === \"true\",\n            \"extract\": process.env[`STATE_POST`] !== undefined,\n            \"utility-image\": (0, _coreJs.getInput)(\"utility-image\") || \"ghcr.io/containerd/busybox:latest\",\n            \"builder\": (0, _coreJs.getInput)(\"builder\") || \"default\",\n            \"help\": false\n        },\n        string: [\n            \"cache-map\",\n            \"dockerfile\",\n            \"cache-dir\",\n            \"scratch-dir\",\n            \"cache-source\",\n            \"cache-target\",\n            \"utility-image\",\n            \"builder\"\n        ],\n        boolean: [\n            \"skip-extraction\",\n            \"help\",\n            \"extract\"\n        ],\n        alias: {\n            \"help\": [\n                \"h\"\n            ]\n        }\n    });\n    if (opts[\"cache-source\"] && opts[\"cache-target\"]) {\n        (0, _coreJs.warning)(\"The `cache-source` and `cache-target` options are deprecated. Use `cache-map` instead.\");\n        opts[\"cache-map\"] = JSON.stringify({\n            [opts[\"cache-source\"]]: opts[\"cache-target\"]\n        });\n    }\n    return opts;\n}\nfunction help() {\n    console.log(`build-cache-dance [options]\nSave 'RUN --mount=type=cache' caches on GitHub Actions or other CI platforms\n\nOptions:\n  --extract      Extract the cache from the docker container (extract step). Otherwise, inject the cache (main step)\n  --cache-map    The map of actions source paths to container destination paths or mount arguments\n  --dockerfile   The Dockerfile to use for auto-discovery of the cache-map. Default: 'Dockerfile'\n  --cache-dir    The root directory where cache content is injected from/extracted to when using auto-discovery of the cache-map.\n  --scratch-dir  Where the action is stores some temporary files for its processing. Default: 'scratch'\n  --skip-extraction  Skip the extraction of the cache from the docker container\n  --utility-image  The container image to use for injecting and extracting the cache. Default: 'ghcr.io/containerd/busybox:latest'\n  --builder      The name of the buildx builder to use for the cache injection\n  --help         Show this help\n`);\n}\nasync function getCacheMapFromDockerfile(dockerfilePath, bindRoot) {\n    const dockerfileContent = await (0, _fs.promises).readFile(dockerfilePath, \"utf-8\");\n    const dockerfile = (0, _dockerfileAst.DockerfileParser).parse(dockerfileContent);\n    const cacheMap = {};\n    const runInstructions = dockerfile.getInstructions().filter((i)=>i.getKeyword() == 'RUN');\n    for (const run of runInstructions){\n        for (const flag of run.getFlags())if (flag.getName() == 'mount' && flag.getOption('type')?.getValue() == 'cache') {\n            // Extract the `id` flag which defaults to `target` when `id` is not set\n            // https://docs.docker.com/reference/dockerfile/#run---mounttypecache\n            const id = flag.getOption('id')?.getValue() || flag.getOption('target')?.getValue();\n            if (id == null) throw new Error('cache mount must define id or target: ' + flag.toString() + ' in ' + run.toString());\n            // The directory on the host to inject/extract the cache mount data from\n            const bindDir = bindRoot !== null ? `${bindRoot}/${id}` : id;\n            // The target in this action does not matter as long as it is\n            // different than /var/dance-cache of course\n            const target = \"/var/cache-target\";\n            cacheMap[bindDir] = {\n                id,\n                target\n            };\n        }\n    }\n    return cacheMap;\n}\nasync function getCacheMap(opts) {\n    try {\n        const cacheMap = JSON.parse(opts[\"cache-map\"]);\n        if (Object.keys(cacheMap).length !== 0) return cacheMap;\n        console.log(`No cache map provided. Trying to parse the Dockerfile to find the cache mount instructions...`);\n        const cacheMapFromDockerfile = await getCacheMapFromDockerfile(opts[\"dockerfile\"], opts[\"cache-dir\"]);\n        console.log(`Cache map parsed from Dockerfile: ${JSON.stringify(cacheMapFromDockerfile)}`);\n        return cacheMapFromDockerfile;\n    } catch (e) {\n        throw new Error(`Failed to parse cache map. Expected JSON, got:\\n${opts[\"cache-map\"]}\\n${e}`);\n    }\n}\nfunction getTargetPath(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return cacheOptions;\n    else {\n        // object is provided\n        if (\"target\" in cacheOptions) return cacheOptions.target;\n        else throw new Error(`Expected the 'target' key in the cache options, got:\\n${cacheOptions}`);\n    }\n}\nfunction getUID(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return \"\";\n    else {\n        // object is provided\n        if (\"uid\" in cacheOptions && cacheOptions.uid !== undefined) return cacheOptions.uid.toString();\n        else return \"\";\n    }\n}\nfunction getGID(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return \"\";\n    else {\n        // object is provided\n        if (\"gid\" in cacheOptions && cacheOptions.gid !== undefined) return cacheOptions.gid.toString();\n        else return \"\";\n    }\n}\nfunction getMountArgsString(cacheOptions) {\n    if (typeof cacheOptions === \"string\") // only the target path is provided\n    return `type=cache,target=${cacheOptions}`;\n    else {\n        // other options are provided\n        const otherOptions = Object.entries(cacheOptions).map(([key, value])=>`${key}=${value}`).join(\",\");\n        return `type=cache,${otherOptions}`;\n    }\n}\nfunction getBuilder(opts) {\n    return opts[\"builder\"] == null || opts[\"builder\"] == \"\" ? \"default\" : opts[\"builder\"];\n}\n\n},{\"mri\":\"5lGLa\",\"fs\":\"fs\",\"@actions/core/lib/core.js\":\"k7YnK\",\"dockerfile-ast\":\"1irbL\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"5lGLa\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>function(args, opts) {\n        args = args || [];\n        opts = opts || {};\n        var k, arr, arg, name, val, out = {\n            _: []\n        };\n        var i = 0, j = 0, idx = 0, len = args.length;\n        const alibi = opts.alias !== void 0;\n        const strict = opts.unknown !== void 0;\n        const defaults = opts.default !== void 0;\n        opts.alias = opts.alias || {};\n        opts.string = toArr(opts.string);\n        opts.boolean = toArr(opts.boolean);\n        if (alibi) for(k in opts.alias){\n            arr = opts.alias[k] = toArr(opts.alias[k]);\n            for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);\n        }\n        for(i = opts.boolean.length; i-- > 0;){\n            arr = opts.alias[opts.boolean[i]] || [];\n            for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);\n        }\n        for(i = opts.string.length; i-- > 0;){\n            arr = opts.alias[opts.string[i]] || [];\n            for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);\n        }\n        if (defaults) for(k in opts.default){\n            name = typeof opts.default[k];\n            arr = opts.alias[k] = opts.alias[k] || [];\n            if (opts[name] !== void 0) {\n                opts[name].push(k);\n                for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);\n            }\n        }\n        const keys = strict ? Object.keys(opts.alias) : [];\n        for(i = 0; i < len; i++){\n            arg = args[i];\n            if (arg === '--') {\n                out._ = out._.concat(args.slice(++i));\n                break;\n            }\n            for(j = 0; j < arg.length; j++){\n                if (arg.charCodeAt(j) !== 45) break; // \"-\"\n            }\n            if (j === 0) out._.push(arg);\n            else if (arg.substring(j, j + 3) === 'no-') {\n                name = arg.substring(j + 3);\n                if (strict && !~keys.indexOf(name)) return opts.unknown(arg);\n                out[name] = false;\n            } else {\n                for(idx = j + 1; idx < arg.length; idx++){\n                    if (arg.charCodeAt(idx) === 61) break; // \"=\"\n                }\n                name = arg.substring(j, idx);\n                val = arg.substring(++idx) || i + 1 === len || ('' + args[i + 1]).charCodeAt(0) === 45 || args[++i];\n                arr = j === 2 ? [\n                    name\n                ] : name;\n                for(idx = 0; idx < arr.length; idx++){\n                    name = arr[idx];\n                    if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);\n                    toVal(out, name, idx + 1 < arr.length || val, opts);\n                }\n            }\n        }\n        if (defaults) {\n            for(k in opts.default)if (out[k] === void 0) out[k] = opts.default[k];\n        }\n        if (alibi) for(k in out){\n            arr = opts.alias[k] || [];\n            while(arr.length > 0)out[arr.shift()] = out[k];\n        }\n        return out;\n    });\nfunction toArr(any) {\n    return any == null ? [] : Array.isArray(any) ? any : [\n        any\n    ];\n}\nfunction toVal(out, key, val, opts) {\n    var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? '' : String(val) : typeof val === 'boolean' ? val : !!~opts.boolean.indexOf(key) ? val === 'false' ? false : val === 'true' || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;\n    out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [\n        old,\n        nxt\n    ];\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"8h9S8\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"k7YnK\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"e924a1cef16bef69\");\nconst file_command_1 = require(\"16e43487988cdce8\");\nconst utils_1 = require(\"7f8c194a8c8f18e8\");\nconst os = __importStar(require(\"92b8860262e27ba\"));\nconst path = __importStar(require(\"d28a375bd89b68cf\"));\nconst oidc_utils_1 = require(\"7e9da61c1748be9\");\n/**\n * The code to exit an action\n */ var ExitCode;\n(function(ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */ ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */ ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    } else command_1.issueCommand('set-env', {\n        name\n    }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */ function setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */ function addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) file_command_1.issueCommand('PATH', inputPath);\n    else command_1.issueCommand('add-path', {}, inputPath);\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */ function getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);\n    if (options && options.trimWhitespace === false) return val;\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */ function getMultilineInput(name, options) {\n    const inputs = getInput(name, options).split('\\n').filter((x)=>x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */ function getBooleanInput(name, options) {\n    const trueValue = [\n        'true',\n        'True',\n        'TRUE'\n    ];\n    const falseValue = [\n        'false',\n        'False',\n        'FALSE'\n    ];\n    const val = getInput(name, options);\n    if (trueValue.includes(val)) return true;\n    if (falseValue.includes(val)) return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` + `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', {\n        name\n    }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */ function setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */ function setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */ function isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */ function debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */ function notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */ function info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */ function startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */ function endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */ function group(name, fn) {\n    return __awaiter(this, void 0, void 0, function*() {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        } finally{\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', {\n        name\n    }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */ function getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */ var summary_1 = require(\"e44daa22e4d4d53e\");\nObject.defineProperty(exports, \"summary\", {\n    enumerable: true,\n    get: function() {\n        return summary_1.summary;\n    }\n});\n/**\n * @deprecated use core.summary\n */ var summary_2 = require(\"e44daa22e4d4d53e\");\nObject.defineProperty(exports, \"markdownSummary\", {\n    enumerable: true,\n    get: function() {\n        return summary_2.markdownSummary;\n    }\n});\n\n},{\"e924a1cef16bef69\":\"kZGXI\",\"16e43487988cdce8\":\"gRxw7\",\"7f8c194a8c8f18e8\":\"bO0ir\",\"92b8860262e27ba\":\"os\",\"d28a375bd89b68cf\":\"path\",\"7e9da61c1748be9\":\"b9uNA\",\"e44daa22e4d4d53e\":\"7Zbhg\"}],\"kZGXI\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"3737725acaa42483\"));\nconst utils_1 = require(\"69b2ffcef1696d24\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */ function issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message){\n        if (!command) command = 'missing.command';\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for(const key in this.properties)if (this.properties.hasOwnProperty(key)) {\n                const val = this.properties[key];\n                if (val) {\n                    if (first) first = false;\n                    else cmdStr += ',';\n                    cmdStr += `${key}=${escapeProperty(val)}`;\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s).replace(/%/g, '%25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A').replace(/:/g, '%3A').replace(/,/g, '%2C');\n}\n\n},{\"3737725acaa42483\":\"os\",\"69b2ffcef1696d24\":\"bO0ir\"}],\"bO0ir\":[function(require,module,exports,__globalThis) {\n\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */ function toCommandValue(input) {\n    if (input === null || input === undefined) return '';\n    else if (typeof input === 'string' || input instanceof String) return input;\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */ function toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) return {};\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n\n},{}],\"gRxw7\":[function(require,module,exports,__globalThis) {\n\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */ const fs = __importStar(require(\"778c221d6defca47\"));\nconst os = __importStar(require(\"9ee56551f05bb7a0\"));\nconst utils_1 = require(\"a1dde01443f9a1e6\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);\n    if (!fs.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n\n},{\"778c221d6defca47\":\"fs\",\"9ee56551f05bb7a0\":\"os\",\"a1dde01443f9a1e6\":\"bO0ir\"}],\"b9uNA\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"6cdaf1fd914e5387\");\nconst auth_1 = require(\"8db37dcf5a5b1463\");\nconst core_1 = require(\"1147ffd9ee1d6042\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [\n            new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())\n        ], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient.getJson(id_token_url).catch((error)=>{\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) throw new Error('Response json body do not have ID Token field');\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            } catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n\n},{\"6cdaf1fd914e5387\":\"bTnEL\",\"8db37dcf5a5b1463\":\"lQXpe\",\"1147ffd9ee1d6042\":\"k7YnK\"}],\"bTnEL\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst http = require(\"69cee5eb1e6c891e\");\nconst https = require(\"5135743cad10c017\");\nconst pm = require(\"74ceafcf2537bb1e\");\nlet tunnel;\nvar HttpCodes;\n(function(HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function(Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function(MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */ function getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = [\n    'OPTIONS',\n    'GET',\n    'DELETE',\n    'HEAD'\n];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode){\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message){\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject)=>{\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk)=>{\n                output = Buffer.concat([\n                    output,\n                    chunk\n                ]);\n            });\n            this.message.on('end', ()=>{\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions){\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;\n            if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;\n            if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;\n            if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */ async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */ async request(verb, requestUrl, data, headers) {\n        if (this._disposed) throw new Error('Client has already been disposed.');\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;\n        let numTries = 0;\n        let response;\n        while(numTries < maxTries){\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for(let i = 0; i < this.handlers.length; i++)if (this.handlers[i].canHandleAuthentication(response)) {\n                    authenticationHandler = this.handlers[i];\n                    break;\n                }\n                if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info, data);\n                else // We have received an unauthorized response but have no handlers to handle it.\n                // Let the response return to the caller.\n                return response;\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while(HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0){\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) break;\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for(let header in headers)// header names are case insensitive\n                    if (header.toLowerCase() === 'authorization') delete headers[header];\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) // If not a retry code, return immediately instead of retrying\n            return response;\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */ dispose() {\n        if (this._agent) this._agent.destroy();\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */ requestRaw(info, data) {\n        return new Promise((resolve, reject)=>{\n            let callbackForResult = function(err, res) {\n                if (err) reject(err);\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */ requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        let callbackCalled = false;\n        let handleResult = (err, res)=>{\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg)=>{\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', (sock)=>{\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 180000, ()=>{\n            if (socket) socket.end();\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function(err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') req.write(data, 'utf8');\n        if (data && typeof data !== 'string') {\n            data.on('close', function() {\n                req.end();\n            });\n            data.pipe(req);\n        } else req.end();\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */ getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;\n        info.options.path = (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) info.options.headers['user-agent'] = this.userAgent;\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) this.handlers.forEach((handler)=>{\n            handler.prepareRequest(info.options);\n        });\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = (obj)=>Object.keys(obj).reduce((c, k)=>(c[k.toLowerCase()] = obj[k], c), {});\n        if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = (obj)=>Object.keys(obj).reduce((c, k)=>(c[k.toLowerCase()] = obj[k], c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) agent = this._proxyAgent;\n        if (this._keepAlive && !useProxy) agent = this._agent;\n        // if agent is already assigned use that agent.\n        if (!!agent) return agent;\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) tunnel = require(\"591dff9a34bef599\");\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...(proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    },\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = {\n                keepAlive: this._keepAlive,\n                maxSockets: maxSockets\n            };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) agent = usingSsl ? https.globalAgent : http.globalAgent;\n        if (usingSsl && this._ignoreSslError) // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n        // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n        // we have to cast it to any and change it directly\n        agent.options = Object.assign(agent.options || {}, {\n            rejectUnauthorized: false\n        });\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise((resolve)=>setTimeout(()=>resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) return a;\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject)=>{\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) resolve(response);\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    else obj = JSON.parse(contents);\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            } catch (err) {\n            // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) msg = obj.message;\n                else if (contents && contents.length > 0) // it may be the case that the exception is in the body message as string\n                msg = contents;\n                else msg = 'Failed request: (' + statusCode + ')';\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            } else resolve(response);\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n\n},{\"69cee5eb1e6c891e\":\"http\",\"5135743cad10c017\":\"https\",\"74ceafcf2537bb1e\":\"jyPkM\",\"591dff9a34bef599\":\"fHNgG\"}],\"jyPkM\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) return proxyUrl;\n    let proxyVar;\n    if (usingSsl) proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    else proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    if (proxyVar) proxyUrl = new URL(proxyVar);\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) return false;\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) return false;\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) reqPort = Number(reqUrl.port);\n    else if (reqUrl.protocol === 'http:') reqPort = 80;\n    else if (reqUrl.protocol === 'https:') reqPort = 443;\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [\n        reqUrl.hostname.toUpperCase()\n    ];\n    if (typeof reqPort === 'number') upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy.split(',').map((x)=>x.trim().toUpperCase()).filter((x)=>x)){\n        if (upperReqHosts.some((x)=>x === upperNoProxyItem)) return true;\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n\n},{}],\"fHNgG\":[function(require,module,exports,__globalThis) {\nmodule.exports = require(\"4930519cb3dd45a3\");\n\n},{\"4930519cb3dd45a3\":\"Z7Qtc\"}],\"Z7Qtc\":[function(require,module,exports,__globalThis) {\n'use strict';\nvar net = require(\"5121e3e37efd6d5e\");\nvar tls = require(\"2f892df2fa9f0920\");\nvar http = require(\"d8f61135d445c2eb\");\nvar https = require(\"4422f117af5fb5c5\");\nvar events = require(\"2bf2dc2e245634a1\");\nvar assert = require(\"d682d38a2480f4c\");\nvar util = require(\"8150fd083365f338\");\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\nfunction httpOverHttp(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = http.request;\n    return agent;\n}\nfunction httpsOverHttp(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = http.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction httpOverHttps(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = https.request;\n    return agent;\n}\nfunction httpsOverHttps(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = https.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction TunnelingAgent(options) {\n    var self = this;\n    self.options = options || {};\n    self.proxyOptions = self.options.proxy || {};\n    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n    self.requests = [];\n    self.sockets = [];\n    self.on('free', function onFree(socket, host, port, localAddress) {\n        var options = toOptions(host, port, localAddress);\n        for(var i = 0, len = self.requests.length; i < len; ++i){\n            var pending = self.requests[i];\n            if (pending.host === options.host && pending.port === options.port) {\n                // Detect the request to connect same origin server,\n                // reuse the connection.\n                self.requests.splice(i, 1);\n                pending.request.onSocket(socket);\n                return;\n            }\n        }\n        socket.destroy();\n        self.removeSocket(socket);\n    });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n    var self = this;\n    var options = mergeOptions({\n        request: req\n    }, self.options, toOptions(host, port, localAddress));\n    if (self.sockets.length >= this.maxSockets) {\n        // We are over limit so we'll add it to the queue.\n        self.requests.push(options);\n        return;\n    }\n    // If we are under maxSockets create a new one.\n    self.createSocket(options, function(socket) {\n        socket.on('free', onFree);\n        socket.on('close', onCloseOrRemove);\n        socket.on('agentRemove', onCloseOrRemove);\n        req.onSocket(socket);\n        function onFree() {\n            self.emit('free', socket, options);\n        }\n        function onCloseOrRemove(err) {\n            self.removeSocket(socket);\n            socket.removeListener('free', onFree);\n            socket.removeListener('close', onCloseOrRemove);\n            socket.removeListener('agentRemove', onCloseOrRemove);\n        }\n    });\n};\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n    var self = this;\n    var placeholder = {};\n    self.sockets.push(placeholder);\n    var connectOptions = mergeOptions({}, self.proxyOptions, {\n        method: 'CONNECT',\n        path: options.host + ':' + options.port,\n        agent: false,\n        headers: {\n            host: options.host + ':' + options.port\n        }\n    });\n    if (options.localAddress) connectOptions.localAddress = options.localAddress;\n    if (connectOptions.proxyAuth) {\n        connectOptions.headers = connectOptions.headers || {};\n        connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');\n    }\n    debug('making CONNECT request');\n    var connectReq = self.request(connectOptions);\n    connectReq.useChunkedEncodingByDefault = false; // for v0.6\n    connectReq.once('response', onResponse); // for v0.6\n    connectReq.once('upgrade', onUpgrade); // for v0.6\n    connectReq.once('connect', onConnect); // for v0.7 or later\n    connectReq.once('error', onError);\n    connectReq.end();\n    function onResponse(res) {\n        // Very hacky. This is necessary to avoid http-parser leaks.\n        res.upgrade = true;\n    }\n    function onUpgrade(res, socket, head) {\n        // Hacky.\n        process.nextTick(function() {\n            onConnect(res, socket, head);\n        });\n    }\n    function onConnect(res, socket, head) {\n        connectReq.removeAllListeners();\n        socket.removeAllListeners();\n        if (res.statusCode !== 200) {\n            debug('tunneling socket could not be established, statusCode=%d', res.statusCode);\n            socket.destroy();\n            var error = new Error(\"tunneling socket could not be established, statusCode=\" + res.statusCode);\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        if (head.length > 0) {\n            debug('got illegal response body from proxy');\n            socket.destroy();\n            var error = new Error('got illegal response body from proxy');\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        debug('tunneling connection has established');\n        self.sockets[self.sockets.indexOf(placeholder)] = socket;\n        return cb(socket);\n    }\n    function onError(cause) {\n        connectReq.removeAllListeners();\n        debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack);\n        var error = new Error(\"tunneling socket could not be established, cause=\" + cause.message);\n        error.code = 'ECONNRESET';\n        options.request.emit('error', error);\n        self.removeSocket(placeholder);\n    }\n};\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n    var pos = this.sockets.indexOf(socket);\n    if (pos === -1) return;\n    this.sockets.splice(pos, 1);\n    var pending = this.requests.shift();\n    if (pending) // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n        pending.request.onSocket(socket);\n    });\n};\nfunction createSecureSocket(options, cb) {\n    var self = this;\n    TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n        var hostHeader = options.request.getHeader('host');\n        var tlsOptions = mergeOptions({}, self.options, {\n            socket: socket,\n            servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n        });\n        // 0 is dummy port for v0.6\n        var secureSocket = tls.connect(0, tlsOptions);\n        self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n        cb(secureSocket);\n    });\n}\nfunction toOptions(host, port, localAddress) {\n    if (typeof host === 'string') return {\n        host: host,\n        port: port,\n        localAddress: localAddress\n    };\n    return host; // for v0.11 or later\n}\nfunction mergeOptions(target) {\n    for(var i = 1, len = arguments.length; i < len; ++i){\n        var overrides = arguments[i];\n        if (typeof overrides === 'object') {\n            var keys = Object.keys(overrides);\n            for(var j = 0, keyLen = keys.length; j < keyLen; ++j){\n                var k = keys[j];\n                if (overrides[k] !== undefined) target[k] = overrides[k];\n            }\n        }\n    }\n    return target;\n}\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') args[0] = 'TUNNEL: ' + args[0];\n    else args.unshift('TUNNEL:');\n    console.error.apply(console, args);\n};\nelse debug = function() {};\nexports.debug = debug; // for test\n\n},{\"5121e3e37efd6d5e\":\"net\",\"2f892df2fa9f0920\":\"tls\",\"d8f61135d445c2eb\":\"http\",\"4422f117af5fb5c5\":\"https\",\"2bf2dc2e245634a1\":\"events\",\"d682d38a2480f4c\":\"assert\",\"8150fd083365f338\":\"util\"}],\"lQXpe\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nclass BasicCredentialHandler {\n    constructor(username, password){\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Basic ' + Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token){\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token){\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n\n},{}],\"7Zbhg\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"883cae28f50a90e7\");\nconst fs_1 = require(\"d52c794fdbfabbb1\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor(){\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */ filePath() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._filePath) return this._filePath;\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            } catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */ wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs).map(([key, value])=>` ${key}=\"${value}\"`).join('');\n        if (!content) return `<${tag}${htmlAttrs}>`;\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */ write(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, {\n                encoding: 'utf8'\n            });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */ clear() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.emptyBuffer().write({\n                overwrite: true\n            });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */ stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */ isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */ emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */ addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */ addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */ addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, lang && {\n            lang\n        });\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */ addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map((item)=>this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */ addTable(rows) {\n        const tableBody = rows.map((row)=>{\n            const cells = row.map((cell)=>{\n                if (typeof cell === 'string') return this.wrap('td', cell);\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, colspan && {\n                    colspan\n                }), rowspan && {\n                    rowspan\n                });\n                return this.wrap(tag, data, attrs);\n            }).join('');\n            return this.wrap('tr', cells);\n        }).join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */ addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */ addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, width && {\n            width\n        }), height && {\n            height\n        });\n        const element = this.wrap('img', null, Object.assign({\n            src,\n            alt\n        }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */ addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = [\n            'h1',\n            'h2',\n            'h3',\n            'h4',\n            'h5',\n            'h6'\n        ].includes(tag) ? tag : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */ addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */ addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */ addQuote(text, cite) {\n        const attrs = Object.assign({}, cite && {\n            cite\n        });\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */ addLink(text, href) {\n        const element = this.wrap('a', text, {\n            href\n        });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */ exports.markdownSummary = _summary;\nexports.summary = _summary;\n\n},{\"883cae28f50a90e7\":\"os\",\"d52c794fdbfabbb1\":\"fs\"}],\"1irbL\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DockerfileParser = exports.DefaultVariables = exports.Directive = exports.Keyword = exports.Workdir = exports.Volume = exports.User = exports.Stopsignal = exports.Shell = exports.Run = exports.PropertyInstruction = exports.Onbuild = exports.ModifiableInstruction = exports.Label = exports.JSONInstruction = exports.Heredoc = exports.Healthcheck = exports.From = exports.Env = exports.Entrypoint = exports.Copy = exports.Cmd = exports.Arg = exports.Add = exports.Variable = exports.Property = exports.ParserDirective = exports.Line = exports.Instruction = exports.Flag = exports.Comment = exports.JSONArgument = exports.Argument = void 0;\nvar argument_1 = require(\"818c00e38db4fcf4\");\nObject.defineProperty(exports, \"Argument\", {\n    enumerable: true,\n    get: function() {\n        return argument_1.Argument;\n    }\n});\nvar jsonArgument_1 = require(\"c08f7534e96127a6\");\nObject.defineProperty(exports, \"JSONArgument\", {\n    enumerable: true,\n    get: function() {\n        return jsonArgument_1.JSONArgument;\n    }\n});\nconst comment_1 = require(\"1222b947cf52db6a\");\nObject.defineProperty(exports, \"Comment\", {\n    enumerable: true,\n    get: function() {\n        return comment_1.Comment;\n    }\n});\nconst parser_1 = require(\"76bd4faa688b3a6\");\nvar flag_1 = require(\"146dd26c02688bdf\");\nObject.defineProperty(exports, \"Flag\", {\n    enumerable: true,\n    get: function() {\n        return flag_1.Flag;\n    }\n});\nconst instruction_1 = require(\"580224f94f990f62\");\nObject.defineProperty(exports, \"Instruction\", {\n    enumerable: true,\n    get: function() {\n        return instruction_1.Instruction;\n    }\n});\nvar line_1 = require(\"b10e9f8eeb123952\");\nObject.defineProperty(exports, \"Line\", {\n    enumerable: true,\n    get: function() {\n        return line_1.Line;\n    }\n});\nconst parserDirective_1 = require(\"48560c9781a127f2\");\nObject.defineProperty(exports, \"ParserDirective\", {\n    enumerable: true,\n    get: function() {\n        return parserDirective_1.ParserDirective;\n    }\n});\nvar property_1 = require(\"32b923ba03725fba\");\nObject.defineProperty(exports, \"Property\", {\n    enumerable: true,\n    get: function() {\n        return property_1.Property;\n    }\n});\nvar variable_1 = require(\"38f5b7215a951c16\");\nObject.defineProperty(exports, \"Variable\", {\n    enumerable: true,\n    get: function() {\n        return variable_1.Variable;\n    }\n});\nvar add_1 = require(\"46fe02f5a4ca95f9\");\nObject.defineProperty(exports, \"Add\", {\n    enumerable: true,\n    get: function() {\n        return add_1.Add;\n    }\n});\nconst arg_1 = require(\"b50e6043532127e\");\nObject.defineProperty(exports, \"Arg\", {\n    enumerable: true,\n    get: function() {\n        return arg_1.Arg;\n    }\n});\nconst cmd_1 = require(\"6151c2d28c8d5622\");\nObject.defineProperty(exports, \"Cmd\", {\n    enumerable: true,\n    get: function() {\n        return cmd_1.Cmd;\n    }\n});\nconst copy_1 = require(\"302e65a20d20846c\");\nObject.defineProperty(exports, \"Copy\", {\n    enumerable: true,\n    get: function() {\n        return copy_1.Copy;\n    }\n});\nconst entrypoint_1 = require(\"3b8f9736d90d33e6\");\nObject.defineProperty(exports, \"Entrypoint\", {\n    enumerable: true,\n    get: function() {\n        return entrypoint_1.Entrypoint;\n    }\n});\nconst env_1 = require(\"73053c83e5457e82\");\nObject.defineProperty(exports, \"Env\", {\n    enumerable: true,\n    get: function() {\n        return env_1.Env;\n    }\n});\nconst from_1 = require(\"fb70244a02539db4\");\nObject.defineProperty(exports, \"From\", {\n    enumerable: true,\n    get: function() {\n        return from_1.From;\n    }\n});\nconst healthcheck_1 = require(\"ce38775557f57e2\");\nObject.defineProperty(exports, \"Healthcheck\", {\n    enumerable: true,\n    get: function() {\n        return healthcheck_1.Healthcheck;\n    }\n});\nvar heredoc_1 = require(\"3fc29578d4056add\");\nObject.defineProperty(exports, \"Heredoc\", {\n    enumerable: true,\n    get: function() {\n        return heredoc_1.Heredoc;\n    }\n});\nvar jsonInstruction_1 = require(\"110dc2f32a5a5c80\");\nObject.defineProperty(exports, \"JSONInstruction\", {\n    enumerable: true,\n    get: function() {\n        return jsonInstruction_1.JSONInstruction;\n    }\n});\nvar label_1 = require(\"ea70ab055c82b9c6\");\nObject.defineProperty(exports, \"Label\", {\n    enumerable: true,\n    get: function() {\n        return label_1.Label;\n    }\n});\nvar modifiableInstruction_1 = require(\"c1e4a9f72f3e4c8a\");\nObject.defineProperty(exports, \"ModifiableInstruction\", {\n    enumerable: true,\n    get: function() {\n        return modifiableInstruction_1.ModifiableInstruction;\n    }\n});\nvar onbuild_1 = require(\"1eb1f87000f1507b\");\nObject.defineProperty(exports, \"Onbuild\", {\n    enumerable: true,\n    get: function() {\n        return onbuild_1.Onbuild;\n    }\n});\nvar propertyInstruction_1 = require(\"f04eacef530f3101\");\nObject.defineProperty(exports, \"PropertyInstruction\", {\n    enumerable: true,\n    get: function() {\n        return propertyInstruction_1.PropertyInstruction;\n    }\n});\nvar run_1 = require(\"efc72f3780a14232\");\nObject.defineProperty(exports, \"Run\", {\n    enumerable: true,\n    get: function() {\n        return run_1.Run;\n    }\n});\nvar shell_1 = require(\"bb2b3970bd5df961\");\nObject.defineProperty(exports, \"Shell\", {\n    enumerable: true,\n    get: function() {\n        return shell_1.Shell;\n    }\n});\nvar stopsignal_1 = require(\"3f106ce05bb305c2\");\nObject.defineProperty(exports, \"Stopsignal\", {\n    enumerable: true,\n    get: function() {\n        return stopsignal_1.Stopsignal;\n    }\n});\nvar user_1 = require(\"26177b9c0e662cb0\");\nObject.defineProperty(exports, \"User\", {\n    enumerable: true,\n    get: function() {\n        return user_1.User;\n    }\n});\nvar volume_1 = require(\"657db89678e27c44\");\nObject.defineProperty(exports, \"Volume\", {\n    enumerable: true,\n    get: function() {\n        return volume_1.Volume;\n    }\n});\nconst workdir_1 = require(\"7c097a1fe36e1e9e\");\nObject.defineProperty(exports, \"Workdir\", {\n    enumerable: true,\n    get: function() {\n        return workdir_1.Workdir;\n    }\n});\nvar Keyword;\n(function(Keyword) {\n    Keyword[\"ADD\"] = \"ADD\";\n    Keyword[\"ARG\"] = \"ARG\";\n    Keyword[\"CMD\"] = \"CMD\";\n    Keyword[\"COPY\"] = \"COPY\";\n    Keyword[\"ENTRYPOINT\"] = \"ENTRYPOINT\";\n    Keyword[\"ENV\"] = \"ENV\";\n    Keyword[\"EXPOSE\"] = \"EXPOSE\";\n    Keyword[\"FROM\"] = \"FROM\";\n    Keyword[\"HEALTHCHECK\"] = \"HEALTHCHECK\";\n    Keyword[\"LABEL\"] = \"LABEL\";\n    Keyword[\"MAINTAINER\"] = \"MAINTAINER\";\n    Keyword[\"ONBUILD\"] = \"ONBUILD\";\n    Keyword[\"RUN\"] = \"RUN\";\n    Keyword[\"SHELL\"] = \"SHELL\";\n    Keyword[\"STOPSIGNAL\"] = \"STOPSIGNAL\";\n    Keyword[\"USER\"] = \"USER\";\n    Keyword[\"VOLUME\"] = \"VOLUME\";\n    Keyword[\"WORKDIR\"] = \"WORKDIR\";\n})(Keyword || (exports.Keyword = Keyword = {}));\nvar Directive;\n(function(Directive) {\n    Directive[\"escape\"] = \"escape\";\n    Directive[\"syntax\"] = \"syntax\";\n})(Directive || (exports.Directive = Directive = {}));\nexports.DefaultVariables = [\n    \"ALL_PROXY\",\n    \"all_proxy\",\n    \"FTP_PROXY\",\n    \"ftp_proxy\",\n    \"HTTP_PROXY\",\n    \"http_proxy\",\n    \"HTTPS_PROXY\",\n    \"https_proxy\",\n    \"NO_PROXY\",\n    \"no_proxy\"\n];\nvar DockerfileParser;\n(function(DockerfileParser) {\n    function parse(content) {\n        let parser = new parser_1.Parser();\n        return parser.parse(content);\n    }\n    DockerfileParser.parse = parse;\n})(DockerfileParser || (exports.DockerfileParser = DockerfileParser = {}));\n\n},{\"818c00e38db4fcf4\":\"j0TZA\",\"c08f7534e96127a6\":\"58ALy\",\"1222b947cf52db6a\":\"5T0KS\",\"76bd4faa688b3a6\":\"aGQ73\",\"146dd26c02688bdf\":\"2WqAd\",\"580224f94f990f62\":\"hMvuU\",\"b10e9f8eeb123952\":\"jax2A\",\"48560c9781a127f2\":\"jIw2h\",\"32b923ba03725fba\":\"gy5Z3\",\"38f5b7215a951c16\":\"eGHet\",\"46fe02f5a4ca95f9\":\"gRGNk\",\"b50e6043532127e\":\"aKTxx\",\"6151c2d28c8d5622\":\"9Gc1y\",\"302e65a20d20846c\":\"b3t88\",\"3b8f9736d90d33e6\":\"a7xJN\",\"73053c83e5457e82\":\"1F4QE\",\"fb70244a02539db4\":\"nTyT0\",\"ce38775557f57e2\":\"bkMBh\",\"3fc29578d4056add\":\"f2Bvm\",\"110dc2f32a5a5c80\":\"jxSFH\",\"ea70ab055c82b9c6\":\"57hgN\",\"c1e4a9f72f3e4c8a\":\"hJrte\",\"1eb1f87000f1507b\":\"8eYDK\",\"f04eacef530f3101\":\"hOqfp\",\"efc72f3780a14232\":\"bBCsY\",\"bb2b3970bd5df961\":\"j6kkx\",\"3f106ce05bb305c2\":\"bxm6V\",\"26177b9c0e662cb0\":\"bSHO0\",\"657db89678e27c44\":\"5fZdP\",\"7c097a1fe36e1e9e\":\"alCEF\"}],\"j0TZA\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Argument = void 0;\nclass Argument {\n    constructor(value, range){\n        this.value = value;\n        this.range = range;\n    }\n    toString() {\n        return this.value;\n    }\n    getRange() {\n        return this.range;\n    }\n    getValue() {\n        return this.value;\n    }\n    isAfter(position) {\n        if (this.range.end.line < position.line) return false;\n        return this.range.start.line > position.line ? true : this.range.start.character > position.character;\n    }\n    isBefore(position) {\n        if (this.range.start.line < position.line) return true;\n        return this.range.end.line > position.line ? false : this.range.end.character < position.character;\n    }\n}\nexports.Argument = Argument;\n\n},{}],\"58ALy\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.JSONArgument = void 0;\nconst argument_1 = require(\"60b94b0b95605351\");\nclass JSONArgument extends argument_1.Argument {\n    constructor(value, range, jsonRange){\n        super(value, range);\n        this.jsonRange = jsonRange;\n    }\n    getJSONRange() {\n        return this.jsonRange;\n    }\n    getJSONValue() {\n        let value = super.getValue();\n        value = value.substring(1, value.length - 1);\n        return value;\n    }\n}\nexports.JSONArgument = JSONArgument;\n\n},{\"60b94b0b95605351\":\"j0TZA\"}],\"5T0KS\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Comment = void 0;\nconst vscode_languageserver_types_1 = require(\"7469fdb9598c3ee1\");\nconst line_1 = require(\"236e9d8672ea26a2\");\nconst util_1 = require(\"d962123f7b2d05e\");\nclass Comment extends line_1.Line {\n    constructor(document, range){\n        super(document, range);\n    }\n    toString() {\n        const content = this.getContent();\n        if (content) return \"# \" + content;\n        return \"#\";\n    }\n    /**\n     * Returns the content of this comment. This excludes leading and\n     * trailing whitespace as well as the # symbol. If the comment only\n     * consists of whitespace, the empty string will be returned.\n     */ getContent() {\n        let range = this.getContentRange();\n        if (range === null) return \"\";\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    /**\n     * Returns a range that includes the content of the comment\n     * excluding any leading and trailing whitespace as well as the #\n     * symbol. May return null if the comment only consists of whitespace\n     * characters.\n     */ getContentRange() {\n        let range = this.getRange();\n        const startOffset = this.document.offsetAt(range.start);\n        let raw = this.document.getText().substring(startOffset, this.document.offsetAt(range.end));\n        let start = -1;\n        let end = -1;\n        // skip the first # symbol\n        for(let i = 1; i < raw.length; i++)if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n            start = i;\n            break;\n        }\n        if (start === -1) return null;\n        // go backwards up to the first # symbol\n        for(let i = raw.length - 1; i >= 1; i--)if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n            end = i + 1;\n            break;\n        }\n        return vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + start), this.document.positionAt(startOffset + end));\n    }\n}\nexports.Comment = Comment;\n\n},{\"7469fdb9598c3ee1\":\"ghSGy\",\"236e9d8672ea26a2\":\"jax2A\",\"d962123f7b2d05e\":\"7JXpr\"}],\"ghSGy\":[function(require,module,exports,__globalThis) {\n(function(factory) {\n    if (typeof module.exports === \"object\") {\n        var v = factory(undefined, exports);\n        if (v !== undefined) module.exports = v;\n    } else if (typeof define === \"function\" && define.amd) define([\n        \"require\",\n        \"exports\"\n    ], factory);\n})(function(require, exports1) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */ 'use strict';\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.TextDocument = exports1.EOL = exports1.WorkspaceFolder = exports1.InlineCompletionContext = exports1.SelectedCompletionInfo = exports1.InlineCompletionTriggerKind = exports1.InlineCompletionList = exports1.InlineCompletionItem = exports1.StringValue = exports1.InlayHint = exports1.InlayHintLabelPart = exports1.InlayHintKind = exports1.InlineValueContext = exports1.InlineValueEvaluatableExpression = exports1.InlineValueVariableLookup = exports1.InlineValueText = exports1.SemanticTokens = exports1.SemanticTokenModifiers = exports1.SemanticTokenTypes = exports1.SelectionRange = exports1.DocumentLink = exports1.FormattingOptions = exports1.CodeLens = exports1.CodeAction = exports1.CodeActionContext = exports1.CodeActionTriggerKind = exports1.CodeActionKind = exports1.DocumentSymbol = exports1.WorkspaceSymbol = exports1.SymbolInformation = exports1.SymbolTag = exports1.SymbolKind = exports1.DocumentHighlight = exports1.DocumentHighlightKind = exports1.SignatureInformation = exports1.ParameterInformation = exports1.Hover = exports1.MarkedString = exports1.CompletionList = exports1.CompletionItem = exports1.CompletionItemLabelDetails = exports1.InsertTextMode = exports1.InsertReplaceEdit = exports1.CompletionItemTag = exports1.InsertTextFormat = exports1.CompletionItemKind = exports1.MarkupContent = exports1.MarkupKind = exports1.TextDocumentItem = exports1.OptionalVersionedTextDocumentIdentifier = exports1.VersionedTextDocumentIdentifier = exports1.TextDocumentIdentifier = exports1.WorkspaceChange = exports1.WorkspaceEdit = exports1.DeleteFile = exports1.RenameFile = exports1.CreateFile = exports1.TextDocumentEdit = exports1.AnnotatedTextEdit = exports1.ChangeAnnotationIdentifier = exports1.ChangeAnnotation = exports1.TextEdit = exports1.Command = exports1.Diagnostic = exports1.CodeDescription = exports1.DiagnosticTag = exports1.DiagnosticSeverity = exports1.DiagnosticRelatedInformation = exports1.FoldingRange = exports1.FoldingRangeKind = exports1.ColorPresentation = exports1.ColorInformation = exports1.Color = exports1.LocationLink = exports1.Location = exports1.Range = exports1.Position = exports1.uinteger = exports1.integer = exports1.URI = exports1.DocumentUri = void 0;\n    var DocumentUri;\n    (function(DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports1.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function(URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports1.URI = URI = {}));\n    var integer;\n    (function(integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports1.integer = integer = {}));\n    var uinteger;\n    (function(uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports1.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */ var Position;\n    (function(Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */ function create(line, character) {\n            if (line === Number.MAX_VALUE) line = uinteger.MAX_VALUE;\n            if (character === Number.MAX_VALUE) character = uinteger.MAX_VALUE;\n            return {\n                line: line,\n                character: character\n            };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports1.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */ var Range;\n    (function(Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) return {\n                start: Position.create(one, two),\n                end: Position.create(three, four)\n            };\n            else if (Position.is(one) && Position.is(two)) return {\n                start: one,\n                end: two\n            };\n            else throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports1.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */ var Location;\n    (function(Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */ function create(uri, range) {\n            return {\n                uri: uri,\n                range: range\n            };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports1.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */ var LocationLink;\n    (function(LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return {\n                targetUri: targetUri,\n                targetRange: targetRange,\n                targetSelectionRange: targetSelectionRange,\n                originSelectionRange: originSelectionRange\n            };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports1.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */ var Color;\n    (function(Color) {\n        /**\n         * Creates a new Color literal.\n         */ function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports1.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */ var ColorInformation;\n    (function(ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */ function create(range, color) {\n            return {\n                range: range,\n                color: color\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports1.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */ var ColorPresentation;\n    (function(ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */ function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports1.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */ var FoldingRangeKind;\n    (function(FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */ FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */ FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */ FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports1.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */ var FoldingRange;\n    (function(FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) result.startCharacter = startCharacter;\n            if (Is.defined(endCharacter)) result.endCharacter = endCharacter;\n            if (Is.defined(kind)) result.kind = kind;\n            if (Is.defined(collapsedText)) result.collapsedText = collapsedText;\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports1.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */ var DiagnosticRelatedInformation;\n    (function(DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */ function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports1.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */ var DiagnosticSeverity;\n    (function(DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */ DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */ DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */ DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */ DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports1.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */ var DiagnosticTag;\n    (function(DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */ DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */ DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports1.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */ var CodeDescription;\n    (function(CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports1.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */ var Diagnostic;\n    (function(Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */ function create(range, message, severity, code, source, relatedInformation) {\n            var result = {\n                range: range,\n                message: message\n            };\n            if (Is.defined(severity)) result.severity = severity;\n            if (Is.defined(code)) result.code = code;\n            if (Is.defined(source)) result.source = source;\n            if (Is.defined(relatedInformation)) result.relatedInformation = relatedInformation;\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */ function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports1.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */ var Command;\n    (function(Command) {\n        /**\n         * Creates a new Command literal.\n         */ function create(title, command) {\n            var args = [];\n            for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];\n            var result = {\n                title: title,\n                command: command\n            };\n            if (Is.defined(args) && args.length > 0) result.arguments = args;\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports1.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */ var TextEdit;\n    (function(TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */ function replace(range, newText) {\n            return {\n                range: range,\n                newText: newText\n            };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */ function insert(position, newText) {\n            return {\n                range: {\n                    start: position,\n                    end: position\n                },\n                newText: newText\n            };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */ function del(range) {\n            return {\n                range: range,\n                newText: ''\n            };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports1.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function(ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = {\n                label: label\n            };\n            if (needsConfirmation !== undefined) result.needsConfirmation = needsConfirmation;\n            if (description !== undefined) result.description = description;\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports1.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function(ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports1.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function(AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */ function replace(range, newText, annotation) {\n            return {\n                range: range,\n                newText: newText,\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */ function insert(position, newText, annotation) {\n            return {\n                range: {\n                    start: position,\n                    end: position\n                },\n                newText: newText,\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */ function del(range, annotation) {\n            return {\n                range: range,\n                newText: '',\n                annotationId: annotation\n            };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports1.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */ var TextDocumentEdit;\n    (function(TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */ function create(textDocument, edits) {\n            return {\n                textDocument: textDocument,\n                edits: edits\n            };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports1.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function(CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports1.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function(RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports1.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function(DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) result.options = options;\n            if (annotation !== undefined) result.annotationId = annotation;\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports1.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function(WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {\n                if (Is.string(change.kind)) return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                else return TextDocumentEdit.is(change);\n            }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports1.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ function() {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.insert(position, newText);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.replace(range, newText);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.delete = function(range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) edit = TextEdit.del(range);\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            } else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) return id;\n        };\n        TextEditChangeImpl.prototype.add = function(edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function() {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function() {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {\n            if (value === undefined) throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        };\n        return TextEditChangeImpl;\n    }();\n    /**\n     * A helper class\n     */ var ChangeAnnotations = /** @class */ function() {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function() {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function() {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) id = idOrAnnotation;\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            if (annotation === undefined) throw new Error(\"No annotation provided for id \".concat(id));\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function() {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }();\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */ var WorkspaceChange = /** @class */ function() {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function(change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                } else if (workspaceEdit.changes) Object.keys(workspaceEdit.changes).forEach(function(key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            } else this._workspaceEdit = {};\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */ get: function() {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) this._workspaceEdit.changeAnnotations = undefined;\n                    else this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function(key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n                var textDocument = {\n                    uri: key.uri,\n                    version: key.version\n                };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            } else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) throw new Error('Workspace edit is not configured for normal text edit changes.');\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function() {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function() {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) this._workspaceEdit.changes = Object.create(null);\n        };\n        WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = CreateFile.create(uri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = RenameFile.create(oldUri, newUri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) throw new Error('Workspace edit is not configured for document changes.');\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) annotation = optionsOrAnnotation;\n            else options = optionsOrAnnotation;\n            var operation;\n            var id;\n            if (annotation === undefined) operation = DeleteFile.create(uri, options);\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) return id;\n        };\n        return WorkspaceChange;\n    }();\n    exports1.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */ var TextDocumentIdentifier;\n    (function(TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */ function create(uri) {\n            return {\n                uri: uri\n            };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports1.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */ var VersionedTextDocumentIdentifier;\n    (function(VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */ function create(uri, version) {\n            return {\n                uri: uri,\n                version: version\n            };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports1.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */ var OptionalVersionedTextDocumentIdentifier;\n    (function(OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */ function create(uri, version) {\n            return {\n                uri: uri,\n                version: version\n            };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports1.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */ var TextDocumentItem;\n    (function(TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */ function create(uri, languageId, version, text) {\n            return {\n                uri: uri,\n                languageId: languageId,\n                version: version,\n                text: text\n            };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports1.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */ var MarkupKind;\n    (function(MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */ MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */ MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */ function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports1.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function(MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports1.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */ var CompletionItemKind;\n    (function(CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports1.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */ var InsertTextFormat;\n    (function(InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */ InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */ InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports1.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */ var CompletionItemTag;\n    (function(CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */ CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports1.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */ var InsertReplaceEdit;\n    (function(InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */ function create(newText, insert, replace) {\n            return {\n                newText: newText,\n                insert: insert,\n                replace: replace\n            };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */ function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports1.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */ var InsertTextMode;\n    (function(InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */ InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */ InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports1.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function(CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports1.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */ var CompletionItem;\n    (function(CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */ function create(label) {\n            return {\n                label: label\n            };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports1.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */ var CompletionList;\n    (function(CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */ function create(items, isIncomplete) {\n            return {\n                items: items ? items : [],\n                isIncomplete: !!isIncomplete\n            };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports1.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function(MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */ function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */ function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports1.MarkedString = MarkedString = {}));\n    var Hover;\n    (function(Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */ function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports1.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */ var ParameterInformation;\n    (function(ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */ function create(label, documentation) {\n            return documentation ? {\n                label: label,\n                documentation: documentation\n            } : {\n                label: label\n            };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports1.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */ var SignatureInformation;\n    (function(SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for(var _i = 2; _i < arguments.length; _i++)parameters[_i - 2] = arguments[_i];\n            var result = {\n                label: label\n            };\n            if (Is.defined(documentation)) result.documentation = documentation;\n            if (Is.defined(parameters)) result.parameters = parameters;\n            else result.parameters = [];\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports1.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */ var DocumentHighlightKind;\n    (function(DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */ DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */ DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */ DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports1.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */ var DocumentHighlight;\n    (function(DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */ function create(range, kind) {\n            var result = {\n                range: range\n            };\n            if (Is.number(kind)) result.kind = kind;\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports1.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */ var SymbolKind;\n    (function(SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports1.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */ var SymbolTag;\n    (function(SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */ SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports1.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function(SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */ function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri,\n                    range: range\n                }\n            };\n            if (containerName) result.containerName = containerName;\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports1.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function(WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */ function create(name, kind, uri, range) {\n            return range !== undefined ? {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri,\n                    range: range\n                }\n            } : {\n                name: name,\n                kind: kind,\n                location: {\n                    uri: uri\n                }\n            };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports1.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function(DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */ function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) result.children = children;\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */ function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports1.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */ var CodeActionKind;\n    (function(CodeActionKind) {\n        /**\n         * Empty kind.\n         */ CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */ CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */ CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */ CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */ CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */ CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */ CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports1.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */ var CodeActionTriggerKind;\n    (function(CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */ CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */ CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports1.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */ var CodeActionContext;\n    (function(CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */ function create(diagnostics, only, triggerKind) {\n            var result = {\n                diagnostics: diagnostics\n            };\n            if (only !== undefined && only !== null) result.only = only;\n            if (triggerKind !== undefined && triggerKind !== null) result.triggerKind = triggerKind;\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports1.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function(CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = {\n                title: title\n            };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            } else if (Command.is(kindOrCommandOrEdit)) result.command = kindOrCommandOrEdit;\n            else result.edit = kindOrCommandOrEdit;\n            if (checkKind && kind !== undefined) result.kind = kind;\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports1.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */ var CodeLens;\n    (function(CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */ function create(range, data) {\n            var result = {\n                range: range\n            };\n            if (Is.defined(data)) result.data = data;\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports1.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */ var FormattingOptions;\n    (function(FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */ function create(tabSize, insertSpaces) {\n            return {\n                tabSize: tabSize,\n                insertSpaces: insertSpaces\n            };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports1.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */ var DocumentLink;\n    (function(DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */ function create(range, target, data) {\n            return {\n                range: range,\n                target: target,\n                data: data\n            };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports1.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */ var SelectionRange;\n    (function(SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */ function create(range, parent) {\n            return {\n                range: range,\n                parent: parent\n            };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports1.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */ var SemanticTokenTypes;\n    (function(SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */ SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */ SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports1.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */ var SemanticTokenModifiers;\n    (function(SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports1.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */ var SemanticTokens;\n    (function(SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports1.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */ var InlineValueText;\n    (function(InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */ function create(range, text) {\n            return {\n                range: range,\n                text: text\n            };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports1.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */ var InlineValueVariableLookup;\n    (function(InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */ function create(range, variableName, caseSensitiveLookup) {\n            return {\n                range: range,\n                variableName: variableName,\n                caseSensitiveLookup: caseSensitiveLookup\n            };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports1.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */ var InlineValueEvaluatableExpression;\n    (function(InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */ function create(range, expression) {\n            return {\n                range: range,\n                expression: expression\n            };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports1.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */ var InlineValueContext;\n    (function(InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */ function create(frameId, stoppedLocation) {\n            return {\n                frameId: frameId,\n                stoppedLocation: stoppedLocation\n            };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports1.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */ var InlayHintKind;\n    (function(InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */ InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */ InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports1.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function(InlayHintLabelPart) {\n        function create(value) {\n            return {\n                value: value\n            };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports1.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function(InlayHint) {\n        function create(position, label, kind) {\n            var result = {\n                position: position,\n                label: label\n            };\n            if (kind !== undefined) result.kind = kind;\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports1.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function(StringValue) {\n        function createSnippet(value) {\n            return {\n                kind: 'snippet',\n                value: value\n            };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports1.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function(InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return {\n                insertText: insertText,\n                filterText: filterText,\n                range: range,\n                command: command\n            };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports1.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function(InlineCompletionList) {\n        function create(items) {\n            return {\n                items: items\n            };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports1.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */ var InlineCompletionTriggerKind;\n    (function(InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */ InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */ InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports1.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function(SelectedCompletionInfo) {\n        function create(range, text) {\n            return {\n                range: range,\n                text: text\n            };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports1.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function(InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return {\n                triggerKind: triggerKind,\n                selectedCompletionInfo: selectedCompletionInfo\n            };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports1.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function(WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports1.WorkspaceFolder = WorkspaceFolder = {}));\n    exports1.EOL = [\n        '\\n',\n        '\\r\\n',\n        '\\r'\n    ];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */ var TextDocument;\n    (function(TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */ function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */ function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function(a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) return a.range.start.character - b.range.start.character;\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for(var i = sortedEdits.length - 1; i >= 0; i--){\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                else throw new Error('Overlapping edit');\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) // sorted\n            return data;\n            var p = data.length / 2 | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while(leftIdx < left.length && rightIdx < right.length){\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n                else // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n            while(leftIdx < left.length)data[i++] = left[leftIdx++];\n            while(rightIdx < right.length)data[i++] = right[rightIdx++];\n            return data;\n        }\n    })(TextDocument || (exports1.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */ var FullTextDocument = /** @class */ function() {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function() {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function() {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function() {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function(range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function(event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function() {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for(var i = 0; i < text.length; i++){\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = ch === '\\r' || ch === '\\n';\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') i++;\n                }\n                if (isLineStart && text.length > 0) lineOffsets.push(text.length);\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function(offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) return Position.create(0, offset);\n            while(low < high){\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) high = mid;\n                else low = mid + 1;\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function(position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) return this._content.length;\n            else if (position.line < 0) return 0;\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function() {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }();\n    var Is;\n    (function(Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined1(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined1;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n\n},{}],\"jax2A\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Line = void 0;\nclass Line {\n    constructor(document, range){\n        this.document = document;\n        this.range = range;\n    }\n    getRange() {\n        return this.range;\n    }\n    getTextContent() {\n        return this.document.getText().substring(this.document.offsetAt(this.range.start), this.document.offsetAt(this.range.end));\n    }\n    isAfter(line) {\n        return this.range.start.line > line.range.start.line;\n    }\n    isBefore(line) {\n        return this.range.start.line < line;\n    }\n}\nexports.Line = Line;\n\n},{}],\"7JXpr\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Util = void 0;\nclass Util {\n    static isUTF8BOM(char) {\n        const uintArray = Uint8Array.from(Buffer.from(char, \"UTF-8\"));\n        return uintArray[0] === 0xEF && uintArray[1] == 0xBB && uintArray[2] == 0xBF;\n    }\n    static isWhitespace(char) {\n        return char === ' ' || char === '\\t' || Util.isNewline(char);\n    }\n    static isNewline(char) {\n        return char === '\\r' || char === '\\n';\n    }\n    static findLeadingNonWhitespace(content, escapeChar) {\n        whitespaceCheck: for(let i = 0; i < content.length; i++)switch(content.charAt(i)){\n            case ' ':\n            case '\\t':\n                continue;\n            case escapeChar:\n                escapeCheck: for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        continue;\n                    case '\\r':\n                        // offset one more for \\r\\n\n                        i = j + 1;\n                        continue whitespaceCheck;\n                    case '\\n':\n                        i = j;\n                        continue whitespaceCheck;\n                    default:\n                        break escapeCheck;\n                }\n                // found an escape character and then reached EOF\n                return -1;\n            default:\n                return i;\n        }\n        // only possible if the content is the empty string\n        return -1;\n    }\n    /**\n     * Determines if the given position is contained within the given range.\n     *\n     * @param position the position to check\n     * @param range the range to see if the position is inside of\n     */ static isInsideRange(position, range) {\n        if (range.start.line === range.end.line) return range.start.line === position.line && range.start.character <= position.character && position.character <= range.end.character;\n        else if (range.start.line === position.line) return range.start.character <= position.character;\n        else if (range.end.line === position.line) return position.character <= range.end.character;\n        return range.start.line < position.line && position.line < range.end.line;\n    }\n    static parseHeredocName(value) {\n        value = value.substring(2);\n        if (value.charAt(0) === '-') value = value.substring(1);\n        if (value.charAt(0) === '\"') {\n            if (value.charAt(value.length - 1) !== '\"') return null;\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === '\\'') {\n            if (value.charAt(value.length - 1) !== '\\'') return null;\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === \"<\") return null;\n        return value;\n    }\n}\nexports.Util = Util;\n\n},{}],\"aGQ73\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Parser = void 0;\nconst vscode_languageserver_textdocument_1 = require(\"3eb2e9f72fa842bb\");\nconst vscode_languageserver_types_1 = require(\"34b2e1cd00de16ce\");\nconst comment_1 = require(\"9e92b8b410126e56\");\nconst parserDirective_1 = require(\"777f0037af770a91\");\nconst instruction_1 = require(\"1329dffc7d9471c6\");\nconst add_1 = require(\"5065fff407b0cdf5\");\nconst arg_1 = require(\"aa6e0b7a0eb2c8a9\");\nconst cmd_1 = require(\"62420b33948711ba\");\nconst copy_1 = require(\"44a1387c9f6642f8\");\nconst env_1 = require(\"c3c835dbabebb0c\");\nconst entrypoint_1 = require(\"a1a0bf4df6e06e65\");\nconst from_1 = require(\"ac2ea75013335655\");\nconst healthcheck_1 = require(\"fbf71dd210ee2ad2\");\nconst label_1 = require(\"17f71289f1308509\");\nconst onbuild_1 = require(\"abac336e7fc664aa\");\nconst run_1 = require(\"d4206ac9dc34f56c\");\nconst shell_1 = require(\"341b73fd8ae672e8\");\nconst stopsignal_1 = require(\"44cf25b6f2d37d9\");\nconst workdir_1 = require(\"9247ddaff67cb60c\");\nconst user_1 = require(\"b96409d6175d837f\");\nconst volume_1 = require(\"4febb7a38de581a6\");\nconst dockerfile_1 = require(\"50edac4bf8b150b0\");\nconst util_1 = require(\"f9cdab4223270f96\");\nconst main_1 = require(\"38bd78812b171580\");\nclass Parser {\n    constructor(){\n        this.escapeChar = null;\n    }\n    static createInstruction(document, dockerfile, escapeChar, lineRange, instruction, instructionRange) {\n        switch(instruction.toUpperCase()){\n            case \"ADD\":\n                return new add_1.Add(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ARG\":\n                return new arg_1.Arg(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"CMD\":\n                return new cmd_1.Cmd(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"COPY\":\n                return new copy_1.Copy(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENTRYPOINT\":\n                return new entrypoint_1.Entrypoint(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENV\":\n                return new env_1.Env(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"FROM\":\n                return new from_1.From(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"HEALTHCHECK\":\n                return new healthcheck_1.Healthcheck(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"LABEL\":\n                return new label_1.Label(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ONBUILD\":\n                return new onbuild_1.Onbuild(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"RUN\":\n                return new run_1.Run(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"SHELL\":\n                return new shell_1.Shell(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"STOPSIGNAL\":\n                return new stopsignal_1.Stopsignal(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"WORKDIR\":\n                return new workdir_1.Workdir(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"USER\":\n                return new user_1.User(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"VOLUME\":\n                return new volume_1.Volume(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n        }\n        return new instruction_1.Instruction(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getParserDirectives(document, buffer) {\n        // reset the escape directive in between runs\n        const directives = [];\n        this.escapeChar = '';\n        const offset = util_1.Util.isUTF8BOM(buffer.substring(0, 1)) ? 1 : 0;\n        directiveCheck: for(let i = offset; i < buffer.length; i++)switch(buffer.charAt(i)){\n            case ' ':\n            case '\\t':\n                break;\n            case '\\r':\n            case '\\n':\n                break directiveCheck;\n            case '#':\n                let directiveStart = -1;\n                let directiveEnd = -1;\n                for(let j = i + 1; j < buffer.length; j++){\n                    let char = buffer.charAt(j);\n                    switch(char){\n                        case ' ':\n                        case '\\t':\n                            if (directiveStart !== -1 && directiveEnd === -1) directiveEnd = j;\n                            break;\n                        case '\\r':\n                        case '\\n':\n                            break directiveCheck;\n                        case '=':\n                            let valueStart = -1;\n                            let valueEnd = -1;\n                            if (directiveEnd === -1) directiveEnd = j;\n                            // assume the line ends with the file\n                            let lineEnd = buffer.length;\n                            directiveValue: for(let k = j + 1; k < buffer.length; k++){\n                                char = buffer.charAt(k);\n                                switch(char){\n                                    case '\\r':\n                                    case '\\n':\n                                        if (valueStart !== -1 && valueEnd === -1) valueEnd = k;\n                                        // line break found, reset\n                                        lineEnd = k;\n                                        break directiveValue;\n                                    case '\\t':\n                                    case ' ':\n                                        if (valueStart !== -1 && valueEnd === -1) valueEnd = k;\n                                        continue;\n                                    default:\n                                        if (valueStart === -1) valueStart = k;\n                                        break;\n                                }\n                            }\n                            if (directiveStart === -1) break directiveCheck;\n                            if (valueStart === -1) {\n                                // no non-whitespace characters found, highlight all the characters then\n                                valueStart = j + 1;\n                                valueEnd = lineEnd;\n                            } else if (valueEnd === -1) // reached EOF\n                            valueEnd = buffer.length;\n                            const lineRange = vscode_languageserver_types_1.Range.create(document.positionAt(i), document.positionAt(lineEnd));\n                            const nameRange = vscode_languageserver_types_1.Range.create(document.positionAt(directiveStart), document.positionAt(directiveEnd));\n                            const valueRange = vscode_languageserver_types_1.Range.create(document.positionAt(valueStart), document.positionAt(valueEnd));\n                            directives.push(new parserDirective_1.ParserDirective(document, lineRange, nameRange, valueRange));\n                            directiveStart = -1;\n                            if (buffer.charAt(valueEnd) === '\\r') // skip over the \\r\n                            i = valueEnd + 1;\n                            else i = valueEnd;\n                            continue directiveCheck;\n                        default:\n                            if (directiveStart === -1) directiveStart = j;\n                            break;\n                    }\n                }\n                break;\n            default:\n                break directiveCheck;\n        }\n        return directives;\n    }\n    parse(buffer) {\n        this.document = vscode_languageserver_textdocument_1.TextDocument.create(\"\", \"\", 0, buffer);\n        this.buffer = buffer;\n        let dockerfile = new dockerfile_1.Dockerfile(this.document);\n        let directives = this.getParserDirectives(this.document, this.buffer);\n        let offset = 0;\n        this.escapeChar = '\\\\';\n        if (directives.length > 0) {\n            dockerfile.setDirectives(directives);\n            this.escapeChar = dockerfile.getEscapeCharacter();\n            // start parsing after the directives\n            offset = this.document.offsetAt(vscode_languageserver_types_1.Position.create(directives.length, 0));\n        } else if (util_1.Util.isUTF8BOM(buffer.substring(0, 1))) offset = 1;\n        for(let i = offset; i < this.buffer.length; i++){\n            const char = this.buffer.charAt(i);\n            switch(char){\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '#':\n                    i = this.processComment(dockerfile, i);\n                    break;\n                default:\n                    i = this.processInstruction(dockerfile, char, i);\n                    break;\n            }\n        }\n        dockerfile.organizeComments();\n        return dockerfile;\n    }\n    processInstruction(dockerfile, char, start) {\n        let instruction = char;\n        let instructionEnd = -1;\n        let escapedInstruction = false;\n        instructionCheck: for(let i = start + 1; i < this.buffer.length; i++){\n            char = this.buffer.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    escapedInstruction = true;\n                    char = this.buffer.charAt(i + 1);\n                    if (char === '\\r' || char === '\\n') {\n                        if (instructionEnd === -1) instructionEnd = i;\n                        i++;\n                    } else if (char === ' ' || char === '\\t') {\n                        for(let j = i + 2; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                i = j;\n                                continue instructionCheck;\n                            default:\n                                // found an argument, mark end of instruction\n                                instructionEnd = i + 1;\n                                instruction = instruction + this.escapeChar;\n                                i = j - 2;\n                                continue instructionCheck;\n                        }\n                        // reached EOF\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        break instructionCheck;\n                    } else {\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        // reset and consider it as one contiguous word\n                        escapedInstruction = false;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escapedInstruction) {\n                        // on an escaped newline, need to search for non-whitespace\n                        escapeCheck: for(let j = i + 1; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                i = j;\n                                continue instructionCheck;\n                            default:\n                                break escapeCheck;\n                        }\n                        escapedInstruction = false;\n                    }\n                    if (instructionEnd === -1) instructionEnd = i;\n                    i = this.processArguments(dockerfile, instruction, instructionEnd, start, i);\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, i));\n                    return i;\n                case '\\r':\n                case '\\n':\n                    if (escapedInstruction) continue;\n                    if (instructionEnd === -1) instructionEnd = i;\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, i, i));\n                    return i;\n                case '#':\n                    if (escapedInstruction) continue;\n                default:\n                    instructionEnd = i + 1;\n                    instruction = instruction + char;\n                    escapedInstruction = false;\n                    break;\n            }\n        }\n        // reached EOF\n        if (instructionEnd === -1) instructionEnd = this.buffer.length;\n        dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, this.buffer.length));\n        return this.buffer.length;\n    }\n    processHeredocs(instruction, offset) {\n        let keyword = instruction.getKeyword();\n        if (keyword === main_1.Keyword.ONBUILD) {\n            instruction = instruction.getTriggerInstruction();\n            if (instruction === null) return offset;\n            keyword = instruction.getKeyword();\n        }\n        if (keyword !== main_1.Keyword.ADD && keyword !== main_1.Keyword.COPY && keyword !== main_1.Keyword.RUN) return offset;\n        const heredocs = [];\n        for (const arg of instruction.getArguments()){\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && value.length > 2) {\n                const name = util_1.Util.parseHeredocName(value);\n                if (name !== null) heredocs.push(name);\n            }\n        }\n        if (heredocs.length > 0) for (const heredoc of heredocs)offset = this.parseHeredoc(heredoc, offset);\n        return offset;\n    }\n    processArguments(dockerfile, instruction, instructionEnd, start, offset) {\n        let escaped = false;\n        argumentsCheck: for(let i = offset + 1; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case '\\r':\n            case '\\n':\n                if (escaped) continue;\n                return this.processHeredocs(this.createInstruction(dockerfile, instruction, start, instructionEnd, i), i);\n            case this.escapeChar:\n                const next = this.buffer.charAt(i + 1);\n                if (next === '\\n' || next === '\\r') {\n                    escaped = true;\n                    i++;\n                } else if (next === ' ' || next === '\\t') {\n                    for(let j = i + 2; j < this.buffer.length; j++)switch(this.buffer.charAt(j)){\n                        case ' ':\n                        case '\\t':\n                            break;\n                        case '\\r':\n                        case '\\n':\n                            escaped = true;\n                        default:\n                            i = j;\n                            continue argumentsCheck;\n                    }\n                    // reached EOF\n                    return this.buffer.length;\n                }\n                continue;\n            case '#':\n                if (escaped) {\n                    i = this.processComment(dockerfile, i);\n                    continue argumentsCheck;\n                }\n                break;\n            case ' ':\n            case '\\t':\n                break;\n            default:\n                if (escaped) escaped = false;\n                break;\n        }\n        return this.buffer.length;\n    }\n    processComment(dockerfile, start) {\n        let end = this.buffer.length;\n        commentLoop: for(let i = start + 1; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case '\\r':\n            case '\\n':\n                end = i;\n                break commentLoop;\n        }\n        const range = vscode_languageserver_types_1.Range.create(this.document.positionAt(start), this.document.positionAt(end));\n        dockerfile.addComment(new comment_1.Comment(this.document, range));\n        return end;\n    }\n    parseHeredoc(heredocName, offset) {\n        let startWord = -1;\n        let lineStart = true;\n        for(let i = offset; i < this.buffer.length; i++)switch(this.buffer.charAt(i)){\n            case ' ':\n            case '\\t':\n                lineStart = false;\n                break;\n            case '\\r':\n            case '\\n':\n                if (startWord !== -1 && heredocName === this.buffer.substring(startWord, i)) return i;\n                startWord = -1;\n                lineStart = true;\n                break;\n            default:\n                if (lineStart) {\n                    startWord = i;\n                    lineStart = false;\n                }\n                break;\n        }\n        return this.buffer.length;\n    }\n    createInstruction(dockerfile, instruction, start, instructionEnd, end) {\n        const startPosition = this.document.positionAt(start);\n        const instructionRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(instructionEnd));\n        const lineRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(end));\n        return Parser.createInstruction(this.document, dockerfile, this.escapeChar, lineRange, instruction, instructionRange);\n    }\n}\nexports.Parser = Parser;\n\n},{\"3eb2e9f72fa842bb\":\"fnQzO\",\"34b2e1cd00de16ce\":\"ghSGy\",\"9e92b8b410126e56\":\"5T0KS\",\"777f0037af770a91\":\"jIw2h\",\"1329dffc7d9471c6\":\"hMvuU\",\"5065fff407b0cdf5\":\"gRGNk\",\"aa6e0b7a0eb2c8a9\":\"aKTxx\",\"62420b33948711ba\":\"9Gc1y\",\"44a1387c9f6642f8\":\"b3t88\",\"c3c835dbabebb0c\":\"1F4QE\",\"a1a0bf4df6e06e65\":\"a7xJN\",\"ac2ea75013335655\":\"nTyT0\",\"fbf71dd210ee2ad2\":\"bkMBh\",\"17f71289f1308509\":\"57hgN\",\"abac336e7fc664aa\":\"8eYDK\",\"d4206ac9dc34f56c\":\"bBCsY\",\"341b73fd8ae672e8\":\"j6kkx\",\"44cf25b6f2d37d9\":\"bxm6V\",\"9247ddaff67cb60c\":\"alCEF\",\"b96409d6175d837f\":\"bSHO0\",\"4febb7a38de581a6\":\"5fZdP\",\"50edac4bf8b150b0\":\"040Bk\",\"f9cdab4223270f96\":\"7JXpr\",\"38bd78812b171580\":\"1irbL\"}],\"fnQzO\":[function(require,module,exports,__globalThis) {\nvar __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) {\n        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n(function(factory) {\n    if (typeof module.exports === \"object\") {\n        var v = factory(undefined, exports);\n        if (v !== undefined) module.exports = v;\n    } else if (typeof define === \"function\" && define.amd) define([\n        \"require\",\n        \"exports\"\n    ], factory);\n})(function(require, exports1) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */ 'use strict';\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.TextDocument = void 0;\n    var FullTextDocument = /** @class */ function() {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function() {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function() {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function() {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function(range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function(changes, version) {\n            for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){\n                var change = changes_1[_i];\n                if (FullTextDocument.isIncremental(change)) {\n                    // makes sure start is before end\n                    var range = getWellformedRange(change.range);\n                    // update content\n                    var startOffset = this.offsetAt(range.start);\n                    var endOffset = this.offsetAt(range.end);\n                    this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                    // update the offsets\n                    var startLine = Math.max(range.start.line, 0);\n                    var endLine = Math.max(range.end.line, 0);\n                    var lineOffsets = this._lineOffsets;\n                    var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                    if (endLine - startLine === addedLineOffsets.length) for(var i = 0, len = addedLineOffsets.length; i < len; i++)lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    else if (addedLineOffsets.length < 10000) lineOffsets.splice.apply(lineOffsets, __spreadArray([\n                        startLine + 1,\n                        endLine - startLine\n                    ], addedLineOffsets, false));\n                    else this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    var diff = change.text.length - (endOffset - startOffset);\n                    if (diff !== 0) for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++)lineOffsets[i] = lineOffsets[i] + diff;\n                } else if (FullTextDocument.isFull(change)) {\n                    this._content = change.text;\n                    this._lineOffsets = undefined;\n                } else throw new Error('Unknown change event received');\n            }\n            this._version = version;\n        };\n        FullTextDocument.prototype.getLineOffsets = function() {\n            if (this._lineOffsets === undefined) this._lineOffsets = computeLineOffsets(this._content, true);\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function(offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) return {\n                line: 0,\n                character: offset\n            };\n            while(low < high){\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) high = mid;\n                else low = mid + 1;\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n            return {\n                line: line,\n                character: offset - lineOffsets[line]\n            };\n        };\n        FullTextDocument.prototype.offsetAt = function(position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) return this._content.length;\n            else if (position.line < 0) return 0;\n            var lineOffset = lineOffsets[position.line];\n            if (position.character <= 0) return lineOffset;\n            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n            var offset = Math.min(lineOffset + position.character, nextLineOffset);\n            return this.ensureBeforeEOL(offset, lineOffset);\n        };\n        FullTextDocument.prototype.ensureBeforeEOL = function(offset, lineOffset) {\n            while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1)))offset--;\n            return offset;\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function() {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.isIncremental = function(event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n        };\n        FullTextDocument.isFull = function(event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n        };\n        return FullTextDocument;\n    }();\n    var TextDocument;\n    (function(TextDocument) {\n        /**\n         * Creates a new text document.\n         *\n         * @param uri The document's uri.\n         * @param languageId  The document's language Id.\n         * @param version The document's initial version number.\n         * @param content The document's content.\n         */ function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Updates a TextDocument by modifying its content.\n         *\n         * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n         * @param changes the changes to apply to the document.\n         * @param version the changes version for the document.\n         * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n         *\n         */ function update(document, changes, version) {\n            if (document instanceof FullTextDocument) {\n                document.update(changes, version);\n                return document;\n            } else throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n        TextDocument.update = update;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) return a.range.start.character - b.range.start.character;\n                return diff;\n            });\n            var lastModifiedOffset = 0;\n            var spans = [];\n            for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){\n                var e = sortedEdits_1[_i];\n                var startOffset = document.offsetAt(e.range.start);\n                if (startOffset < lastModifiedOffset) throw new Error('Overlapping edit');\n                else if (startOffset > lastModifiedOffset) spans.push(text.substring(lastModifiedOffset, startOffset));\n                if (e.newText.length) spans.push(e.newText);\n                lastModifiedOffset = document.offsetAt(e.range.end);\n            }\n            spans.push(text.substr(lastModifiedOffset));\n            return spans.join('');\n        }\n        TextDocument.applyEdits = applyEdits;\n    })(TextDocument || (exports1.TextDocument = TextDocument = {}));\n    function mergeSort(data, compare) {\n        if (data.length <= 1) // sorted\n        return data;\n        var p = data.length / 2 | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while(leftIdx < left.length && rightIdx < right.length){\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n            else // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n        while(leftIdx < left.length)data[i++] = left[leftIdx++];\n        while(rightIdx < right.length)data[i++] = right[rightIdx++];\n        return data;\n    }\n    function computeLineOffsets(text, isAtLineStart, textOffset) {\n        if (textOffset === void 0) textOffset = 0;\n        var result = isAtLineStart ? [\n            textOffset\n        ] : [];\n        for(var i = 0; i < text.length; i++){\n            var ch = text.charCodeAt(i);\n            if (isEOL(ch)) {\n                if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) i++;\n                result.push(textOffset + i + 1);\n            }\n        }\n        return result;\n    }\n    function isEOL(char) {\n        return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;\n    }\n    function getWellformedRange(range) {\n        var start = range.start;\n        var end = range.end;\n        if (start.line > end.line || start.line === end.line && start.character > end.character) return {\n            start: end,\n            end: start\n        };\n        return range;\n    }\n    function getWellformedEdit(textEdit) {\n        var range = getWellformedRange(textEdit.range);\n        if (range !== textEdit.range) return {\n            newText: textEdit.newText,\n            range: range\n        };\n        return textEdit;\n    }\n});\n\n},{}],\"jIw2h\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ParserDirective = void 0;\nconst main_1 = require(\"83344ee6e442f65c\");\nconst line_1 = require(\"628c95531afa43c2\");\nclass ParserDirective extends line_1.Line {\n    constructor(document, range, nameRange, valueRange){\n        super(document, range);\n        this.nameRange = nameRange;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        return \"# \" + this.getName() + '=' + this.getValue();\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    getName() {\n        return this.document.getText().substring(this.document.offsetAt(this.nameRange.start), this.document.offsetAt(this.nameRange.end));\n    }\n    getValue() {\n        return this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n    }\n    getDirective() {\n        const directive = main_1.Directive[this.getName().toLowerCase()];\n        return directive === undefined ? null : directive;\n    }\n}\nexports.ParserDirective = ParserDirective;\n\n},{\"83344ee6e442f65c\":\"1irbL\",\"628c95531afa43c2\":\"jax2A\"}],\"hMvuU\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Instruction = void 0;\nconst vscode_languageserver_types_1 = require(\"75e3371b54792caa\");\nconst util_1 = require(\"fa72f15fb47197d2\");\nconst line_1 = require(\"dc037d211747d0bf\");\nconst argument_1 = require(\"674d83a5e08e316f\");\nconst heredoc_1 = require(\"f30c1c980ba59082\");\nconst variable_1 = require(\"6c1e8830b0f0285c\");\nconst main_1 = require(\"c02c05f3ca580f8f\");\nclass Instruction extends line_1.Line {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range);\n        this.dockerfile = dockerfile;\n        this.escapeChar = escapeChar;\n        this.instruction = instruction;\n        this.instructionRange = instructionRange;\n    }\n    toString() {\n        let value = this.getKeyword();\n        for (let arg of this.getRawArguments()){\n            value += ' ';\n            value += arg.getValue();\n        }\n        return value;\n    }\n    getRangeContent(range) {\n        if (range === null) return null;\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    getInstructionRange() {\n        return this.instructionRange;\n    }\n    getInstruction() {\n        return this.instruction;\n    }\n    getKeyword() {\n        return this.getInstruction().toUpperCase();\n    }\n    getArgumentsRange() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        return vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end);\n    }\n    getArgumentsRanges() {\n        let args = this.getArguments();\n        if (args.length === 0) return [];\n        if (args[0].getRange().start.line === args[args.length - 1].getRange().end.line) return [\n            vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end)\n        ];\n        let ranges = [];\n        let end = -1;\n        let startPosition = args[0].getRange().start;\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(startPosition) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra, this.document.offsetAt(args[args.length - 1].getRange().end) - this.document.offsetAt(range.start));\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        for(let i = 0; i < fullArgs.length; i++){\n            let char = fullArgs.charAt(i);\n            if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') whitespaceCheck: for(let j = i + 2; j < fullArgs.length; j++)switch(fullArgs.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        continue;\n                    case '\\r':\n                        j++;\n                    case '\\n':\n                        if (startPosition !== null) ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                        start = true;\n                        comment = false;\n                        i = j;\n                        break whitespaceCheck;\n                    default:\n                        break whitespaceCheck;\n                }\n                else if (next === '\\r') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                    }\n                    start = true;\n                    comment = false;\n                    i += 2;\n                } else if (next === '\\n') {\n                    if (startPosition !== null) ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                    i++;\n                } else i++;\n            } else if (util_1.Util.isNewline(char)) {\n                if (comment) {\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                }\n            } else if (!comment) {\n                if (startPosition === null) {\n                    if (char === '#') {\n                        comment = true;\n                        continue;\n                    }\n                    let position = this.document.positionAt(offset + i);\n                    if (position.character !== 0) startPosition = vscode_languageserver_types_1.Position.create(position.line, 0);\n                }\n                end = i;\n            }\n        }\n        if (startPosition === null) // should only happen if the last argument is on its own line with\n        // no leading whitespace\n        ranges.push(vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + end), this.document.positionAt(offset + end + 1)));\n        else ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n        return ranges;\n    }\n    getRawArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        return this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end));\n    }\n    getArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) return null;\n        let content = \"\";\n        let ranges = this.getArgumentsRanges();\n        let documentText = this.document.getText();\n        for (let range of ranges)content += documentText.substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n        return content;\n    }\n    getArguments() {\n        return this.getRawArguments();\n    }\n    getRawArguments() {\n        let args = [];\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(range.end) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        let found = -1;\n        // determines whether the parser has found a space or tab\n        // whitespace character that's a part of an escaped newline sequence\n        let escapedWhitespaceDetected = false;\n        // determines if the parser is currently in an escaped newline sequence\n        let escaping = false;\n        let escapeMarker = -1;\n        let escapedArg = \"\";\n        for(let i = 0; i < fullArgs.length; i++){\n            let char = fullArgs.charAt(i);\n            if (util_1.Util.isWhitespace(char)) {\n                if (escaping) {\n                    escapedWhitespaceDetected = true;\n                    if (util_1.Util.isNewline(char)) {\n                        // reached a newline, any previously\n                        // detected whitespace should be ignored\n                        escapedWhitespaceDetected = false;\n                        if (comment) {\n                            // reached a newline, no longer in a comment\n                            comment = false;\n                            start = true;\n                        }\n                    }\n                    continue;\n                } else if (found !== -1) {\n                    if (escapeMarker === -1) args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + i))));\n                    else args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                    escapeMarker = -1;\n                    escapedArg = \"\";\n                    found = -1;\n                }\n            } else if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') whitespaceCheck: for(let j = i + 2; j < fullArgs.length; j++){\n                    let newlineCheck = fullArgs.charAt(j);\n                    switch(newlineCheck){\n                        case ' ':\n                        case '\\t':\n                            continue;\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            comment = false;\n                            escaping = true;\n                            start = true;\n                            if (found !== -1) escapeMarker = i;\n                            i = j;\n                            break whitespaceCheck;\n                        default:\n                            escapeMarker = i;\n                            if (found === -1) i = j - 1;\n                            break whitespaceCheck;\n                    }\n                }\n                else if (next === '\\r') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) escapeMarker = i;\n                    i += 2;\n                } else if (next === '\\n') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) escapeMarker = i;\n                    i++;\n                } else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapeMarker = -1;\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    if (next === '$') escapedArg = escapedArg + char + next;\n                    else if (next === '') break;\n                    else escapedArg = escapedArg + next;\n                    if (found === -1) found = i;\n                    i++;\n                }\n            } else if (!comment) {\n                if (start && char === '#') comment = true;\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    escapeMarker = -1;\n                    escapedArg = escapedArg + char;\n                    if (found === -1) found = i;\n                }\n                // non-whitespace character detected, reset\n                start = false;\n            }\n        }\n        if (found !== -1) {\n            if (escapeMarker === -1) args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + fullArgs.length))));\n            else args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n        }\n        return args;\n    }\n    getExpandedArguments() {\n        let args = this.getArguments();\n        for(let i = 0; i < args.length; i++){\n            const argRange = args[i].getRange();\n            let offset = this.document.offsetAt(argRange.start);\n            const variables = this.parseVariables(offset, args[i].getValue());\n            const swaps = [];\n            let requiresExpansion = false;\n            for (let variable of variables){\n                const value = this.dockerfile.resolveVariable(variable.getName(), variable.getNameRange().start.line);\n                swaps.push(value);\n                requiresExpansion = requiresExpansion || value !== undefined;\n            }\n            if (requiresExpansion) {\n                let expanded = \"\";\n                for(let j = 0; j < swaps.length; j++){\n                    const variableRange = variables[j].getRange();\n                    const start = this.document.offsetAt(variableRange.start);\n                    const end = this.document.offsetAt(variableRange.end);\n                    if (swaps[j]) {\n                        // replace variable with its resolved value\n                        expanded += this.document.getText().substring(offset, start);\n                        expanded += swaps[j];\n                        offset = end;\n                    } else {\n                        expanded += this.document.getText().substring(offset, end);\n                        offset = end;\n                    }\n                }\n                const argEnd = this.document.offsetAt(argRange.end);\n                if (argEnd !== offset) // if the variable's range doesn't match the argument,\n                // append the remaining text\n                expanded += this.document.getText().substring(offset, argEnd);\n                args[i] = new argument_1.Argument(expanded, argRange);\n            }\n        }\n        return args;\n    }\n    getVariables() {\n        const variables = [];\n        const args = this.getRawArguments();\n        for (const arg of args){\n            let range = arg.getRange();\n            let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n            const parsedVariables = this.parseVariables(this.document.offsetAt(arg.getRange().start), rawValue);\n            for (const parsedVariable of parsedVariables)variables.push(parsedVariable);\n        }\n        return variables;\n    }\n    parseVariables(offset, arg) {\n        let variables = [];\n        variableLoop: for(let i = 0; i < arg.length; i++)switch(arg.charAt(i)){\n            case this.escapeChar:\n                if (arg.charAt(i + 1) === '$') i++;\n                break;\n            case '$':\n                if (arg.charAt(i + 1) === '{') {\n                    let escapedString = \"${\";\n                    let escapedName = \"\";\n                    let nameEnd = -1;\n                    let escapedSubstitutionParameter = \"\";\n                    let substitutionStart = -1;\n                    let substitutionEnd = -1;\n                    let modifierRead = -1;\n                    nameLoop: for(let j = i + 2; j < arg.length; j++){\n                        let char = arg.charAt(j);\n                        switch(char){\n                            case this.escapeChar:\n                                for(let k = j + 1; k < arg.length; k++)switch(arg.charAt(k)){\n                                    case ' ':\n                                    case '\\t':\n                                    case '\\r':\n                                        continue;\n                                    case '\\n':\n                                        // escape this newline\n                                        j = k;\n                                        continue nameLoop;\n                                }\n                                break;\n                            case '}':\n                                escapedString += '}';\n                                let modifier = null;\n                                let modifierRange = null;\n                                let substitutionParameter = modifierRead !== -1 ? escapedSubstitutionParameter : null;\n                                let substitutionRange = null;\n                                if (nameEnd === -1) nameEnd = j;\n                                else if (nameEnd + 1 === j) {\n                                    modifier = \"\";\n                                    modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + nameEnd + 1), this.document.positionAt(offset + nameEnd + 1));\n                                } else {\n                                    if (substitutionStart === -1) {\n                                        // no substitution parameter found,\n                                        // but a modifier character existed,\n                                        // just offset the range by 1 from\n                                        // the modifier character\n                                        substitutionStart = modifierRead + 1;\n                                        substitutionEnd = modifierRead + 1;\n                                    } else // offset one more from the last\n                                    // character found\n                                    substitutionEnd = substitutionEnd + 1;\n                                    modifier = arg.substring(modifierRead, modifierRead + 1);\n                                    modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + modifierRead), this.document.positionAt(offset + modifierRead + 1));\n                                    substitutionRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + substitutionStart), this.document.positionAt(offset + substitutionEnd));\n                                }\n                                let start = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 2), this.document.positionAt(offset + nameEnd)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j + 1)), modifier, modifierRange, substitutionParameter, substitutionRange, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), escapedString));\n                                i = j;\n                                continue variableLoop;\n                            case ':':\n                                if (nameEnd === -1) nameEnd = j;\n                                else if (modifierRead !== -1) {\n                                    if (substitutionStart === -1) {\n                                        substitutionStart = j;\n                                        substitutionEnd = j;\n                                    } else substitutionEnd = j;\n                                    escapedSubstitutionParameter += ':';\n                                } else modifierRead = j;\n                                escapedString += ':';\n                                break;\n                            case '\\n':\n                            case '\\r':\n                            case ' ':\n                            case '\\t':\n                                break;\n                            default:\n                                if (nameEnd === -1) escapedName += char;\n                                else if (modifierRead !== -1) {\n                                    if (substitutionStart === -1) {\n                                        substitutionStart = j;\n                                        substitutionEnd = j;\n                                    } else substitutionEnd = j;\n                                    escapedSubstitutionParameter += char;\n                                } else modifierRead = j;\n                                escapedString += char;\n                                break;\n                        }\n                    }\n                    break variableLoop;\n                } else if (util_1.Util.isWhitespace(arg.charAt(i + 1)) || i === arg.length - 1) continue;\n                else {\n                    let escapedName = \"\";\n                    nameLoop: for(let j = i + 1; j < arg.length; j++){\n                        let char = arg.charAt(j);\n                        switch(char){\n                            case '\\r':\n                            case '\\n':\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '$':\n                            case '\\'':\n                            case '\"':\n                                let varStart = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                i = j - 1;\n                                continue variableLoop;\n                            case this.escapeChar:\n                                for(let k = j + 1; k < arg.length; k++)switch(arg.charAt(k)){\n                                    case ' ':\n                                    case '\\t':\n                                    case '\\r':\n                                        continue;\n                                    case '\\n':\n                                        // escape this newline\n                                        j = k;\n                                        continue nameLoop;\n                                }\n                                // reached EOF after an escape character\n                                let start = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                                break variableLoop;\n                        }\n                        if (char.match(/^[a-z0-9_]+$/i) === null) {\n                            let varStart = this.document.positionAt(offset + i);\n                            variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                            i = j - 1;\n                            continue variableLoop;\n                        }\n                        escapedName += char;\n                    }\n                    let start = this.document.positionAt(offset + i);\n                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + arg.length)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + arg.length)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                }\n                break variableLoop;\n        }\n        return variables;\n    }\n    isBuildVariable(variable, line) {\n        if (this.getKeyword() === main_1.Keyword.FROM) {\n            for (const initialArg of this.dockerfile.getInitialARGs()){\n                const arg = initialArg;\n                const property = arg.getProperty();\n                if (property && variable === property.getName()) return true;\n            }\n            return undefined;\n        }\n        let image = this.dockerfile.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        let envs = image.getENVs();\n        for(let i = envs.length - 1; i >= 0; i--){\n            if (envs[i].isBefore(line)) for (let property of envs[i].getProperties()){\n                if (property.getName() === variable) return false;\n            }\n        }\n        let args = image.getARGs();\n        for(let i = args.length - 1; i >= 0; i--)if (args[i].isBefore(line)) {\n            let property = args[i].getProperty();\n            if (property && property.getName() === variable) return true;\n        }\n        return undefined;\n    }\n    createSingleLineHeredocs(args) {\n        const heredocs = [];\n        // instruction only on one line, if heredocs exist they would be incomplete\n        for (const arg of args){\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && util_1.Util.parseHeredocName(value) !== null) {\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n            }\n        }\n        return heredocs;\n    }\n    getName(nameRange) {\n        const content = this.document.getText(nameRange);\n        let escaping = false;\n        let name = \"\";\n        nameLoop: for(let i = 0; i < content.length; i++){\n            const ch = content.charAt(i);\n            switch(ch){\n                case this.escapeChar:\n                    escaping = true;\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case ' ':\n                        case '\\t':\n                            break;\n                        case '\\r':\n                            i = j + 1;\n                            continue nameLoop;\n                        case '\\n':\n                            i = j;\n                            continue nameLoop;\n                        default:\n                            name += content.charAt(j);\n                            i = j;\n                            continue nameLoop;\n                    }\n                    break;\n                case '#':\n                    if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            i = j;\n                            continue nameLoop;\n                    }\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    if (escaping) break;\n                default:\n                    name += ch;\n                    break;\n            }\n        }\n        return name;\n    }\n    getNameRange(startRange) {\n        const content = this.document.getText(startRange);\n        let endFound = false;\n        let searchHyphen = false;\n        let start = -1;\n        let end = -1;\n        let escaping = false;\n        let quote = null;\n        contentLoop: for(let i = 0; i < content.length; i++){\n            const ch = content.charAt(i);\n            switch(ch){\n                case '\"':\n                case '\\'':\n                    if (quote === ch) break contentLoop;\n                    quote = ch;\n                    continue;\n                case this.escapeChar:\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            escaping = true;\n                            j = i;\n                            continue contentLoop;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '<':\n                    if (endFound) searchHyphen = true;\n                    else endFound = true;\n                    break;\n                case '-':\n                    if (searchHyphen) {\n                        searchHyphen = false;\n                        break;\n                    }\n                case '#':\n                    if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case '\\n':\n                            i = j;\n                            continue contentLoop;\n                    }\n                default:\n                    if (start === -1) start = i;\n                    if (quote !== null) {\n                        end = i + 1;\n                        break;\n                    }\n                    break contentLoop;\n            }\n        }\n        if (start === -1) return vscode_languageserver_types_1.Range.create(startRange.end, startRange.end);\n        const nameStart = this.document.positionAt(this.document.offsetAt(startRange.start) + start);\n        const nameEnd = quote !== null ? this.document.positionAt(this.document.offsetAt(startRange.start) + end) : startRange.end;\n        return vscode_languageserver_types_1.Range.create(nameStart, nameEnd);\n    }\n    getHeredocs() {\n        const args = this.getArguments();\n        if (args.length === 0) return [];\n        const heredocs = [];\n        const range = this.getRange();\n        if (range.start.line === range.end.line) // instruction only on one line, if heredocs exist they would be incomplete\n        return this.createSingleLineHeredocs(args);\n        const heredocDefinitions = [];\n        let heredocsProcessed = false;\n        let escaping = false;\n        let contentStart = -1;\n        let contentEnd = -1;\n        let lineStart = -1;\n        let currentHeredoc = 0;\n        const startOffset = this.document.offsetAt(args[0].getRange().start);\n        const content = this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end));\n        contentLoop: for(let i = 0; i < content.length; i++)switch(content.charAt(i)){\n            case this.escapeChar:\n                escaping = true;\n                for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                        break;\n                    case '\\r':\n                        j++;\n                    case '\\n':\n                        i = j;\n                        continue contentLoop;\n                    default:\n                        i = j;\n                        continue contentLoop;\n                }\n                break;\n            case '\\r':\n                break;\n            case '\\n':\n                if (escaping) break;\n                if (heredocsProcessed) {\n                    if (contentStart === -1) contentStart = i;\n                    contentEnd = i;\n                    const arg = heredocDefinitions[currentHeredoc];\n                    const startRange = arg.getRange();\n                    const nameRange = this.getNameRange(startRange);\n                    const name = this.getName(nameRange);\n                    const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), this.document.positionAt(startOffset + i)));\n                    if (delimiterRange !== null) {\n                        const contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + lineStart - 1));\n                        heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n                        contentStart = -1;\n                        currentHeredoc++;\n                    }\n                    lineStart = -1;\n                } else {\n                    // found a newline that hasn't been escaped,\n                    // must be in a heredoc\n                    const offsetLimit = startOffset + i;\n                    for (const arg of args){\n                        // check if this argument is on the initial line of the instruction,\n                        // note that it may not all be on the same line due to escaped newlines,\n                        // because of that we need to use offset checks instead of line checks\n                        // as an argument being on a different line in the document does not\n                        // imply it is on a different line from the Dockerfile's point of view\n                        if (this.document.offsetAt(arg.getRange().start) < offsetLimit) {\n                            if (arg.getValue().startsWith(\"<<\")) heredocDefinitions.push(arg);\n                        } else break;\n                    }\n                    heredocsProcessed = true;\n                    lineStart = -1;\n                    continue contentLoop;\n                }\n                break;\n            case ' ':\n            case '\\t':\n                if (escaping) break;\n            case '#':\n                if (escaping) for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                    case '\\n':\n                        i = j;\n                        continue contentLoop;\n                }\n            default:\n                if (escaping) escaping = false;\n                if (heredocsProcessed) {\n                    if (contentStart === -1) contentStart = i;\n                    if (lineStart === -1) lineStart = i;\n                }\n                break;\n        }\n        if (heredocsProcessed) {\n            const arg = heredocDefinitions[currentHeredoc];\n            const startRange = arg.getRange();\n            const nameRange = this.getNameRange(startRange);\n            const name = this.getName(nameRange);\n            let contentRange = null;\n            // check if the last line of this instruction matches the name of the last heredoc\n            const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), range.end));\n            if (delimiterRange === null) contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), range.end);\n            else if (contentEnd !== -1) contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + contentEnd));\n            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n            currentHeredoc++;\n            for(let i = currentHeredoc; i < heredocDefinitions.length; i++){\n                const arg = heredocDefinitions[currentHeredoc];\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n                currentHeredoc++;\n            }\n        } else // instruction only on one line, if heredocs exist they would be incomplete\n        return this.createSingleLineHeredocs(args);\n        return heredocs;\n    }\n    getDelimiterRange(startArg, name, candidateRange) {\n        const text = this.document.getText(candidateRange);\n        if (startArg.getValue().startsWith(\"<<-\")) {\n            // remove tabs in the front\n            let index = 0;\n            while(text.charAt(index) === '\\t')index++;\n            if (text.substring(index) === name) return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(candidateRange.start.line, index), candidateRange.end);\n            return null;\n        }\n        return text === name ? candidateRange : null;\n    }\n}\nexports.Instruction = Instruction;\n\n},{\"75e3371b54792caa\":\"ghSGy\",\"fa72f15fb47197d2\":\"7JXpr\",\"dc037d211747d0bf\":\"jax2A\",\"674d83a5e08e316f\":\"j0TZA\",\"f30c1c980ba59082\":\"f2Bvm\",\"6c1e8830b0f0285c\":\"eGHet\",\"c02c05f3ca580f8f\":\"1irbL\"}],\"f2Bvm\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Heredoc = void 0;\n/**\n * Heredoc represents a here-document that has been embedded in a\n * Dockerfile.\n *\n * This API is experimental and subject to change.\n */ class Heredoc {\n    constructor(startRange, name, nameRange, contentRange, endRange){\n        this.startRange = startRange;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.contentRange = contentRange;\n        this.endRange = endRange;\n    }\n    /**\n     * Returns the name of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */ getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range of the start operator and the name. If the\n     * here-document is initialized with <<EOT then the start range would\n     * encompass all five characters.\n     *\n     * This API is experimental and subject to change.\n     */ getStartRange() {\n        return this.startRange;\n    }\n    /**\n     * Returns the range of this here-document's name that is declared at\n     * the beginning of the here-document with the operator. If the\n     * here-document is initialized with <<EOT then the name range would\n     * encompass the latter three \"EOT\" characters.\n     *\n     * This API is experimental and subject to change.\n     */ getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the content of this here-document. This may\n     * be null if the here-document has no content because:\n     * - the start range is the only thing that was declared\n     * - the end range was declared immediately and there is no content\n     *\n     * This API is experimental and subject to change.\n     */ getContentRange() {\n        return this.contentRange;\n    }\n    /**\n     * Returns the range of the here-document's name on a line that\n     * represents the end of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */ getDelimiterRange() {\n        return this.endRange;\n    }\n}\nexports.Heredoc = Heredoc;\n\n},{}],\"eGHet\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Variable = void 0;\nclass Variable {\n    constructor(name, nameRange, range, modifier, modifierRange, substitutionParameter, substitutionRange, defined, buildVariable, stringValue){\n        this.name = name;\n        this.nameRange = nameRange;\n        this.range = range;\n        this.modifier = modifier;\n        this.modifierRange = modifierRange;\n        this.substitutionParameter = substitutionParameter;\n        this.substitutionRange = substitutionRange;\n        this.defined = defined;\n        this.buildVariable = buildVariable;\n        this.stringValue = stringValue;\n    }\n    toString() {\n        return this.stringValue;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the entire variable. This includes the symbols for\n     * the declaration of the variable such as the $, {, and } symbols.\n     *\n     * @return the range in the document that this variable encompasses in its\n     *         entirety\n     */ getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the modifier character that has been set for\n     * specifying how this variable should be expanded and resolved.\n     * If this variable is ${variable:+value} then the modifier\n     * character is '+'. Will be the empty string if the variable is\n     * declared as ${variable:}. Otherwise, will be null if this\n     * variable will not use variable substitution at all (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's modifier character, or the empty\n     *         string if it does not have one, or null if this\n     *         variable will not use variable substitution\n     */ getModifier() {\n        return this.modifier;\n    }\n    getModifierRange() {\n        return this.modifierRange;\n    }\n    /**\n     * Returns the parameter that will be used for substitution if\n     * this variable uses modifiers to define how its value should be\n     * resolved. If this variable is ${variable:+value} then the\n     * substitution value will be 'value'. Will be the empty string\n     * if the variable is declared as ${variable:+} or some other\n     * variant where the only thing that follows the modifier\n     * character (excluding considerations of escape characters and\n     * so on) is the variable's closing bracket. May be null if this\n     * variable does not have a modifier character defined (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's substitution parameter, or the empty\n     *         string if it does not have one, or null if there is\n     *         not one defined\n     */ getSubstitutionParameter() {\n        return this.substitutionParameter;\n    }\n    getSubstitutionRange() {\n        return this.substitutionRange;\n    }\n    /**\n     * Returns whether this variable has been defined or not.\n     *\n     * @return true if this variable has been defined, false otherwise\n     */ isDefined() {\n        return this.defined;\n    }\n    isBuildVariable() {\n        return this.buildVariable === true;\n    }\n    isEnvironmentVariable() {\n        return this.buildVariable === false;\n    }\n}\nexports.Variable = Variable;\n\n},{}],\"gRGNk\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Add = void 0;\nconst jsonInstruction_1 = require(\"45edbc923db84bc5\");\nclass Add extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n}\nexports.Add = Add;\n\n},{\"45edbc923db84bc5\":\"jxSFH\"}],\"jxSFH\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.JSONInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"b67afa726af51201\");\nconst argument_1 = require(\"92c9241da20c9f3\");\nconst jsonArgument_1 = require(\"87f92bbce16b9f06\");\nconst modifiableInstruction_1 = require(\"96353d5546ff94dc\");\nclass JSONInstruction extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.openingBracket = null;\n        this.closingBracket = null;\n        this.jsonStrings = [];\n        const argsContent = this.getRawArgumentsContent();\n        if (argsContent === null) return;\n        const args = this.getArguments();\n        if (args.length === 1 && args[0].getValue() === \"[]\") {\n            let argRange = args[0].getRange();\n            this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character, argRange.start.line, argRange.start.character + 1));\n            this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character + 1, argRange.end.line, argRange.end.character));\n            return;\n        } else if (args.length === 2 && args[0].getValue() === '[' && args[1].getValue() === ']') {\n            this.openingBracket = args[0];\n            this.closingBracket = args[1];\n            return;\n        }\n        const argsOffset = document.offsetAt(this.getArgumentsRange().start);\n        let start = -1;\n        let last = \"\";\n        let quoted = false;\n        let escapedArg = \"\";\n        argsCheck: for(let i = 0; i < argsContent.length; i++){\n            let char = argsContent.charAt(i);\n            switch(char){\n                case '[':\n                    if (last === \"\") {\n                        this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        last = '[';\n                    } else if (quoted) escapedArg = escapedArg + char;\n                    else break argsCheck;\n                    break;\n                case '\"':\n                    if (last === '[' || last === ',') {\n                        start = i;\n                        quoted = true;\n                        last = '\"';\n                        escapedArg = escapedArg + char;\n                        continue;\n                    } else if (last === '\"') {\n                        if (quoted) {\n                            escapedArg = escapedArg + char;\n                            // quoted string done\n                            quoted = false;\n                            this.jsonStrings.push(new jsonArgument_1.JSONArgument(escapedArg, vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start), document.positionAt(argsOffset + i + 1)), vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start + 1), document.positionAt(argsOffset + i))));\n                            escapedArg = \"\";\n                        } else break argsCheck;\n                    } else break argsCheck;\n                    break;\n                case ',':\n                    if (quoted) escapedArg = escapedArg + char;\n                    else {\n                        if (last === '\"') last = ',';\n                        else break argsCheck;\n                    }\n                    break;\n                case ']':\n                    if (quoted) escapedArg = escapedArg + char;\n                    else if (last !== \"\") {\n                        this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        break argsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\\\':\n                    if (quoted) switch(argsContent.charAt(i + 1)){\n                        case '\"':\n                        case '\\\\':\n                            escapedArg = escapedArg + argsContent.charAt(i + 1);\n                            i++;\n                            continue;\n                        case ' ':\n                        case '\\t':\n                            escapeCheck: for(let j = i + 2; j < argsContent.length; j++)switch(argsContent.charAt(j)){\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue argsCheck;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    break escapeCheck;\n                            }\n                            break;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        default:\n                            i++;\n                            continue;\n                    }\n                    else escapeCheck: for(let j = i + 1; j < argsContent.length; j++)switch(argsContent.charAt(j)){\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            j++;\n                        case '\\n':\n                            i = j;\n                            continue argsCheck;\n                        case ' ':\n                        case '\\t':\n                            break;\n                        default:\n                            break escapeCheck;\n                    }\n                    break argsCheck;\n                default:\n                    if (!quoted) break argsCheck;\n                    escapedArg = escapedArg + char;\n                    break;\n            }\n        }\n    }\n    stopSearchingForFlags(_value) {\n        return true;\n    }\n    getOpeningBracket() {\n        return this.openingBracket;\n    }\n    getJSONStrings() {\n        return this.jsonStrings;\n    }\n    getClosingBracket() {\n        return this.closingBracket;\n    }\n}\nexports.JSONInstruction = JSONInstruction;\n\n},{\"b67afa726af51201\":\"ghSGy\",\"92c9241da20c9f3\":\"j0TZA\",\"87f92bbce16b9f06\":\"58ALy\",\"96353d5546ff94dc\":\"hJrte\"}],\"hJrte\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ModifiableInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"855ac039bce5641c\");\nconst flag_1 = require(\"709209d535932d47\");\nconst instruction_1 = require(\"e9069bd7c795ab09\");\nclass ModifiableInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getFlags() {\n        if (!this.flags) {\n            this.flags = [];\n            for (let arg of this.getArguments()){\n                let value = arg.getValue();\n                if (this.stopSearchingForFlags(value)) return this.flags;\n                else if (value.indexOf(\"--\") === 0) {\n                    let range = arg.getRange();\n                    let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n                    let nameIndex = value.indexOf('=');\n                    let index = rawValue.indexOf('=');\n                    let firstMatch = false;\n                    let secondMatch = false;\n                    let startIndex = -1;\n                    nameSearchLoop: for(let i = 0; i < rawValue.length; i++)switch(rawValue.charAt(i)){\n                        case '\\\\':\n                        case ' ':\n                        case '\\t':\n                        case '\\r':\n                        case '\\n':\n                            break;\n                        case '-':\n                            if (secondMatch) {\n                                startIndex = i;\n                                break nameSearchLoop;\n                            } else if (firstMatch) secondMatch = true;\n                            else firstMatch = true;\n                            break;\n                        default:\n                            startIndex = i;\n                            break nameSearchLoop;\n                    }\n                    let nameStart = this.document.positionAt(this.document.offsetAt(range.start) + startIndex);\n                    if (index === -1) this.flags.push(new flag_1.Flag(this.document, range, value.substring(2), vscode_languageserver_types_1.Range.create(nameStart, range.end), null, null));\n                    else if (index === value.length - 1) {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, index), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), \"\", vscode_languageserver_types_1.Range.create(range.end, range.end)));\n                    } else {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, nameIndex), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), value.substring(nameIndex + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(this.document.offsetAt(range.start) + index + 1), range.end)));\n                    }\n                }\n            }\n        }\n        return this.flags;\n    }\n    getArguments() {\n        const args = super.getArguments();\n        const flags = this.getFlags();\n        if (flags.length === 0) return args;\n        for(let i = 0; i < flags.length; i++)args.shift();\n        return args;\n    }\n}\nexports.ModifiableInstruction = ModifiableInstruction;\n\n},{\"855ac039bce5641c\":\"ghSGy\",\"709209d535932d47\":\"2WqAd\",\"e9069bd7c795ab09\":\"hMvuU\"}],\"2WqAd\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Flag = void 0;\nconst vscode_languageserver_types_1 = require(\"4b50d54787c41ee7\");\nconst flagOption_1 = require(\"b99c8b3ac173456d\");\nclass Flag {\n    constructor(document, range, name, nameRange, value, valueRange){\n        this.options = [];\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n        if (this.value !== null) {\n            let offset = document.offsetAt(valueRange.start);\n            let nameStart = -1;\n            let valueStart = -1;\n            let hasOptions = false;\n            for(let i = 0; i < value.length; i++)switch(value.charAt(i)){\n                case '=':\n                    hasOptions = true;\n                    if (valueStart === -1) {\n                        valueStart = i + 1;\n                        break;\n                    }\n                    break;\n                case ',':\n                    this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, i));\n                    nameStart = -1;\n                    valueStart = -1;\n                    break;\n                default:\n                    if (nameStart === -1) nameStart = i;\n                    break;\n            }\n            if (hasOptions && nameStart !== -1) this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, value.length));\n        }\n    }\n    createFlagOption(document, content, documentOffset, nameStart, valueStart, valueEnd) {\n        const optionRange = vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueEnd));\n        if (valueStart === -1) return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueEnd), optionRange, null, null);\n        return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueStart - 1), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueStart - 1)), content.substring(valueStart, valueEnd), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + valueStart), document.positionAt(documentOffset + valueEnd)));\n    }\n    toString() {\n        if (this.valueRange) return \"--\" + this.name + \"=\" + this.value;\n        return \"--\" + this.name;\n    }\n    /**\n     * Returns the range that encompasses this entire flag. This includes the\n     * -- prefix in the beginning to the last character of the flag's value (if\n     * it has been defined).\n     *\n     * @return the entire range of this flag\n     */ getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the name of this flag. The name does not include the -- prefix.\n     * Thus, for HEALTHCHECK's --interval flag, interval is the flag's name and\n     * not --interval.\n     *\n     * @return this flag's name\n     */ getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range that encompasses the flag's name\n     *\n     * @return the range containing the flag's name\n     */ getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the value that has been set to this flag. May be null if the\n     * flag is invalid and has no value set like a --start-period. If the flag\n     * is instead a --start-period= with an equals sign then the flag's value\n     * is the empty string.\n     *\n     * @return this flag's value if it has been defined, null otherwise\n     */ getValue() {\n        return this.value;\n    }\n    /**\n     * Returns the range that encompasses this flag's value. If no value has\n     * been set then null will be returned.\n     *\n     * @return the range containing this flag's value, or null if the flag\n     *         has no value defined\n     */ getValueRange() {\n        return this.valueRange;\n    }\n    getOption(name) {\n        for (const option of this.options){\n            if (option.getName() === name) return option;\n        }\n        return null;\n    }\n    getOptions() {\n        return this.options;\n    }\n    hasOptions() {\n        return this.options.length > 0;\n    }\n}\nexports.Flag = Flag;\n\n},{\"4b50d54787c41ee7\":\"ghSGy\",\"b99c8b3ac173456d\":\"epAH1\"}],\"epAH1\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FlagOption = void 0;\nclass FlagOption {\n    constructor(range, name, nameRange, value, valueRange){\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        if (this.valueRange !== null) return this.name + \"=\" + this.value;\n        return this.name;\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n}\nexports.FlagOption = FlagOption;\n\n},{}],\"aKTxx\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Arg = void 0;\nconst property_1 = require(\"80085cc42a36e81\");\nconst propertyInstruction_1 = require(\"7526e7dfe4901c29\");\nclass Arg extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.property = null;\n        const args = this.getPropertyArguments();\n        if (args.length === 1) this.property = new property_1.Property(this.document, this.escapeChar, args[0]);\n        else this.property = null;\n    }\n    /**\n     * Returns the variable defined by this ARG. This may be null if\n     * this ARG instruction is malformed and has no variable\n     * declaration.\n     */ getProperty() {\n        return this.property;\n    }\n}\nexports.Arg = Arg;\n\n},{\"80085cc42a36e81\":\"gy5Z3\",\"7526e7dfe4901c29\":\"hOqfp\"}],\"gy5Z3\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Property = void 0;\nconst vscode_languageserver_types_1 = require(\"e172fc4caa74424\");\nconst util_1 = require(\"554d16feb7eb1735\");\nclass Property {\n    constructor(document, escapeChar, arg, arg2){\n        this.assignmentOperatorRange = null;\n        this.assignmentOperator = null;\n        this.valueRange = null;\n        this.value = null;\n        this.document = document;\n        this.escapeChar = escapeChar;\n        this.nameRange = Property.getNameRange(document, arg);\n        let value = document.getText().substring(document.offsetAt(this.nameRange.start), document.offsetAt(this.nameRange.end));\n        this.name = Property.getValue(value, escapeChar);\n        if (arg2) {\n            this.valueRange = arg2.getRange();\n            value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n            this.value = Property.getValue(value, escapeChar);\n            this.range = vscode_languageserver_types_1.Range.create(this.nameRange.start, this.valueRange.end);\n        } else {\n            let argRange = arg.getRange();\n            if (this.nameRange.start.line === argRange.start.line && this.nameRange.start.character === argRange.start.character && this.nameRange.end.line === argRange.end.line && this.nameRange.end.character === argRange.end.character) ;\n            else {\n                this.valueRange = Property.getValueRange(document, arg);\n                value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n                this.value = Property.getValue(value, escapeChar);\n                this.assignmentOperatorRange = vscode_languageserver_types_1.Range.create(this.nameRange.end, this.valueRange.start);\n                this.assignmentOperator = \"=\";\n            }\n            this.range = argRange;\n        }\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    /**\n     * Retrieves the operator used for delimiting between the name and\n     * value of this property. This will either be the \"=\" character\n     * or null if a character was not used or if this property has no\n     * value defined.\n     */ getAssignmentOperator() {\n        return this.assignmentOperator;\n    }\n    getAssignmentOperatorRange() {\n        return this.assignmentOperatorRange;\n    }\n    /**\n     * Returns the value of this property including any enclosing\n     * single or double quotes and relevant escape characters.\n     * Escaped newlines and its associated contiguous whitespace\n     * characters however will not be returned as they are deemed to\n     * be uninteresting to clients trying to return a Dockerfile.\n     *\n     * @return the unescaped value of this property or null if this\n     *         property has no associated value\n     */ getUnescapedValue() {\n        if (this.valueRange === null) return null;\n        let escaped = false;\n        let rawValue = \"\";\n        let value = this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n        rawLoop: for(let i = 0; i < value.length; i++){\n            let char = value.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            escaped = true;\n                            i = j;\n                            continue rawLoop;\n                        case ' ':\n                        case '\\t':\n                            break;\n                        default:\n                            rawValue = rawValue + char;\n                            continue rawLoop;\n                    }\n                    // this happens if there's only whitespace after the escape character\n                    rawValue = rawValue + char;\n                    break;\n                case '\\r':\n                case '\\n':\n                    break;\n                case ' ':\n                case '\\t':\n                    if (!escaped) rawValue = rawValue + char;\n                    break;\n                case '#':\n                    if (escaped) for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                        case '\\r':\n                            j++;\n                        case '\\n':\n                            i = j;\n                            continue rawLoop;\n                    }\n                    else rawValue = rawValue + char;\n                    break;\n                default:\n                    rawValue = rawValue + char;\n                    escaped = false;\n                    break;\n            }\n        }\n        return rawValue;\n    }\n    static getNameRange(document, arg) {\n        let value = arg.getValue();\n        let index = value.indexOf('=');\n        if (index !== -1) {\n            let initial = value.charAt(0);\n            let before = value.charAt(index - 1);\n            // check if content before the equals sign are in quotes\n            // \"var\"=value\n            // 'var'=value\n            // otherwise, just assume it's a standard definition\n            // var=value\n            if (initial === '\"' && before === '\"' || initial === '\\'' && before === '\\'' || initial !== '\"' && initial !== '\\'') return vscode_languageserver_types_1.Range.create(arg.getRange().start, document.positionAt(document.offsetAt(arg.getRange().start) + index));\n        }\n        // no '=' found, just defined the property's name\n        return arg.getRange();\n    }\n    static getValueRange(document, arg) {\n        return vscode_languageserver_types_1.Range.create(document.positionAt(document.offsetAt(arg.getRange().start) + arg.getValue().indexOf('=') + 1), document.positionAt(document.offsetAt(arg.getRange().end)));\n    }\n    /**\n     * Returns the actual value of this key-value pair. The value will\n     * have its escape characters removed if applicable. If the value\n     * spans multiple lines and there are comments nested within the\n     * lines, they too will be removed.\n     *\n     * @return the value that this key-value pair will actually be, may\n     *         be null if no value is defined, may be the empty string\n     *         if the value only consists of whitespace\n     */ static getValue(value, escapeChar) {\n        let escaped = false;\n        const skip = util_1.Util.findLeadingNonWhitespace(value, escapeChar);\n        if (skip !== 0 && value.charAt(skip) === '#') // need to skip over comments\n        escaped = true;\n        value = value.substring(skip);\n        let first = value.charAt(0);\n        let last = value.charAt(value.length - 1);\n        let literal = first === '\\'' || first === '\"';\n        let inSingle = first === '\\'' && last === '\\'';\n        let inDouble = false;\n        if (first === '\"') for(let i = 1; i < value.length; i++){\n            if (value.charAt(i) === escapeChar) i++;\n            else if (value.charAt(i) === '\"' && i === value.length - 1) inDouble = true;\n        }\n        if (inSingle || inDouble) value = value.substring(1, value.length - 1);\n        let commentCheck = -1;\n        let escapedValue = \"\";\n        let start = 0;\n        parseValue: for(let i = 0; i < value.length; i++){\n            let char = value.charAt(i);\n            switch(char){\n                case escapeChar:\n                    if (i + 1 === value.length) {\n                        escapedValue = escapedValue + escapeChar;\n                        break parseValue;\n                    }\n                    char = value.charAt(i + 1);\n                    if (char === ' ' || char === '\\t') whitespaceCheck: for(let j = i + 2; j < value.length; j++){\n                        let char2 = value.charAt(j);\n                        switch(char2){\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                escaped = true;\n                                i = j;\n                                continue parseValue;\n                            default:\n                                if (!inDouble && !inSingle && !literal) {\n                                    if (char2 === escapeChar) {\n                                        // add the escaped character\n                                        escapedValue = escapedValue + char;\n                                        // now start parsing from the next escape character\n                                        i = i + 1;\n                                    } else {\n                                        // the expectation is that this j = i + 2 here\n                                        escapedValue = escapedValue + char + char2;\n                                        i = j;\n                                    }\n                                    continue parseValue;\n                                }\n                                break whitespaceCheck;\n                        }\n                    }\n                    if (inDouble) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        } else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        } else if (char !== '\"') {\n                            if (char === escapeChar) i++;\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    } else if (inSingle || literal) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        } else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        } else escapedValue = escapedValue + escapeChar;\n                        continue parseValue;\n                    } else if (char === escapeChar) {\n                        // double escape, append one and move on\n                        escapedValue = escapedValue + escapeChar;\n                        i++;\n                    } else if (char === '\\r') {\n                        escaped = true;\n                        // offset one more for \\r\\n\n                        i = i + 2;\n                    } else if (char === '\\n') {\n                        escaped = true;\n                        i++;\n                        start = i;\n                    } else {\n                        // any other escapes are simply ignored\n                        escapedValue = escapedValue + char;\n                        i++;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaped && commentCheck === -1) commentCheck = i;\n                    escapedValue = escapedValue + char;\n                    break;\n                case '\\r':\n                    i++;\n                case '\\n':\n                    if (escaped && commentCheck !== -1) {\n                        // rollback and remove the whitespace that was previously appended\n                        escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck - 1));\n                        commentCheck = -1;\n                    }\n                    break;\n                case '#':\n                    // a newline was escaped and now there's a comment\n                    if (escaped) {\n                        if (commentCheck !== -1) {\n                            // rollback and remove the whitespace that was previously appended\n                            escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck));\n                            commentCheck = -1;\n                        }\n                        newlineCheck: for(let j = i + 1; j < value.length; j++)switch(value.charAt(j)){\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                break newlineCheck;\n                        }\n                        continue parseValue;\n                    }\n                default:\n                    if (escaped) {\n                        escaped = false;\n                        commentCheck = -1;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n            }\n        }\n        return escapedValue;\n    }\n}\nexports.Property = Property;\n\n},{\"e172fc4caa74424\":\"ghSGy\",\"554d16feb7eb1735\":\"7JXpr\"}],\"hOqfp\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PropertyInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"fb005c0263efbd46\");\nconst instruction_1 = require(\"ae3a92d2c36b7ea3\");\nconst property_1 = require(\"39497e57ce0ffacf\");\nconst argument_1 = require(\"2f89de63f1f8e904\");\nconst util_1 = require(\"ca53fbc43fccdebf\");\nclass PropertyInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.properties = undefined;\n    }\n    getProperties() {\n        if (this.properties === undefined) {\n            let args = this.getPropertyArguments();\n            if (args.length === 0) this.properties = [];\n            else if (args.length === 1) this.properties = [\n                new property_1.Property(this.document, this.escapeChar, args[0])\n            ];\n            else if (args.length === 2) {\n                if (args[0].getValue().indexOf('=') === -1) this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0], args[1])\n                ];\n                else this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0]),\n                    new property_1.Property(this.document, this.escapeChar, args[1])\n                ];\n            } else if (args[0].getValue().indexOf('=') === -1) {\n                let text = this.document.getText();\n                let start = args[1].getRange().start;\n                let end = args[args.length - 1].getRange().end;\n                text = text.substring(this.document.offsetAt(start), this.document.offsetAt(end));\n                this.properties = [\n                    new property_1.Property(this.document, this.escapeChar, args[0], new argument_1.Argument(text, vscode_languageserver_types_1.Range.create(args[1].getRange().start, args[args.length - 1].getRange().end)))\n                ];\n            } else {\n                this.properties = [];\n                for(let i = 0; i < args.length; i++)this.properties.push(new property_1.Property(this.document, this.escapeChar, args[i]));\n            }\n        }\n        return this.properties;\n    }\n    /**\n     * Goes from the back of the string and returns the first\n     * non-whitespace character that is found. If an escape character\n     * is found with newline characters, the escape character will\n     * not be considered a non-whitespace character and its index in\n     * the string will not be returned.\n     *\n     * @param content the string to search through\n     * @return the index in the string for the first non-whitespace\n     *         character when searching from the end of the string\n     */ findTrailingNonWhitespace(content) {\n        // loop back to find the first non-whitespace character\n        let index = content.length;\n        whitespaceCheck: for(let i = content.length - 1; i >= 0; i--)switch(content.charAt(i)){\n            case ' ':\n            case '\\t':\n                continue;\n            case '\\n':\n                if (content.charAt(i - 1) === '\\r') i = i - 1;\n            case '\\r':\n                newlineCheck: for(let j = i - 1; j >= 0; j--)switch(content.charAt(j)){\n                    case ' ':\n                    case '\\t':\n                    case '\\r':\n                    case '\\n':\n                    case this.escapeChar:\n                        continue;\n                    default:\n                        index = j;\n                        break newlineCheck;\n                }\n                break whitespaceCheck;\n            default:\n                index = i;\n                break whitespaceCheck;\n        }\n        return index;\n    }\n    getPropertyArguments() {\n        const args = [];\n        let range = this.getInstructionRange();\n        let instructionNameEndOffset = this.document.offsetAt(range.end);\n        let extra = instructionNameEndOffset - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let start = util_1.Util.findLeadingNonWhitespace(fullArgs, this.escapeChar);\n        if (start === -1) // only whitespace found, no arguments\n        return [];\n        const startPosition = this.document.positionAt(instructionNameEndOffset + start);\n        // records whether the parser has just processed an escaped newline or not,\n        // if our starting position is not on the same line as the instruction then\n        // the start of the content is already on an escaped line\n        let escaped = range.start.line !== startPosition.line;\n        // flag to track if the last character was an escape character\n        let endingEscape = false;\n        // position before the first escape character was hit\n        let mark = -1;\n        let end = this.findTrailingNonWhitespace(fullArgs);\n        content = fullArgs.substring(start, end + 1);\n        let argStart = escaped ? -1 : 0;\n        let spaced = false;\n        argumentLoop: for(let i = 0; i < content.length; i++){\n            let char = content.charAt(i);\n            switch(char){\n                case this.escapeChar:\n                    if (i + 1 === content.length) {\n                        endingEscape = true;\n                        break argumentLoop;\n                    }\n                    if (!escaped) mark = i;\n                    switch(content.charAt(i + 1)){\n                        case ' ':\n                        case '\\t':\n                            if (!util_1.Util.isWhitespace(content.charAt(i + 2))) {\n                                // space was escaped, continue as normal\n                                i = i + 1;\n                                continue argumentLoop;\n                            }\n                            // whitespace encountered, need to figure out if it extends to EOL\n                            whitespaceCheck: for(let j = i + 2; j < content.length; j++)switch(content.charAt(j)){\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    // whitespace only, safe to skip\n                                    escaped = true;\n                                    i = j;\n                                    continue argumentLoop;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    // whitespace doesn't extend to EOL, create an argument\n                                    args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i + 2))));\n                                    argStart = j;\n                                    break whitespaceCheck;\n                            }\n                            // go back and start processing the encountered non-whitespace character\n                            i = argStart - 1;\n                            continue argumentLoop;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        case '\\n':\n                            // immediately followed by a newline, skip the newline\n                            escaped = true;\n                            i = i + 1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            // double escape found, skip it and move on\n                            if (argStart === -1) argStart = i;\n                            i = i + 1;\n                            continue argumentLoop;\n                        default:\n                            if (argStart === -1) argStart = i;\n                            continue argumentLoop;\n                    }\n                case '\\'':\n                case '\"':\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    if (argStart === -1) argStart = i;\n                    for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                        case char:\n                            if (content.charAt(j + 1) !== ' ' && content.charAt(j + 1) !== '') {\n                                // there is more content after this quote,\n                                // continue so that it is all processed as\n                                // one single argument\n                                i = j;\n                                continue argumentLoop;\n                            }\n                            args.push(new argument_1.Argument(content.substring(argStart, j + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + j + 1))));\n                            i = j;\n                            argStart = -1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            j++;\n                            break;\n                    }\n                    break argumentLoop;\n                case ' ':\n                case '\\t':\n                    if (escaped) // consider there to be a space only if an argument\n                    // is not spanning multiple lines\n                    {\n                        if (argStart !== -1) spaced = true;\n                    } else if (argStart !== -1) {\n                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i))));\n                        argStart = -1;\n                    }\n                    break;\n                case '\\r':\n                    // offset one more for \\r\\n\n                    i++;\n                case '\\n':\n                    spaced = false;\n                    break;\n                case '#':\n                    if (escaped) {\n                        // a newline was escaped and now there's a comment\n                        for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                spaced = false;\n                                continue argumentLoop;\n                        }\n                        // went to the end without finding a newline,\n                        // the comment was the last line in the instruction,\n                        // just stop parsing, create an argument if needed\n                        if (argStart !== -1) {\n                            let value = content.substring(argStart, mark);\n                            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n                            argStart = -1;\n                        }\n                        break argumentLoop;\n                    } else if (argStart === -1) argStart = i;\n                    break;\n                default:\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    escaped = false;\n                    if (argStart === -1) argStart = i;\n                    // variable detected\n                    if (char === '$' && content.charAt(i + 1) === '{') {\n                        let singleQuotes = false;\n                        let doubleQuotes = false;\n                        let escaped = false;\n                        for(let j = i + 1; j < content.length; j++)switch(content.charAt(j)){\n                            case this.escapeChar:\n                                escaped = true;\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                break;\n                            case '\\'':\n                                singleQuotes = !singleQuotes;\n                                escaped = false;\n                                break;\n                            case '\"':\n                                doubleQuotes = !doubleQuotes;\n                                escaped = false;\n                                break;\n                            case ' ':\n                            case '\\t':\n                                if (escaped || singleQuotes || doubleQuotes) break;\n                                i = j - 1;\n                                continue argumentLoop;\n                            case '}':\n                                i = j;\n                                continue argumentLoop;\n                            default:\n                                escaped = false;\n                                break;\n                        }\n                        break argumentLoop;\n                    }\n                    break;\n            }\n        }\n        if (argStart !== -1 && argStart !== content.length) {\n            let end = endingEscape ? content.length - 1 : content.length;\n            let value = content.substring(argStart, end);\n            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + end))));\n        }\n        return args;\n    }\n    createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start) {\n        if (argStart !== -1) args.push(new argument_1.Argument(content.substring(argStart, mark), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n    }\n}\nexports.PropertyInstruction = PropertyInstruction;\n\n},{\"fb005c0263efbd46\":\"ghSGy\",\"ae3a92d2c36b7ea3\":\"hMvuU\",\"39497e57ce0ffacf\":\"gy5Z3\",\"2f89de63f1f8e904\":\"j0TZA\",\"ca53fbc43fccdebf\":\"7JXpr\"}],\"9Gc1y\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Cmd = void 0;\nconst jsonInstruction_1 = require(\"fadbfdfa374dda06\");\nclass Cmd extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Cmd = Cmd;\n\n},{\"fadbfdfa374dda06\":\"jxSFH\"}],\"b3t88\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Copy = void 0;\nconst jsonInstruction_1 = require(\"65144230b131ca44\");\nclass Copy extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getFromFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"from\" ? flags[0] : null;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */ getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Copy = Copy;\n\n},{\"65144230b131ca44\":\"jxSFH\"}],\"1F4QE\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Env = void 0;\nconst propertyInstruction_1 = require(\"3dd682269c8a52ed\");\nclass Env extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Env = Env;\n\n},{\"3dd682269c8a52ed\":\"hOqfp\"}],\"a7xJN\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Entrypoint = void 0;\nconst jsonInstruction_1 = require(\"f651b847cf9bdc2\");\nclass Entrypoint extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Entrypoint = Entrypoint;\n\n},{\"f651b847cf9bdc2\":\"jxSFH\"}],\"nTyT0\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.From = void 0;\nconst vscode_languageserver_types_1 = require(\"5b86d61a77060318\");\nconst modifiableInstruction_1 = require(\"3fab8faba231e372\");\nclass From extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getImage() {\n        return this.getRangeContent(this.getImageRange());\n    }\n    /**\n     * Returns the name of the image that will be used as the base image.\n     *\n     * @return the base image's name, or null if unspecified\n     */ getImageName() {\n        return this.getRangeContent(this.getImageNameRange());\n    }\n    /**\n     * Returns the range that covers the name of the image used by\n     * this instruction.\n     *\n     * @return the range of the name of this instruction's argument,\n     *         or null if no image has been specified\n     */ getImageNameRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let registryRange = this.getRegistryRange();\n            if (registryRange) range.start = this.document.positionAt(this.document.offsetAt(registryRange.end) + 1);\n            let tagRange = this.getImageTagRange();\n            let digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n            } else range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            return range;\n        }\n        return null;\n    }\n    /**\n     * Returns the range that covers the image argument of this\n     * instruction. This includes the tag or digest of the image if\n     * it has been specified by the instruction.\n     *\n     * @return the range of the image argument, or null if no image\n     *         has been specified\n     */ getImageRange() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0].getRange() : null;\n    }\n    getImageTag() {\n        return this.getRangeContent(this.getImageTagRange());\n    }\n    /**\n     * Returns the range in the document that the tag of the base\n     * image encompasses.\n     *\n     * @return the base image's tag's range in the document, or null\n     *         if no tag has been specified\n     */ getImageTagRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const rangeStartOffset = this.document.offsetAt(range.start);\n            const content = this.getRangeContent(range);\n            const atIndex = this.indexOf(rangeStartOffset, content, '@');\n            const slashIndex = content.indexOf('/');\n            if (atIndex === -1) {\n                const colonIndex = this.lastIndexOf(rangeStartOffset, content, ':');\n                if (colonIndex > slashIndex) return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + colonIndex + 1, range.end.line, range.end.character);\n            }\n            const subcontent = content.substring(0, atIndex);\n            const subcolonIndex = subcontent.indexOf(':');\n            if (subcolonIndex === -1) return null;\n            if (slashIndex === -1) // slash not found suggests no registry and no namespace defined\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + atIndex));\n            // both colon and slash found, check if it is a port\n            if (subcolonIndex < slashIndex) return null;\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + subcontent.length));\n        }\n        return null;\n    }\n    getImageDigest() {\n        return this.getRangeContent(this.getImageDigestRange());\n    }\n    /**\n     * Returns the range in the document that the digest of the base\n     * image encompasses.\n     *\n     * @return the base image's digest's range in the document, or null\n     *         if no digest has been specified\n     */ getImageDigestRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let content = this.getRangeContent(range);\n            let index = this.lastIndexOf(this.document.offsetAt(range.start), content, '@');\n            if (index !== -1) return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + index + 1, range.end.line, range.end.character);\n        }\n        return null;\n    }\n    indexOf(documentOffset, content, searchString) {\n        let index = content.indexOf(searchString);\n        const variables = this.getVariables();\n        for(let i = 0; i < variables.length; i++){\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                const offset = this.document.offsetAt(variableRange.end) - documentOffset;\n                const substring = content.substring(offset);\n                const subIndex = substring.indexOf(searchString);\n                if (subIndex === -1) return -1;\n                index = subIndex + offset;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    lastIndexOf(documentOffset, content, searchString) {\n        let index = content.lastIndexOf(searchString);\n        const variables = this.getVariables();\n        for(let i = 0; i < variables.length; i++){\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                index = content.substring(0, index).lastIndexOf(searchString);\n                if (index === -1) return -1;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    getRegistry() {\n        return this.getRangeContent(this.getRegistryRange());\n    }\n    getRegistryRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const tagRange = this.getImageTagRange();\n            const digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n            } else range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            const content = this.getRangeContent(range);\n            const rangeStart = this.document.offsetAt(range.start);\n            const startingSlashIndex = this.indexOf(rangeStart, content, '/');\n            if (startingSlashIndex === -1) return null;\n            const portIndex = this.indexOf(rangeStart, content, ':');\n            const dotIndex = this.indexOf(rangeStart, content, '.');\n            // hostname detected\n            if (portIndex !== -1 || dotIndex !== -1) return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            const registry = content.substring(0, startingSlashIndex);\n            // localhost registry detected\n            if (registry === 'localhost') return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n        }\n        return null;\n    }\n    getBuildStage() {\n        let range = this.getBuildStageRange();\n        return range === null ? null : this.getRangeContent(range);\n    }\n    getBuildStageRange() {\n        let args = this.getArguments();\n        if (args.length > 2 && args[1].getValue().toUpperCase() === \"AS\") return args[2].getRange();\n        return null;\n    }\n    getPlatformFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"platform\" ? flags[0] : null;\n    }\n}\nexports.From = From;\n\n},{\"5b86d61a77060318\":\"ghSGy\",\"3fab8faba231e372\":\"hJrte\"}],\"bkMBh\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Healthcheck = void 0;\nconst modifiableInstruction_1 = require(\"665598fff2f000a9\");\nclass Healthcheck extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        argument = argument.toUpperCase();\n        return argument === \"CMD\" || argument === \"NONE\";\n    }\n    getSubcommand() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0] : null;\n    }\n}\nexports.Healthcheck = Healthcheck;\n\n},{\"665598fff2f000a9\":\"hJrte\"}],\"57hgN\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Label = void 0;\nconst propertyInstruction_1 = require(\"2a3c43ab2d532e31\");\nconst util_1 = require(\"5d28f2c31403599f\");\nclass Label extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getVariables() {\n        const variables = super.getVariables();\n        const properties = this.getProperties();\n        // iterate over all of this LABEL's properties\n        for (const property of properties){\n            const value = property.getUnescapedValue();\n            // check if the value is contained in single quotes,\n            // single quotes would indicate a literal value\n            if (value !== null && value.length > 2 && value.charAt(0) === '\\'' && value.charAt(value.length - 1) === '\\'') {\n                const range = property.getValueRange();\n                for(let i = 0; i < variables.length; i++)// if a variable is in a single quote, remove it from the list\n                if (util_1.Util.isInsideRange(variables[i].getRange().start, range)) {\n                    variables.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        return variables;\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Label = Label;\n\n},{\"2a3c43ab2d532e31\":\"hOqfp\",\"5d28f2c31403599f\":\"7JXpr\"}],\"8eYDK\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Onbuild = void 0;\nconst vscode_languageserver_types_1 = require(\"8cc927a606bbcc1f\");\nconst parser_1 = require(\"929a3cd6b7bd5151\");\nconst instruction_1 = require(\"5311b0a026532a3\");\nclass Onbuild extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getTrigger() {\n        let trigger = this.getTriggerWord();\n        return trigger === null ? null : trigger.toUpperCase();\n    }\n    getTriggerWord() {\n        return this.getRangeContent(this.getTriggerRange());\n    }\n    getTriggerRange() {\n        let args = this.getArguments();\n        return args.length > 0 ? args[0].getRange() : null;\n    }\n    getTriggerInstruction() {\n        let triggerRange = this.getTriggerRange();\n        if (triggerRange === null) return null;\n        let args = this.getArguments();\n        return parser_1.Parser.createInstruction(this.document, this.dockerfile, this.escapeChar, vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end), this.getTriggerWord(), triggerRange);\n    }\n}\nexports.Onbuild = Onbuild;\n\n},{\"8cc927a606bbcc1f\":\"ghSGy\",\"929a3cd6b7bd5151\":\"aGQ73\",\"5311b0a026532a3\":\"hMvuU\"}],\"bBCsY\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Run = void 0;\nconst jsonInstruction_1 = require(\"d3870bc430335c64\");\nclass Run extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */ getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Run = Run;\n\n},{\"d3870bc430335c64\":\"jxSFH\"}],\"j6kkx\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Shell = void 0;\nconst jsonInstruction_1 = require(\"dc6aa9db0db2b2a4\");\nclass Shell extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Shell = Shell;\n\n},{\"dc6aa9db0db2b2a4\":\"jxSFH\"}],\"bxm6V\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Stopsignal = void 0;\nconst instruction_1 = require(\"e3fce526f69f22f\");\nclass Stopsignal extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Stopsignal = Stopsignal;\n\n},{\"e3fce526f69f22f\":\"hMvuU\"}],\"alCEF\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Workdir = void 0;\nconst instruction_1 = require(\"95b77616cbe9ddd8\");\nclass Workdir extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    /**\n     * Returns the path that has been defined. Note that this path may\n     * be absolute or relative depending on what was written in the\n     * instruction.\n     *\n     * @return the working directory's path, or null if this\n     *         instruction has no arguments\n     */ getPath() {\n        return this.getArgumentsContent();\n    }\n    /**\n     * Returns the absolute path that this instruction resolves to. The\n     * function will inspect prior WORKDIR instructions in the current\n     * image or another build stage in the Dockerfile to try to\n     * determine this.\n     *\n     * @return the absolute path of the working directory, or null if\n     *         this instruction has no arguments, or undefined if it\n     *         cannot be determined because only relative paths could be\n     *         found\n     */ getAbsolutePath() {\n        const path = this.getPath();\n        if (path === null || path.startsWith(\"/\")) return path;\n        const startLine = this.getRange().start.line;\n        const hierarchy = this.dockerfile.getStageHierarchy(startLine);\n        for(let i = hierarchy.length - 1; i >= 0; i--){\n            const workdirs = hierarchy[i].getWORKDIRs();\n            for(let j = workdirs.length - 1; j >= 0; j--)if (workdirs[j].getRange().start.line < startLine) {\n                const parent = workdirs[j].getAbsolutePath();\n                if (parent === undefined || parent === null) return undefined;\n                return parent.endsWith(\"/\") ? parent + path : parent + \"/\" + path;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Workdir = Workdir;\n\n},{\"95b77616cbe9ddd8\":\"hMvuU\"}],\"bSHO0\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.User = void 0;\nconst instruction_1 = require(\"1c67107403f9045a\");\nclass User extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.User = User;\n\n},{\"1c67107403f9045a\":\"hMvuU\"}],\"5fZdP\":[function(require,module,exports,__globalThis) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Volume = void 0;\nconst jsonInstruction_1 = require(\"2200bfdb26148310\");\nclass Volume extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange){\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Volume = Volume;\n\n},{\"2200bfdb26148310\":\"jxSFH\"}],\"040Bk\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Dockerfile = void 0;\nconst vscode_languageserver_types_1 = require(\"9b3d375bed950159\");\nconst ast = require(\"d891ee5557672a0b\");\nconst imageTemplate_1 = require(\"372addc62e869cb6\");\nconst from_1 = require(\"3861ba9aa1dc6c84\");\nconst util_1 = require(\"e6e9b77f8d4a922b\");\nconst main_1 = require(\"d891ee5557672a0b\");\nclass Dockerfile extends imageTemplate_1.ImageTemplate {\n    constructor(document){\n        super();\n        this.initialInstructions = new imageTemplate_1.ImageTemplate();\n        this.buildStages = [];\n        this.directives = [];\n        /**\n         * Whether a FROM instruction has been added to this Dockerfile or not.\n         */ this.foundFrom = false;\n        this.document = document;\n    }\n    getEscapeCharacter() {\n        for (const directive of this.directives)if (directive.getDirective() === ast.Directive.escape) {\n            const value = directive.getValue();\n            if (value === '\\\\' || value === '`') return value;\n        }\n        return '\\\\';\n    }\n    getInitialARGs() {\n        return this.initialInstructions.getARGs();\n    }\n    getContainingImage(position) {\n        let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), this.document.positionAt(this.document.getText().length));\n        if (!util_1.Util.isInsideRange(position, range)) // not inside the document, invalid position\n        return null;\n        if (this.initialInstructions.getComments().length > 0 || this.initialInstructions.getInstructions().length > 0) {\n            if (util_1.Util.isInsideRange(position, this.initialInstructions.getRange())) return this.initialInstructions;\n        }\n        for (const buildStage of this.buildStages){\n            if (util_1.Util.isInsideRange(position, buildStage.getRange())) return buildStage;\n        }\n        return this;\n    }\n    addInstruction(instruction) {\n        if (instruction.getKeyword() === main_1.Keyword.FROM) {\n            this.currentBuildStage = new imageTemplate_1.ImageTemplate();\n            this.buildStages.push(this.currentBuildStage);\n            this.foundFrom = true;\n        } else if (!this.foundFrom) this.initialInstructions.addInstruction(instruction);\n        if (this.foundFrom) this.currentBuildStage.addInstruction(instruction);\n        super.addInstruction(instruction);\n    }\n    setDirectives(directives) {\n        this.directives = directives;\n    }\n    getDirective() {\n        return this.directives.length === 0 ? null : this.directives[0];\n    }\n    getDirectives() {\n        return this.directives;\n    }\n    resolveVariable(variable, line) {\n        for (let from of this.getFROMs()){\n            let range = from.getRange();\n            if (range.start.line <= line && line <= range.end.line) {\n                // resolve the FROM variable against the initial ARGs\n                let initialARGs = new imageTemplate_1.ImageTemplate();\n                for (let instruction of this.initialInstructions.getARGs())initialARGs.addInstruction(instruction);\n                return initialARGs.resolveVariable(variable, line);\n            }\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) return undefined;\n        let resolvedVariable = image.resolveVariable(variable, line);\n        if (resolvedVariable === null) {\n            // refers to an uninitialized ARG variable,\n            // try resolving it against the initial ARGs then\n            let initialARGs = new imageTemplate_1.ImageTemplate();\n            for (let instruction of this.initialInstructions.getARGs())initialARGs.addInstruction(instruction);\n            return initialARGs.resolveVariable(variable, line);\n        }\n        return resolvedVariable;\n    }\n    getAvailableVariables(currentLine) {\n        if (this.getInstructionAt(currentLine) instanceof from_1.From) {\n            let variables = [];\n            for (let arg of this.getInitialARGs()){\n                let property = arg.getProperty();\n                if (property) variables.push(property.getName());\n            }\n            return variables;\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(currentLine, 0));\n        return image ? image.getAvailableVariables(currentLine) : [];\n    }\n    getParentStage(image) {\n        const templateFrom = image.getFROM();\n        const imageName = templateFrom === null ? null : templateFrom.getImageName();\n        if (imageName === null) return null;\n        for (const from of this.getFROMs())if (from.getBuildStage() === imageName) {\n            const range = from.getRange();\n            // on the same line then it's an image that shares the name as the build stage\n            if (range.start.line === templateFrom.getRange().start.line) return null;\n            return this.getContainingImage(range.start);\n        }\n        return null;\n    }\n    getStageHierarchy(line) {\n        const image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) return [];\n        const stages = [\n            image\n        ];\n        let stage = this.getParentStage(image);\n        while(stage !== null){\n            stages.splice(0, 0, stage);\n            stage = this.getParentStage(stage);\n        }\n        return stages;\n    }\n    getAvailableWorkingDirectories(line) {\n        const availableDirectories = new Set();\n        for (const image of this.getStageHierarchy(line)){\n            for (const workdir of image.getWORKDIRs())if (workdir.getRange().end.line < line) {\n                let directory = workdir.getAbsolutePath();\n                if (directory !== undefined && directory !== null) {\n                    if (!directory.endsWith(\"/\")) directory += \"/\";\n                    availableDirectories.add(directory);\n                }\n            }\n        }\n        return Array.from(availableDirectories);\n    }\n    /**\n     * Internally reorganize the comments in the Dockerfile and allocate\n     * them to the relevant build stages that they belong to.\n     */ organizeComments() {\n        const comments = this.getComments();\n        for(let i = 0; i < comments.length; i++)if (util_1.Util.isInsideRange(comments[i].getRange().end, this.initialInstructions.getRange())) this.initialInstructions.addComment(comments[i]);\n        else {\n            for (const buildStage of this.buildStages)if (util_1.Util.isInsideRange(comments[i].getRange().start, buildStage.getRange())) buildStage.addComment(comments[i]);\n        }\n    }\n    getRange() {\n        const comments = this.getComments();\n        const instructions = this.getInstructions();\n        let range = null;\n        if (comments.length === 0) {\n            if (instructions.length > 0) range = vscode_languageserver_types_1.Range.create(instructions[0].getRange().start, instructions[instructions.length - 1].getRange().end);\n        } else if (instructions.length === 0) range = vscode_languageserver_types_1.Range.create(comments[0].getRange().start, comments[comments.length - 1].getRange().end);\n        else {\n            const commentStart = comments[0].getRange().start;\n            const commentEnd = comments[comments.length - 1].getRange().end;\n            const instructionStart = instructions[0].getRange().start;\n            const instructionEnd = instructions[instructions.length - 1].getRange().end;\n            if (commentStart.line < instructionStart.line) {\n                if (commentEnd.line < instructionEnd.line) range = vscode_languageserver_types_1.Range.create(commentStart, instructionEnd);\n                range = vscode_languageserver_types_1.Range.create(commentStart, commentEnd);\n            } else if (commentEnd.line < instructionEnd.line) range = vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n            else range = vscode_languageserver_types_1.Range.create(instructionStart, commentEnd);\n        }\n        if (range === null) {\n            if (this.directives.length === 0) return null;\n            return this.directives[0].getRange();\n        } else if (this.directives.length === 0) return range;\n        return vscode_languageserver_types_1.Range.create(this.directives[0].getRange().start, range.end);\n    }\n}\nexports.Dockerfile = Dockerfile;\n\n},{\"9b3d375bed950159\":\"ghSGy\",\"d891ee5557672a0b\":\"1irbL\",\"372addc62e869cb6\":\"dfryE\",\"3861ba9aa1dc6c84\":\"nTyT0\",\"e6e9b77f8d4a922b\":\"7JXpr\"}],\"dfryE\":[function(require,module,exports,__globalThis) {\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */ 'use strict';\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ImageTemplate = void 0;\nconst vscode_languageserver_types_1 = require(\"637eaa8a1fc84367\");\nconst arg_1 = require(\"8d6e1611976d457\");\nconst cmd_1 = require(\"7049fdb6ce6cfe77\");\nconst copy_1 = require(\"18fb214fae92c2ad\");\nconst env_1 = require(\"ed7edb89b8b53c18\");\nconst entrypoint_1 = require(\"404b55dc97f3131e\");\nconst from_1 = require(\"8a1e47b88288dfaa\");\nconst healthcheck_1 = require(\"67d1d9c7cde52290\");\nconst onbuild_1 = require(\"434b828c9fd563cf\");\nconst util_1 = require(\"94e3edfa252cd826\");\nconst workdir_1 = require(\"97943bcfae78dd09\");\nclass ImageTemplate {\n    constructor(){\n        this.comments = [];\n        this.instructions = [];\n    }\n    addComment(comment) {\n        this.comments.push(comment);\n    }\n    getComments() {\n        return this.comments;\n    }\n    addInstruction(instruction) {\n        this.instructions.push(instruction);\n    }\n    getInstructions() {\n        return this.instructions;\n    }\n    getInstructionAt(line) {\n        for (let instruction of this.instructions){\n            if (util_1.Util.isInsideRange(vscode_languageserver_types_1.Position.create(line, 0), instruction.getRange())) return instruction;\n        }\n        return null;\n    }\n    /**\n     * Gets all the ARG instructions that are defined in this image.\n     */ getARGs() {\n        let args = [];\n        for (let instruction of this.instructions)if (instruction instanceof arg_1.Arg) args.push(instruction);\n        return args;\n    }\n    /**\n     * Gets all the CMD instructions that are defined in this image.\n     */ getCMDs() {\n        let cmds = [];\n        for (let instruction of this.instructions)if (instruction instanceof cmd_1.Cmd) cmds.push(instruction);\n        return cmds;\n    }\n    /**\n     * Gets all the COPY instructions that are defined in this image.\n     */ getCOPYs() {\n        let copies = [];\n        for (let instruction of this.instructions)if (instruction instanceof copy_1.Copy) copies.push(instruction);\n        return copies;\n    }\n    /**\n     * Gets all the ENTRYPOINT instructions that are defined in this image.\n     */ getENTRYPOINTs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof entrypoint_1.Entrypoint) froms.push(instruction);\n        return froms;\n    }\n    /**\n     * Gets all the ENV instructions that are defined in this image.\n     */ getENVs() {\n        let args = [];\n        for (let instruction of this.instructions)if (instruction instanceof env_1.Env) args.push(instruction);\n        return args;\n    }\n    getFROM() {\n        for (const instruction of this.instructions){\n            if (instruction instanceof from_1.From) return instruction;\n        }\n        return null;\n    }\n    /**\n     * Gets all the FROM instructions that are defined in this image.\n     */ getFROMs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof from_1.From) froms.push(instruction);\n        return froms;\n    }\n    /**\n     * Gets all the HEALTHCHECK instructions that are defined in this image.\n     */ getHEALTHCHECKs() {\n        let froms = [];\n        for (let instruction of this.instructions)if (instruction instanceof healthcheck_1.Healthcheck) froms.push(instruction);\n        return froms;\n    }\n    getWORKDIRs() {\n        const workdirs = [];\n        for (const instruction of this.instructions)if (instruction instanceof workdir_1.Workdir) workdirs.push(instruction);\n        return workdirs;\n    }\n    getOnbuildTriggers() {\n        let triggers = [];\n        for (let instruction of this.instructions)if (instruction instanceof onbuild_1.Onbuild) {\n            let trigger = instruction.getTriggerInstruction();\n            if (trigger) triggers.push(trigger);\n        }\n        return triggers;\n    }\n    getAvailableVariables(currentLine) {\n        const variables = [];\n        for (const arg of this.getARGs())if (arg.isBefore(currentLine)) {\n            const property = arg.getProperty();\n            if (property) {\n                const variable = property.getName();\n                if (variables.indexOf(variable) === -1) variables.push(variable);\n            }\n        }\n        for (const env of this.getENVs()){\n            if (env.isBefore(currentLine)) for (const property of env.getProperties()){\n                const variable = property.getName();\n                if (variables.indexOf(variable) === -1) variables.push(variable);\n            }\n        }\n        return variables;\n    }\n    /**\n     * Resolves a variable with the given name at the specified line\n     * to its value. If null is returned, then the variable has been\n     * defined but no value was given. If undefined is returned, then\n     * a variable with the given name has not been defined yet as of\n     * the given line.\n     *\n     * @param variable the name of the variable to resolve\n     * @param line the line number that the variable is on, zero-based\n     * @return the value of the variable as defined by an ARG or ENV\n     *         instruction, or null if no value has been specified, or\n     *         undefined if a variable with the given name has not\n     *         been defined\n     */ resolveVariable(variable, line) {\n        let envs = this.getENVs();\n        for(let i = envs.length - 1; i >= 0; i--){\n            if (envs[i].isBefore(line)) for (let property of envs[i].getProperties()){\n                if (property.getName() === variable) return property.getValue();\n            }\n        }\n        let args = this.getARGs();\n        for(let i = args.length - 1; i >= 0; i--)if (args[i].isBefore(line)) {\n            let property = args[i].getProperty();\n            if (property && property.getName() === variable) return property.getValue();\n        }\n        return undefined;\n    }\n    getRange() {\n        const instructions = this.getInstructions();\n        if (instructions.length === 0) // all templates should have instructions, this only happens for\n        // the initial set of instruction\n        return vscode_languageserver_types_1.Range.create(0, 0, 0, 0);\n        const instructionStart = instructions[0].getRange().start;\n        const instructionEnd = instructions[instructions.length - 1].getRange().end;\n        return vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n    }\n    contains(position) {\n        const range = this.getRange();\n        if (range === null) return false;\n        return util_1.Util.isInsideRange(position, range);\n    }\n}\nexports.ImageTemplate = ImageTemplate;\n\n},{\"637eaa8a1fc84367\":\"ghSGy\",\"8d6e1611976d457\":\"aKTxx\",\"7049fdb6ce6cfe77\":\"9Gc1y\",\"18fb214fae92c2ad\":\"b3t88\",\"ed7edb89b8b53c18\":\"1F4QE\",\"404b55dc97f3131e\":\"a7xJN\",\"8a1e47b88288dfaa\":\"nTyT0\",\"67d1d9c7cde52290\":\"bkMBh\",\"434b828c9fd563cf\":\"8eYDK\",\"94e3edfa252cd826\":\"7JXpr\",\"97943bcfae78dd09\":\"alCEF\"}],\"kHqLa\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"run\", ()=>run);\nparcelHelpers.export(exports, \"runPiped\", ()=>runPiped);\nvar _spawnPlease = require(\"spawn-please\");\nvar _spawnPleaseDefault = parcelHelpers.interopDefault(_spawnPlease);\nvar _childProcess = require(\"child_process\");\nvar _childProcessDefault = parcelHelpers.interopDefault(_childProcess);\nasync function run(command, args) {\n    try {\n        return await (0, _spawnPleaseDefault.default)(command, args);\n    } catch (error) {\n        console.error(`Error running command: ${command} ${args.join(' ')}`);\n        throw error;\n    }\n}\nasync function runPiped([command1, args1], [command2, args2]) {\n    const cp1 = (0, _childProcessDefault.default).spawn(command1, args1, {\n        stdio: [\n            'inherit',\n            'pipe',\n            'inherit'\n        ]\n    });\n    const cp2 = (0, _childProcessDefault.default).spawn(command2, args2, {\n        stdio: [\n            'pipe',\n            'inherit',\n            'inherit'\n        ]\n    });\n    cp1.stdout.pipe(cp2.stdin);\n    await Promise.all([\n        assertSuccess(cp1),\n        assertSuccess(cp2)\n    ]);\n}\nfunction assertSuccess(cp) {\n    return new Promise((resolve, reject)=>{\n        cp.on('error', (error)=>{\n            reject(error);\n        });\n        cp.on('close', (code)=>{\n            if (code !== 0) reject(new Error(`process exited with code ${code}`));\n            resolve();\n        });\n    });\n}\n\n},{\"spawn-please\":\"7zP4I\",\"child_process\":\"child_process\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}],\"7zP4I\":[function(require,module,exports,__globalThis) {\nconst spawn = require(\"8fbf49fd88b8ce1a\");\n/** Spawns a child process, as long as you ask nicely.\n * \n * @param {string} command - The shell command to execute.\n * @param {string[]} [args] - An array of arguments that are given after the command.\n * @param {{ rejectOnError?: boolean, stdin?: string, stderr?: (data: string) => void, stdout?: (data: string) => void }} [options] - Options.\n * @param {any} [spawnOptions] - Options that are passed directly to child_process.spawn. Also supports stdin: string.\n * @returns {Promise<{ stdout: string, stderr: string }>}\n */ const spawnPlease = (command, args, options = {}, spawnOptions = {})=>{\n    // defaults\n    if (options.rejectOnError === undefined) options.rejectOnError = true;\n    let stdout = '';\n    let stderr = '';\n    const child = spawn(command, args, spawnOptions);\n    return new Promise((resolve, reject)=>{\n        if (options.stdin !== undefined && options.stdin != null) child.stdin.write(options.stdin);\n        child.stdin.end();\n        child.stdout.on('data', (data)=>{\n            stdout += data;\n            if (options.stdout) options.stdout(data);\n        });\n        child.stderr.on('data', (data)=>{\n            stderr += data;\n            if (options.stderr) options.stderr(data);\n        });\n        if (options.rejectOnError) child.addListener('error', reject);\n        child.on('close', (code)=>{\n            if (code !== 0 && options.rejectOnError) reject(stderr);\n            else resolve({\n                stdout,\n                stderr\n            });\n        });\n    });\n};\nmodule.exports = spawnPlease;\n\n},{\"8fbf49fd88b8ce1a\":\"gOFfe\"}],\"gOFfe\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst cp = require(\"5db4eea157dc6abd\");\nconst parse = require(\"f459d4faad83418d\");\nconst enoent = require(\"5967fe713a07bdb3\");\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n    return spawned;\n}\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n    return result;\n}\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n\n},{\"5db4eea157dc6abd\":\"child_process\",\"f459d4faad83418d\":\"hSOoE\",\"5967fe713a07bdb3\":\"e03Rd\"}],\"hSOoE\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst path = require(\"bb49ff520c0c29ab\");\nconst resolveCommand = require(\"cf8451362f6c35b9\");\nconst escape = require(\"f76fb8d716c0dfc3\");\nconst readShebang = require(\"91585cdbf7f6adf6\");\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n    const shebang = parsed.file && readShebang(parsed.file);\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        return resolveCommand(parsed);\n    }\n    return parsed.file;\n}\nfunction parseNonShell(parsed) {\n    if (!isWin) return parsed;\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));\n        const shellCommand = [\n            parsed.command\n        ].concat(parsed.args).join(' ');\n        parsed.args = [\n            '/d',\n            '/s',\n            '/c',\n            `\"${shellCommand}\"`\n        ];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n    return parsed;\n}\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args\n        }\n    };\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\nmodule.exports = parse;\n\n},{\"bb49ff520c0c29ab\":\"path\",\"cf8451362f6c35b9\":\"iyIqb\",\"f76fb8d716c0dfc3\":\"kqk3O\",\"91585cdbf7f6adf6\":\"9LoJM\"}],\"iyIqb\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst path = require(\"23fb8fe1b2d52b3\");\nconst which = require(\"f9b07d03c0b43245\");\nconst getPathKey = require(\"ef7a99e848f61b11\");\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) try {\n        process.chdir(parsed.options.cwd);\n    } catch (err) {\n    /* Empty */ }\n    let resolved;\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({\n                env\n            })],\n            pathExt: withoutPathExt ? path.delimiter : undefined\n        });\n    } catch (e) {\n    /* Empty */ } finally{\n        if (shouldSwitchCwd) process.chdir(cwd);\n    }\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    return resolved;\n}\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\nmodule.exports = resolveCommand;\n\n},{\"23fb8fe1b2d52b3\":\"path\",\"f9b07d03c0b43245\":\"g0W6J\",\"ef7a99e848f61b11\":\"7G1S5\"}],\"g0W6J\":[function(require,module,exports,__globalThis) {\nconst isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';\nconst path = require(\"1c762486b04d50e4\");\nconst COLON = isWindows ? ';' : ':';\nconst isexe = require(\"e2e7d3eebf2f2d35\");\nconst getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {\n        code: 'ENOENT'\n    });\nconst getPathInfo = (cmd, opt)=>{\n    const colon = opt.colon || COLON;\n    // If it has a slash, then we don't bother searching the pathenv.\n    // just check the file itself, and that's it.\n    const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [\n        ''\n    ] : [\n        // windows always checks the cwd first\n        ...isWindows ? [\n            process.cwd()\n        ] : [],\n        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ '').split(colon)\n    ];\n    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';\n    const pathExt = isWindows ? pathExtExe.split(colon) : [\n        ''\n    ];\n    if (isWindows) {\n        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');\n    }\n    return {\n        pathEnv,\n        pathExt,\n        pathExtExe\n    };\n};\nconst which = (cmd, opt, cb)=>{\n    if (typeof opt === 'function') {\n        cb = opt;\n        opt = {};\n    }\n    if (!opt) opt = {};\n    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n    const found = [];\n    const step = (i)=>new Promise((resolve, reject)=>{\n            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n            const ppRaw = pathEnv[i];\n            const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n            const pCmd = path.join(pathPart, cmd);\n            const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n            resolve(subStep(p, i, 0));\n        });\n    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{\n            if (ii === pathExt.length) return resolve(step(i + 1));\n            const ext = pathExt[ii];\n            isexe(p + ext, {\n                pathExt: pathExtExe\n            }, (er, is)=>{\n                if (!er && is) {\n                    if (opt.all) found.push(p + ext);\n                    else return resolve(p + ext);\n                }\n                return resolve(subStep(p, i, ii + 1));\n            });\n        });\n    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);\n};\nconst whichSync = (cmd, opt)=>{\n    opt = opt || {};\n    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);\n    const found = [];\n    for(let i = 0; i < pathEnv.length; i++){\n        const ppRaw = pathEnv[i];\n        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n        const pCmd = path.join(pathPart, cmd);\n        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n        for(let j = 0; j < pathExt.length; j++){\n            const cur = p + pathExt[j];\n            try {\n                const is = isexe.sync(cur, {\n                    pathExt: pathExtExe\n                });\n                if (is) {\n                    if (opt.all) found.push(cur);\n                    else return cur;\n                }\n            } catch (ex) {}\n        }\n    }\n    if (opt.all && found.length) return found;\n    if (opt.nothrow) return null;\n    throw getNotFoundError(cmd);\n};\nmodule.exports = which;\nwhich.sync = whichSync;\n\n},{\"1c762486b04d50e4\":\"path\",\"e2e7d3eebf2f2d35\":\"1pcPz\"}],\"1pcPz\":[function(require,module,exports,__globalThis) {\nvar fs = require(\"17f23b75862c81ed\");\nvar core;\nif (process.platform === 'win32' || global.TESTING_WINDOWS) core = require(\"b33dbc941d5fe763\");\nelse core = require(\"5d6b0a3a2e570368\");\nmodule.exports = isexe;\nisexe.sync = sync;\nfunction isexe(path, options, cb) {\n    if (typeof options === 'function') {\n        cb = options;\n        options = {};\n    }\n    if (!cb) {\n        if (typeof Promise !== 'function') throw new TypeError('callback not provided');\n        return new Promise(function(resolve, reject) {\n            isexe(path, options || {}, function(er, is) {\n                if (er) reject(er);\n                else resolve(is);\n            });\n        });\n    }\n    core(path, options || {}, function(er, is) {\n        // ignore EACCES because that just means we aren't allowed to run it\n        if (er) {\n            if (er.code === 'EACCES' || options && options.ignoreErrors) {\n                er = null;\n                is = false;\n            }\n        }\n        cb(er, is);\n    });\n}\nfunction sync(path, options) {\n    // my kingdom for a filtered catch\n    try {\n        return core.sync(path, options || {});\n    } catch (er) {\n        if (options && options.ignoreErrors || er.code === 'EACCES') return false;\n        else throw er;\n    }\n}\n\n},{\"17f23b75862c81ed\":\"fs\",\"b33dbc941d5fe763\":\"cwCNN\",\"5d6b0a3a2e570368\":\"hTVe9\"}],\"cwCNN\":[function(require,module,exports,__globalThis) {\nmodule.exports = isexe;\nisexe.sync = sync;\nvar fs = require(\"fa970ff537f37d97\");\nfunction checkPathExt(path, options) {\n    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;\n    if (!pathext) return true;\n    pathext = pathext.split(';');\n    if (pathext.indexOf('') !== -1) return true;\n    for(var i = 0; i < pathext.length; i++){\n        var p = pathext[i].toLowerCase();\n        if (p && path.substr(-p.length).toLowerCase() === p) return true;\n    }\n    return false;\n}\nfunction checkStat(stat, path, options) {\n    if (!stat.isSymbolicLink() && !stat.isFile()) return false;\n    return checkPathExt(path, options);\n}\nfunction isexe(path, options, cb) {\n    fs.stat(path, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, path, options));\n    });\n}\nfunction sync(path, options) {\n    return checkStat(fs.statSync(path), path, options);\n}\n\n},{\"fa970ff537f37d97\":\"fs\"}],\"hTVe9\":[function(require,module,exports,__globalThis) {\nmodule.exports = isexe;\nisexe.sync = sync;\nvar fs = require(\"ccfd6a39e8d0b5a7\");\nfunction isexe(path, options, cb) {\n    fs.stat(path, function(er, stat) {\n        cb(er, er ? false : checkStat(stat, options));\n    });\n}\nfunction sync(path, options) {\n    return checkStat(fs.statSync(path), options);\n}\nfunction checkStat(stat, options) {\n    return stat.isFile() && checkMode(stat, options);\n}\nfunction checkMode(stat, options) {\n    var mod = stat.mode;\n    var uid = stat.uid;\n    var gid = stat.gid;\n    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();\n    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();\n    var u = parseInt('100', 8);\n    var g = parseInt('010', 8);\n    var o = parseInt('001', 8);\n    var ug = u | g;\n    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;\n    return ret;\n}\n\n},{\"ccfd6a39e8d0b5a7\":\"fs\"}],\"7G1S5\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst pathKey = (options = {})=>{\n    const environment = options.env || process.env;\n    const platform = options.platform || process.platform;\n    if (platform !== 'win32') return 'PATH';\n    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';\n};\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n\n},{}],\"kqk3O\":[function(require,module,exports,__globalThis) {\n'use strict';\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n    return arg;\n}\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n    // All other backslashes occur literally\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) arg = arg.replace(metaCharsRegExp, '^$1');\n    return arg;\n}\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n\n},{}],\"9LoJM\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst fs = require(\"2fc5e4232a07a9d2\");\nconst shebangCommand = require(\"c4e857260abf33c0\");\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n    let fd;\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) {}\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\nmodule.exports = readShebang;\n\n},{\"2fc5e4232a07a9d2\":\"fs\",\"c4e857260abf33c0\":\"drkAo\"}],\"drkAo\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst shebangRegex = require(\"9df9c2d321a8ee95\");\nmodule.exports = (string = '')=>{\n    const match = string.match(shebangRegex);\n    if (!match) return null;\n    const [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n    const binary = path.split('/').pop();\n    if (binary === 'env') return argument;\n    return argument ? `${binary} ${argument}` : binary;\n};\n\n},{\"9df9c2d321a8ee95\":\"gq3Q3\"}],\"gq3Q3\":[function(require,module,exports,__globalThis) {\n'use strict';\nmodule.exports = /^#!(.*)/;\n\n},{}],\"e03Rd\":[function(require,module,exports,__globalThis) {\n'use strict';\nconst isWin = process.platform === 'win32';\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args\n    });\n}\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) return;\n    const originalEmit = cp.emit;\n    cp.emit = function(name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n            if (err) return originalEmit.call(cp, 'error', err);\n        }\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, 'spawn');\n    return null;\n}\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) return notFoundError(parsed.original, 'spawnSync');\n    return null;\n}\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError\n};\n\n},{}],\"14eXt\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"extractCaches\", ()=>extractCaches);\nvar _fs = require(\"fs\");\nvar _path = require(\"path\");\nvar _pathDefault = parcelHelpers.interopDefault(_path);\nvar _optsJs = require(\"./opts.js\");\nvar _runJs = require(\"./run.js\");\nasync function extractCache(cacheSource, cacheOptions, scratchDir, containerImage, builder) {\n    // Prepare Timestamp for Layer Cache Busting\n    const date = new Date().toISOString();\n    await (0, _fs.promises).mkdir(scratchDir, {\n        recursive: true\n    });\n    await (0, _fs.promises).writeFile((0, _pathDefault.default).join(scratchDir, 'buildstamp'), date);\n    // Prepare Dancefile to Access Caches\n    const targetPath = (0, _optsJs.getTargetPath)(cacheOptions);\n    const mountArgs = (0, _optsJs.getMountArgsString)(cacheOptions);\n    const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    mkdir -p /var/dance-cache/ \\\n    && cp -p -R ${targetPath}/. /var/dance-cache/ || true\n`;\n    await (0, _fs.promises).writeFile((0, _pathDefault.default).join(scratchDir, 'Dancefile.extract'), dancefileContent);\n    console.log(dancefileContent);\n    // Extract Data into Docker Image\n    await (0, _runJs.run)('docker', [\n        'buildx',\n        'build',\n        '--builder',\n        builder,\n        '-f',\n        (0, _pathDefault.default).join(scratchDir, 'Dancefile.extract'),\n        '--tag',\n        'dance:extract',\n        '--load',\n        scratchDir\n    ]);\n    // Create Extraction Image\n    try {\n        await (0, _runJs.run)('docker', [\n            'rm',\n            '-f',\n            'cache-container'\n        ]);\n    } catch (error) {\n    // Ignore error if container does not exist\n    }\n    await (0, _runJs.run)('docker', [\n        'create',\n        '-ti',\n        '--name',\n        'cache-container',\n        'dance:extract'\n    ]);\n    // Unpack Docker Image into Scratch\n    await (0, _runJs.runPiped)([\n        'docker',\n        [\n            'cp',\n            '-L',\n            'cache-container:/var/dance-cache',\n            '-'\n        ]\n    ], [\n        'tar',\n        [\n            '-H',\n            'posix',\n            '-x',\n            '-C',\n            scratchDir\n        ]\n    ]);\n    // Move Cache into Its Place\n    await (0, _runJs.run)('sudo', [\n        'rm',\n        '-rf',\n        cacheSource\n    ]);\n    await (0, _fs.promises).rename((0, _pathDefault.default).join(scratchDir, 'dance-cache'), cacheSource);\n}\nasync function extractCaches(opts) {\n    if (opts[\"skip-extraction\"]) {\n        console.log(\"skip-extraction is set. Skipping extraction step...\");\n        return;\n    }\n    const cacheMap = await (0, _optsJs.getCacheMap)(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = (0, _optsJs.getBuilder)(opts);\n    // Extract Caches for each source-target pair\n    for (const [cacheSource, cacheOptions] of Object.entries(cacheMap))await extractCache(cacheSource, cacheOptions, scratchDir, containerImage, builder);\n}\n\n},{\"fs\":\"fs\",\"path\":\"path\",\"./opts.js\":\"bjlzi\",\"./run.js\":\"kHqLa\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"8h9S8\"}]},[\"7sz5b\"], \"7sz5b\", \"parcelRequire86b4\", {\"fs\": __parcelExternal0,\"os\": __parcelExternal1,\"path\": __parcelExternal2,\"http\": __parcelExternal3,\"https\": __parcelExternal4,\"net\": __parcelExternal5,\"tls\": __parcelExternal6,\"events\": __parcelExternal7,\"assert\": __parcelExternal8,\"util\": __parcelExternal9,\"child_process\": __parcelExternal10,})\nlet {} = parcelRequire86b4(\"7sz5b\");\nexport {};\n\n//# sourceMappingURL=index.js.map\n","import { promises as fs } from \"fs\";\nimport os from \"os\";\nimport { injectCaches } from \"./inject-cache.js\";\nimport { extractCaches } from \"./extract-cache.js\";\nimport { help, parseOpts } from \"./opts.js\";\n\nasync function main(args: string[]) {\n  const opts = parseOpts(args);\n\n  if (opts.help) {\n    return help();\n  }\n\n  if (opts.extract) {\n    // Run the post step\n    await extractCaches(opts);\n  } else {\n    // Otherwise, this is the main step\n    if (process.env.GITHUB_STATE !== undefined) {\n      await fs.appendFile(process.env.GITHUB_STATE, `POST=true${os.EOL}`);\n    }\n    await injectCaches(opts);\n  }\n}\n\nmain(process.argv)\n    .catch(err => {\n        console.error(err);\n        if (err instanceof Error) {\n            console.error(err.stack);\n        }\n        process.exit(1);\n    });\n","import { promises as fs } from \"fs\";\nimport path from 'path';\nimport { CacheOptions, Opts, getCacheMap, getMountArgsString, getTargetPath, getUID, getGID, getBuilder } from './opts.js';\nimport { run } from './run.js';\nimport { notice } from '@actions/core/lib/core.js';\n\nasync function injectCache(cacheSource: string, cacheOptions: CacheOptions, scratchDir: string, containerImage: string, builder: string) {\n    // Clean Scratch Directory\n    await fs.rm(scratchDir, { recursive: true, force: true });\n    await fs.mkdir(scratchDir, { recursive: true });\n\n    // Prepare Cache Source Directory\n    await fs.mkdir(cacheSource, { recursive: true });\n\n    // Prepare Timestamp for Layer Cache Busting\n    const date = new Date().toISOString();\n    await fs.writeFile(path.join(cacheSource, 'buildstamp'), date);\n\n    const targetPath = getTargetPath(cacheOptions);\n    const mountArgs = getMountArgsString(cacheOptions);\n\n    // If UID OR GID are set, then add chown to restore files ownership.\n    let ownershipCommand = \"\";\n    const uid = getUID(cacheOptions);\n    const gid = getGID(cacheOptions);\n    if (uid !== \"\" || gid !== \"\") {\n        ownershipCommand = `&& chown -R ${uid}:${gid} ${targetPath}`\n    }\n\n    // Prepare Dancefile to Access Caches\n    const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    --mount=type=bind,source=.,target=/var/dance-cache \\\n    cp -p -R /var/dance-cache/. ${targetPath} ${ownershipCommand} || true\n`;\n    await fs.writeFile(path.join(scratchDir, 'Dancefile.inject'), dancefileContent);\n    console.log(dancefileContent);\n\n    // Inject Data into Docker Cache\n    await run('docker', ['buildx', 'build', '--builder', builder ,'-f', path.join(scratchDir, 'Dancefile.inject'), '--tag', 'dance:inject', cacheSource]);\n\n    // Clean Directories\n    try {\n        await fs.rm(cacheSource, { recursive: true, force: true });\n    } catch (err) {\n        // Ignore Cleaning Errors\n        notice(`Error while cleaning cache source directory: ${err}. Ignoring...`);\n    }\n}\n\n\nexport async function injectCaches(opts: Opts) {\n    const cacheMap = await getCacheMap(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n\n    const builder = getBuilder(opts);\n    // Inject Caches for each source-target pair\n    for (const [cacheSource, cacheOptions] of Object.entries(cacheMap)) {\n        await injectCache(cacheSource, cacheOptions, scratchDir, containerImage, builder);\n    }\n}\n","import mri from 'mri';\nimport { promises as fs } from 'fs';\nimport { getInput, warning } from '@actions/core/lib/core.js';\nimport { DockerfileParser, ModifiableInstruction } from 'dockerfile-ast';\n\nexport type Opts = {\n  \"extract\": boolean\n  \"cache-map\": string\n  \"dockerfile\": string\n  \"cache-dir\": string | null\n  \"scratch-dir\": string\n  \"skip-extraction\": boolean\n  \"utility-image\": string\n  \"builder\"?: string\n  help: boolean\n  /** @deprecated Use `cache-map` instead */\n  \"cache-source\"?: string\n  /** @deprecated Use `cache-map` instead */\n  \"cache-target\"?: string\n}\n\nexport function parseOpts(args: string[]): mri.Argv<Opts> {\n  const opts = mri<Opts>(args, {\n    default: {\n      \"cache-map\": getInput(\"cache-map\") || \"{}\",\n      \"dockerfile\": getInput(\"dockerfile\") || \"Dockerfile\",\n      \"cache-dir\": getInput(\"cache-dir\") || null,\n      \"scratch-dir\": getInput(\"scratch-dir\") || \"scratch\",\n      \"skip-extraction\": (getInput(\"skip-extraction\") || \"false\") === \"true\",\n      \"extract\": process.env[`STATE_POST`] !== undefined,\n      \"utility-image\": getInput(\"utility-image\") || \"ghcr.io/containerd/busybox:latest\",\n      \"builder\": getInput(\"builder\") || \"default\",\n      \"help\": false,\n    },\n    string: [\"cache-map\", \"dockerfile\", \"cache-dir\", \"scratch-dir\", \"cache-source\", \"cache-target\", \"utility-image\", \"builder\"],\n    boolean: [\"skip-extraction\", \"help\", \"extract\"],\n    alias: {\n      \"help\": [\"h\"],\n    },\n  })\n\n  if (opts[\"cache-source\"] && opts[\"cache-target\"]) {\n    warning(\"The `cache-source` and `cache-target` options are deprecated. Use `cache-map` instead.\")\n\n    opts[\"cache-map\"] = JSON.stringify({\n      [opts[\"cache-source\"]]: opts[\"cache-target\"],\n    });\n  }\n\n  return opts;\n}\n\nexport function help() {\n  console.log(`build-cache-dance [options]\nSave 'RUN --mount=type=cache' caches on GitHub Actions or other CI platforms\n\nOptions:\n  --extract      Extract the cache from the docker container (extract step). Otherwise, inject the cache (main step)\n  --cache-map    The map of actions source paths to container destination paths or mount arguments\n  --dockerfile   The Dockerfile to use for auto-discovery of the cache-map. Default: 'Dockerfile'\n  --cache-dir    The root directory where cache content is injected from/extracted to when using auto-discovery of the cache-map.\n  --scratch-dir  Where the action is stores some temporary files for its processing. Default: 'scratch'\n  --skip-extraction  Skip the extraction of the cache from the docker container\n  --utility-image  The container image to use for injecting and extracting the cache. Default: 'ghcr.io/containerd/busybox:latest'\n  --builder      The name of the buildx builder to use for the cache injection\n  --help         Show this help\n`);\n}\n\nexport type SourcePath = string\nexport type TargetPath = string\nexport type ToStringable = {\n  toString(): string;\n}\nexport type CacheOptions = TargetPath | { target: TargetPath } & Record<string, ToStringable>\nexport type CacheMap = Record<SourcePath, CacheOptions>\n\nasync function getCacheMapFromDockerfile(dockerfilePath: string, bindRoot: string | null): Promise<CacheMap> {\n  const dockerfileContent = await fs.readFile(dockerfilePath, \"utf-8\");\n  const dockerfile = DockerfileParser.parse(dockerfileContent);\n\n  const cacheMap: CacheMap = {};\n\n  const runInstructions = dockerfile.getInstructions().filter(i => i.getKeyword() == 'RUN') as Array<ModifiableInstruction>;\n  for (const run of runInstructions) {\n    for (const flag of run.getFlags()) {\n      if (flag.getName() == 'mount' && flag.getOption('type')?.getValue() == 'cache') {\n        // Extract the `id` flag which defaults to `target` when `id` is not set\n        // https://docs.docker.com/reference/dockerfile/#run---mounttypecache\n        const id = flag.getOption('id')?.getValue() || flag.getOption('target')?.getValue();\n        if (id == null) {\n          throw new Error('cache mount must define id or target: ' + flag.toString() + ' in ' + run.toString());\n        }\n\n        // The directory on the host to inject/extract the cache mount data from\n        const bindDir = bindRoot !== null ? `${bindRoot}/${id}` : id\n\n        // The target in this action does not matter as long as it is\n        // different than /var/dance-cache of course\n        const target = \"/var/cache-target\";\n\n        cacheMap[bindDir] = {\n          id,\n          target,\n        };\n      }\n    }\n  }\n\n  return cacheMap;\n}\n\nexport async function getCacheMap(opts: Opts): Promise<CacheMap> {\n  try {\n    const cacheMap = JSON.parse(opts[\"cache-map\"]) as CacheMap;\n    if (Object.keys(cacheMap).length !== 0) {\n      return cacheMap;\n    }\n\n    console.log(`No cache map provided. Trying to parse the Dockerfile to find the cache mount instructions...`);\n    const cacheMapFromDockerfile = await getCacheMapFromDockerfile(opts[\"dockerfile\"], opts[\"cache-dir\"]);\n    console.log(`Cache map parsed from Dockerfile: ${JSON.stringify(cacheMapFromDockerfile)}`);\n    return cacheMapFromDockerfile;\n  } catch (e) {\n    throw new Error(`Failed to parse cache map. Expected JSON, got:\\n${opts[\"cache-map\"]}\\n${e}`);\n  }\n}\n\nexport function getTargetPath(cacheOptions: CacheOptions): TargetPath {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return cacheOptions;\n  } else {\n    // object is provided\n    if (\"target\" in cacheOptions) {\n      return cacheOptions.target;\n    } else {\n      throw new Error(`Expected the 'target' key in the cache options, got:\\n${cacheOptions}`);\n    }\n  }\n}\n\nexport function getUID(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return \"\";\n  } else {\n    // object is provided\n    if (\"uid\" in cacheOptions && cacheOptions.uid !== undefined) {\n      return cacheOptions.uid.toString();\n    } else {\n      return \"\";\n    }\n  }\n}\n\nexport function getGID(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return \"\";\n  } else {\n    // object is provided\n    if (\"gid\" in cacheOptions && cacheOptions.gid !== undefined) {\n      return cacheOptions.gid.toString();\n    } else {\n      return \"\";\n    }\n  }\n}\n\n/**\n * Convert a cache options to a string that is passed to --mount=\n * @param CacheOptions The cache options to convert to a string\n */\nexport function getMountArgsString(cacheOptions: CacheOptions): string {\n  if (typeof cacheOptions === \"string\") {\n    // only the target path is provided\n    return `type=cache,target=${cacheOptions}`;\n  } else {\n    // other options are provided\n    const otherOptions = Object.entries(cacheOptions).map(([key, value]) => `${key}=${value}`).join(\",\");\n    return `type=cache,${otherOptions}`;\n  }\n}\n\nexport function getBuilder(opts: Opts): string {\n    return opts[\"builder\"] == null || opts[\"builder\"] == \"\" ? \"default\" : opts[\"builder\"];\n}\n","function toArr(any) {\n\treturn any == null ? [] : Array.isArray(any) ? any : [any];\n}\n\nfunction toVal(out, key, val, opts) {\n\tvar x, old=out[key], nxt=(\n\t\t!!~opts.string.indexOf(key) ? (val == null || val === true ? '' : String(val))\n\t\t: typeof val === 'boolean' ? val\n\t\t: !!~opts.boolean.indexOf(key) ? (val === 'false' ? false : val === 'true' || (out._.push((x = +val,x * 0 === 0) ? x : val),!!val))\n\t\t: (x = +val,x * 0 === 0) ? x : val\n\t);\n\tout[key] = old == null ? nxt : (Array.isArray(old) ? old.concat(nxt) : [old, nxt]);\n}\n\nexport default function (args, opts) {\n\targs = args || [];\n\topts = opts || {};\n\n\tvar k, arr, arg, name, val, out={ _:[] };\n\tvar i=0, j=0, idx=0, len=args.length;\n\n\tconst alibi = opts.alias !== void 0;\n\tconst strict = opts.unknown !== void 0;\n\tconst defaults = opts.default !== void 0;\n\n\topts.alias = opts.alias || {};\n\topts.string = toArr(opts.string);\n\topts.boolean = toArr(opts.boolean);\n\n\tif (alibi) {\n\t\tfor (k in opts.alias) {\n\t\t\tarr = opts.alias[k] = toArr(opts.alias[k]);\n\t\t\tfor (i=0; i < arr.length; i++) {\n\t\t\t\t(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=opts.boolean.length; i-- > 0;) {\n\t\tarr = opts.alias[opts.boolean[i]] || [];\n\t\tfor (j=arr.length; j-- > 0;) opts.boolean.push(arr[j]);\n\t}\n\n\tfor (i=opts.string.length; i-- > 0;) {\n\t\tarr = opts.alias[opts.string[i]] || [];\n\t\tfor (j=arr.length; j-- > 0;) opts.string.push(arr[j]);\n\t}\n\n\tif (defaults) {\n\t\tfor (k in opts.default) {\n\t\t\tname = typeof opts.default[k];\n\t\t\tarr = opts.alias[k] = opts.alias[k] || [];\n\t\t\tif (opts[name] !== void 0) {\n\t\t\t\topts[name].push(k);\n\t\t\t\tfor (i=0; i < arr.length; i++) {\n\t\t\t\t\topts[name].push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst keys = strict ? Object.keys(opts.alias) : [];\n\n\tfor (i=0; i < len; i++) {\n\t\targ = args[i];\n\n\t\tif (arg === '--') {\n\t\t\tout._ = out._.concat(args.slice(++i));\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j=0; j < arg.length; j++) {\n\t\t\tif (arg.charCodeAt(j) !== 45) break; // \"-\"\n\t\t}\n\n\t\tif (j === 0) {\n\t\t\tout._.push(arg);\n\t\t} else if (arg.substring(j, j + 3) === 'no-') {\n\t\t\tname = arg.substring(j + 3);\n\t\t\tif (strict && !~keys.indexOf(name)) {\n\t\t\t\treturn opts.unknown(arg);\n\t\t\t}\n\t\t\tout[name] = false;\n\t\t} else {\n\t\t\tfor (idx=j+1; idx < arg.length; idx++) {\n\t\t\t\tif (arg.charCodeAt(idx) === 61) break; // \"=\"\n\t\t\t}\n\n\t\t\tname = arg.substring(j, idx);\n\t\t\tval = arg.substring(++idx) || (i+1 === len || (''+args[i+1]).charCodeAt(0) === 45 || args[++i]);\n\t\t\tarr = (j === 2 ? [name] : name);\n\n\t\t\tfor (idx=0; idx < arr.length; idx++) {\n\t\t\t\tname = arr[idx];\n\t\t\t\tif (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);\n\t\t\t\ttoVal(out, name, (idx + 1 < arr.length) || val, opts);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (defaults) {\n\t\tfor (k in opts.default) {\n\t\t\tif (out[k] === void 0) {\n\t\t\t\tout[k] = opts.default[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alibi) {\n\t\tfor (k in out) {\n\t\t\tarr = opts.alias[k] || [];\n\t\t\twhile (arr.length > 0) {\n\t\t\t\tout[arr.shift()] = out[k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n",null,null,null,null,null,null,null,null,null,null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n",null,null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DockerfileParser = exports.DefaultVariables = exports.Directive = exports.Keyword = exports.Workdir = exports.Volume = exports.User = exports.Stopsignal = exports.Shell = exports.Run = exports.PropertyInstruction = exports.Onbuild = exports.ModifiableInstruction = exports.Label = exports.JSONInstruction = exports.Heredoc = exports.Healthcheck = exports.From = exports.Env = exports.Entrypoint = exports.Copy = exports.Cmd = exports.Arg = exports.Add = exports.Variable = exports.Property = exports.ParserDirective = exports.Line = exports.Instruction = exports.Flag = exports.Comment = exports.JSONArgument = exports.Argument = void 0;\nvar argument_1 = require(\"./argument\");\nObject.defineProperty(exports, \"Argument\", { enumerable: true, get: function () { return argument_1.Argument; } });\nvar jsonArgument_1 = require(\"./jsonArgument\");\nObject.defineProperty(exports, \"JSONArgument\", { enumerable: true, get: function () { return jsonArgument_1.JSONArgument; } });\nconst comment_1 = require(\"./comment\");\nObject.defineProperty(exports, \"Comment\", { enumerable: true, get: function () { return comment_1.Comment; } });\nconst parser_1 = require(\"./parser\");\nvar flag_1 = require(\"./flag\");\nObject.defineProperty(exports, \"Flag\", { enumerable: true, get: function () { return flag_1.Flag; } });\nconst instruction_1 = require(\"./instruction\");\nObject.defineProperty(exports, \"Instruction\", { enumerable: true, get: function () { return instruction_1.Instruction; } });\nvar line_1 = require(\"./line\");\nObject.defineProperty(exports, \"Line\", { enumerable: true, get: function () { return line_1.Line; } });\nconst parserDirective_1 = require(\"./parserDirective\");\nObject.defineProperty(exports, \"ParserDirective\", { enumerable: true, get: function () { return parserDirective_1.ParserDirective; } });\nvar property_1 = require(\"./property\");\nObject.defineProperty(exports, \"Property\", { enumerable: true, get: function () { return property_1.Property; } });\nvar variable_1 = require(\"./variable\");\nObject.defineProperty(exports, \"Variable\", { enumerable: true, get: function () { return variable_1.Variable; } });\nvar add_1 = require(\"./instructions/add\");\nObject.defineProperty(exports, \"Add\", { enumerable: true, get: function () { return add_1.Add; } });\nconst arg_1 = require(\"./instructions/arg\");\nObject.defineProperty(exports, \"Arg\", { enumerable: true, get: function () { return arg_1.Arg; } });\nconst cmd_1 = require(\"./instructions/cmd\");\nObject.defineProperty(exports, \"Cmd\", { enumerable: true, get: function () { return cmd_1.Cmd; } });\nconst copy_1 = require(\"./instructions/copy\");\nObject.defineProperty(exports, \"Copy\", { enumerable: true, get: function () { return copy_1.Copy; } });\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nObject.defineProperty(exports, \"Entrypoint\", { enumerable: true, get: function () { return entrypoint_1.Entrypoint; } });\nconst env_1 = require(\"./instructions/env\");\nObject.defineProperty(exports, \"Env\", { enumerable: true, get: function () { return env_1.Env; } });\nconst from_1 = require(\"./instructions/from\");\nObject.defineProperty(exports, \"From\", { enumerable: true, get: function () { return from_1.From; } });\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nObject.defineProperty(exports, \"Healthcheck\", { enumerable: true, get: function () { return healthcheck_1.Healthcheck; } });\nvar heredoc_1 = require(\"./heredoc\");\nObject.defineProperty(exports, \"Heredoc\", { enumerable: true, get: function () { return heredoc_1.Heredoc; } });\nvar jsonInstruction_1 = require(\"./jsonInstruction\");\nObject.defineProperty(exports, \"JSONInstruction\", { enumerable: true, get: function () { return jsonInstruction_1.JSONInstruction; } });\nvar label_1 = require(\"./instructions/label\");\nObject.defineProperty(exports, \"Label\", { enumerable: true, get: function () { return label_1.Label; } });\nvar modifiableInstruction_1 = require(\"./modifiableInstruction\");\nObject.defineProperty(exports, \"ModifiableInstruction\", { enumerable: true, get: function () { return modifiableInstruction_1.ModifiableInstruction; } });\nvar onbuild_1 = require(\"./instructions/onbuild\");\nObject.defineProperty(exports, \"Onbuild\", { enumerable: true, get: function () { return onbuild_1.Onbuild; } });\nvar propertyInstruction_1 = require(\"./propertyInstruction\");\nObject.defineProperty(exports, \"PropertyInstruction\", { enumerable: true, get: function () { return propertyInstruction_1.PropertyInstruction; } });\nvar run_1 = require(\"./instructions/run\");\nObject.defineProperty(exports, \"Run\", { enumerable: true, get: function () { return run_1.Run; } });\nvar shell_1 = require(\"./instructions/shell\");\nObject.defineProperty(exports, \"Shell\", { enumerable: true, get: function () { return shell_1.Shell; } });\nvar stopsignal_1 = require(\"./instructions/stopsignal\");\nObject.defineProperty(exports, \"Stopsignal\", { enumerable: true, get: function () { return stopsignal_1.Stopsignal; } });\nvar user_1 = require(\"./instructions/user\");\nObject.defineProperty(exports, \"User\", { enumerable: true, get: function () { return user_1.User; } });\nvar volume_1 = require(\"./instructions/volume\");\nObject.defineProperty(exports, \"Volume\", { enumerable: true, get: function () { return volume_1.Volume; } });\nconst workdir_1 = require(\"./instructions/workdir\");\nObject.defineProperty(exports, \"Workdir\", { enumerable: true, get: function () { return workdir_1.Workdir; } });\nvar Keyword;\n(function (Keyword) {\n    Keyword[\"ADD\"] = \"ADD\";\n    Keyword[\"ARG\"] = \"ARG\";\n    Keyword[\"CMD\"] = \"CMD\";\n    Keyword[\"COPY\"] = \"COPY\";\n    Keyword[\"ENTRYPOINT\"] = \"ENTRYPOINT\";\n    Keyword[\"ENV\"] = \"ENV\";\n    Keyword[\"EXPOSE\"] = \"EXPOSE\";\n    Keyword[\"FROM\"] = \"FROM\";\n    Keyword[\"HEALTHCHECK\"] = \"HEALTHCHECK\";\n    Keyword[\"LABEL\"] = \"LABEL\";\n    Keyword[\"MAINTAINER\"] = \"MAINTAINER\";\n    Keyword[\"ONBUILD\"] = \"ONBUILD\";\n    Keyword[\"RUN\"] = \"RUN\";\n    Keyword[\"SHELL\"] = \"SHELL\";\n    Keyword[\"STOPSIGNAL\"] = \"STOPSIGNAL\";\n    Keyword[\"USER\"] = \"USER\";\n    Keyword[\"VOLUME\"] = \"VOLUME\";\n    Keyword[\"WORKDIR\"] = \"WORKDIR\";\n})(Keyword || (exports.Keyword = Keyword = {}));\nvar Directive;\n(function (Directive) {\n    Directive[\"escape\"] = \"escape\";\n    Directive[\"syntax\"] = \"syntax\";\n})(Directive || (exports.Directive = Directive = {}));\nexports.DefaultVariables = [\n    \"ALL_PROXY\", \"all_proxy\",\n    \"FTP_PROXY\", \"ftp_proxy\",\n    \"HTTP_PROXY\", \"http_proxy\",\n    \"HTTPS_PROXY\", \"https_proxy\",\n    \"NO_PROXY\", \"no_proxy\"\n];\nvar DockerfileParser;\n(function (DockerfileParser) {\n    function parse(content) {\n        let parser = new parser_1.Parser();\n        return parser.parse(content);\n    }\n    DockerfileParser.parse = parse;\n})(DockerfileParser || (exports.DockerfileParser = DockerfileParser = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Argument = void 0;\nclass Argument {\n    constructor(value, range) {\n        this.value = value;\n        this.range = range;\n    }\n    toString() {\n        return this.value;\n    }\n    getRange() {\n        return this.range;\n    }\n    getValue() {\n        return this.value;\n    }\n    isAfter(position) {\n        if (this.range.end.line < position.line) {\n            return false;\n        }\n        return this.range.start.line > position.line ? true : this.range.start.character > position.character;\n    }\n    isBefore(position) {\n        if (this.range.start.line < position.line) {\n            return true;\n        }\n        return this.range.end.line > position.line ? false : this.range.end.character < position.character;\n    }\n}\nexports.Argument = Argument;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONArgument = void 0;\nconst argument_1 = require(\"./argument\");\nclass JSONArgument extends argument_1.Argument {\n    constructor(value, range, jsonRange) {\n        super(value, range);\n        this.jsonRange = jsonRange;\n    }\n    getJSONRange() {\n        return this.jsonRange;\n    }\n    getJSONValue() {\n        let value = super.getValue();\n        value = value.substring(1, value.length - 1);\n        return value;\n    }\n}\nexports.JSONArgument = JSONArgument;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Comment = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst line_1 = require(\"./line\");\nconst util_1 = require(\"./util\");\nclass Comment extends line_1.Line {\n    constructor(document, range) {\n        super(document, range);\n    }\n    toString() {\n        const content = this.getContent();\n        if (content) {\n            return \"# \" + content;\n        }\n        return \"#\";\n    }\n    /**\n     * Returns the content of this comment. This excludes leading and\n     * trailing whitespace as well as the # symbol. If the comment only\n     * consists of whitespace, the empty string will be returned.\n     */\n    getContent() {\n        let range = this.getContentRange();\n        if (range === null) {\n            return \"\";\n        }\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    /**\n     * Returns a range that includes the content of the comment\n     * excluding any leading and trailing whitespace as well as the #\n     * symbol. May return null if the comment only consists of whitespace\n     * characters.\n     */\n    getContentRange() {\n        let range = this.getRange();\n        const startOffset = this.document.offsetAt(range.start);\n        let raw = this.document.getText().substring(startOffset, this.document.offsetAt(range.end));\n        let start = -1;\n        let end = -1;\n        // skip the first # symbol\n        for (let i = 1; i < raw.length; i++) {\n            if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n                start = i;\n                break;\n            }\n        }\n        if (start === -1) {\n            return null;\n        }\n        // go backwards up to the first # symbol\n        for (let i = raw.length - 1; i >= 1; i--) {\n            if (!util_1.Util.isWhitespace(raw.charAt(i))) {\n                end = i + 1;\n                break;\n            }\n        }\n        return vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + start), this.document.positionAt(startOffset + end));\n    }\n}\nexports.Comment = Comment;\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;\n    var DocumentUri;\n    (function (DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function (URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports.URI = URI = {}));\n    var integer;\n    (function (integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports.integer = integer = {}));\n    var uinteger;\n    (function (uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */\n    var Position;\n    (function (Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */\n        function create(line, character) {\n            if (line === Number.MAX_VALUE) {\n                line = uinteger.MAX_VALUE;\n            }\n            if (character === Number.MAX_VALUE) {\n                character = uinteger.MAX_VALUE;\n            }\n            return { line: line, character: character };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */\n    var Range;\n    (function (Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n                return { start: Position.create(one, two), end: Position.create(three, four) };\n            }\n            else if (Position.is(one) && Position.is(two)) {\n                return { start: one, end: two };\n            }\n            else {\n                throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n            }\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */\n    var Location;\n    (function (Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */\n        function create(uri, range) {\n            return { uri: uri, range: range };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */\n    var LocationLink;\n    (function (LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */\n        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n                && Range.is(candidate.targetSelectionRange)\n                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */\n    var Color;\n    (function (Color) {\n        /**\n         * Creates a new Color literal.\n         */\n        function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha,\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n                && Is.numberRange(candidate.green, 0, 1)\n                && Is.numberRange(candidate.blue, 0, 1)\n                && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */\n    var ColorInformation;\n    (function (ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(range, color) {\n            return {\n                range: range,\n                color: color,\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */\n    var ColorPresentation;\n    (function (ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits,\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label)\n                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */\n    var FoldingRangeKind;\n    (function (FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */\n        FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */\n        FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */\n        FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */\n    var FoldingRange;\n    (function (FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */\n        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) {\n                result.startCharacter = startCharacter;\n            }\n            if (Is.defined(endCharacter)) {\n                result.endCharacter = endCharacter;\n            }\n            if (Is.defined(kind)) {\n                result.kind = kind;\n            }\n            if (Is.defined(collapsedText)) {\n                result.collapsedText = collapsedText;\n            }\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */\n    var DiagnosticRelatedInformation;\n    (function (DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */\n        function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */\n    var DiagnosticSeverity;\n    (function (DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */\n        DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */\n        DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */\n        DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */\n        DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */\n    var DiagnosticTag;\n    (function (DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */\n        DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */\n        DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */\n    var CodeDescription;\n    (function (CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */\n    var Diagnostic;\n    (function (Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */\n        function create(range, message, severity, code, source, relatedInformation) {\n            var result = { range: range, message: message };\n            if (Is.defined(severity)) {\n                result.severity = severity;\n            }\n            if (Is.defined(code)) {\n                result.code = code;\n            }\n            if (Is.defined(source)) {\n                result.source = source;\n            }\n            if (Is.defined(relatedInformation)) {\n                result.relatedInformation = relatedInformation;\n            }\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */\n        function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate)\n                && Range.is(candidate.range)\n                && Is.string(candidate.message)\n                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n                && (Is.string(candidate.source) || Is.undefined(candidate.source))\n                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */\n    var Command;\n    (function (Command) {\n        /**\n         * Creates a new Command literal.\n         */\n        function create(title, command) {\n            var args = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                args[_i - 2] = arguments[_i];\n            }\n            var result = { title: title, command: command };\n            if (Is.defined(args) && args.length > 0) {\n                result.arguments = args;\n            }\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */\n    var TextEdit;\n    (function (TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */\n        function replace(range, newText) {\n            return { range: range, newText: newText };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */\n        function insert(position, newText) {\n            return { range: { start: position, end: position }, newText: newText };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */\n        function del(range) {\n            return { range: range, newText: '' };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && Is.string(candidate.newText)\n                && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function (ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = { label: label };\n            if (needsConfirmation !== undefined) {\n                result.needsConfirmation = needsConfirmation;\n            }\n            if (description !== undefined) {\n                result.description = description;\n            }\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function (ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function (AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */\n        function replace(range, newText, annotation) {\n            return { range: range, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */\n        function insert(position, newText, annotation) {\n            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */\n        function del(range, annotation) {\n            return { range: range, newText: '', annotationId: annotation };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */\n    var TextDocumentEdit;\n    (function (TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */\n        function create(textDocument, edits) {\n            return { textDocument: textDocument, edits: edits };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate)\n                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n                && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function (CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function (RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function (DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function (WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                    if (Is.string(change.kind)) {\n                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                    }\n                    else {\n                        return TextDocumentEdit.is(change);\n                    }\n                }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ (function () {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.insert(position, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.replace(range, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.delete = function (range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.del(range);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.add = function (edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function () {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function () {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n            if (value === undefined) {\n                throw new Error(\"Text edit change is not configured to manage change annotations.\");\n            }\n        };\n        return TextEditChangeImpl;\n    }());\n    /**\n     * A helper class\n     */\n    var ChangeAnnotations = /** @class */ (function () {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function () {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function () {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n                id = idOrAnnotation;\n            }\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) {\n                throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            }\n            if (annotation === undefined) {\n                throw new Error(\"No annotation provided for id \".concat(id));\n            }\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function () {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }());\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */\n    var WorkspaceChange = /** @class */ (function () {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function (change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                }\n                else if (workspaceEdit.changes) {\n                    Object.keys(workspaceEdit.changes).forEach(function (key) {\n                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                        _this._textEditChanges[key] = textEditChange;\n                    });\n                }\n            }\n            else {\n                this._workspaceEdit = {};\n            }\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */\n            get: function () {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) {\n                        this._workspaceEdit.changeAnnotations = undefined;\n                    }\n                    else {\n                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    }\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function (key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) {\n                    throw new Error('Workspace edit is not configured for document changes.');\n                }\n                var textDocument = { uri: key.uri, version: key.version };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            }\n            else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) {\n                    throw new Error('Workspace edit is not configured for normal text edit changes.');\n                }\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._workspaceEdit.changes = Object.create(null);\n            }\n        };\n        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = CreateFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = RenameFile.create(oldUri, newUri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = DeleteFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        return WorkspaceChange;\n    }());\n    exports.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */\n    var TextDocumentIdentifier;\n    (function (TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */\n        function create(uri) {\n            return { uri: uri };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */\n    var VersionedTextDocumentIdentifier;\n    (function (VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */\n    var OptionalVersionedTextDocumentIdentifier;\n    (function (OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */\n    var TextDocumentItem;\n    (function (TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */\n        function create(uri, languageId, version, text) {\n            return { uri: uri, languageId: languageId, version: version, text: text };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */\n    var MarkupKind;\n    (function (MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */\n        MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */\n        MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function (MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */\n    var CompletionItemKind;\n    (function (CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */\n    var InsertTextFormat;\n    (function (InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */\n        InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */\n        InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */\n    var CompletionItemTag;\n    (function (CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */\n        CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */\n    var InsertReplaceEdit;\n    (function (InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */\n        function create(newText, insert, replace) {\n            return { newText: newText, insert: insert, replace: replace };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */\n    var InsertTextMode;\n    (function (InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */\n        InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */\n        InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function (CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */\n    var CompletionItem;\n    (function (CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */\n        function create(label) {\n            return { label: label };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */\n    var CompletionList;\n    (function (CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */\n        function create(items, isIncomplete) {\n            return { items: items ? items : [], isIncomplete: !!isIncomplete };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function (MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */\n        function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports.MarkedString = MarkedString = {}));\n    var Hover;\n    (function (Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n                MarkedString.is(candidate.contents) ||\n                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */\n    var ParameterInformation;\n    (function (ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */\n        function create(label, documentation) {\n            return documentation ? { label: label, documentation: documentation } : { label: label };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */\n    var SignatureInformation;\n    (function (SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                parameters[_i - 2] = arguments[_i];\n            }\n            var result = { label: label };\n            if (Is.defined(documentation)) {\n                result.documentation = documentation;\n            }\n            if (Is.defined(parameters)) {\n                result.parameters = parameters;\n            }\n            else {\n                result.parameters = [];\n            }\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */\n    var DocumentHighlightKind;\n    (function (DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */\n        DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */\n        DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */\n        DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */\n    var DocumentHighlight;\n    (function (DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */\n        function create(range, kind) {\n            var result = { range: range };\n            if (Is.number(kind)) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */\n    var SymbolKind;\n    (function (SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */\n    var SymbolTag;\n    (function (SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */\n        SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function (SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */\n        function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: { uri: uri, range: range }\n            };\n            if (containerName) {\n                result.containerName = containerName;\n            }\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function (WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */\n        function create(name, kind, uri, range) {\n            return range !== undefined\n                ? { name: name, kind: kind, location: { uri: uri, range: range } }\n                : { name: name, kind: kind, location: { uri: uri } };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function (DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */\n        function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) {\n                result.children = children;\n            }\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                Is.string(candidate.name) && Is.number(candidate.kind) &&\n                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n                (candidate.detail === undefined || Is.string(candidate.detail)) &&\n                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n                (candidate.children === undefined || Array.isArray(candidate.children)) &&\n                (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */\n    var CodeActionKind;\n    (function (CodeActionKind) {\n        /**\n         * Empty kind.\n         */\n        CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */\n        CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */\n        CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */\n        CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */\n        CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */\n        CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */\n        CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */\n        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */\n        CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */\n    var CodeActionTriggerKind;\n    (function (CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */\n        CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */\n        CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */\n    var CodeActionContext;\n    (function (CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */\n        function create(diagnostics, only, triggerKind) {\n            var result = { diagnostics: diagnostics };\n            if (only !== undefined && only !== null) {\n                result.only = only;\n            }\n            if (triggerKind !== undefined && triggerKind !== null) {\n                result.triggerKind = triggerKind;\n            }\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function (CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = { title: title };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            }\n            else if (Command.is(kindOrCommandOrEdit)) {\n                result.command = kindOrCommandOrEdit;\n            }\n            else {\n                result.edit = kindOrCommandOrEdit;\n            }\n            if (checkKind && kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) &&\n                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n                (candidate.kind === undefined || Is.string(candidate.kind)) &&\n                (candidate.edit !== undefined || candidate.command !== undefined) &&\n                (candidate.command === undefined || Command.is(candidate.command)) &&\n                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */\n    var CodeLens;\n    (function (CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */\n        function create(range, data) {\n            var result = { range: range };\n            if (Is.defined(data)) {\n                result.data = data;\n            }\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */\n    var FormattingOptions;\n    (function (FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */\n        function create(tabSize, insertSpaces) {\n            return { tabSize: tabSize, insertSpaces: insertSpaces };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */\n    var DocumentLink;\n    (function (DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */\n        function create(range, target, data) {\n            return { range: range, target: target, data: data };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */\n    var SelectionRange;\n    (function (SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */\n        function create(range, parent) {\n            return { range: range, parent: parent };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenTypes;\n    (function (SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */\n        SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */\n        SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenModifiers;\n    (function (SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */\n    var SemanticTokens;\n    (function (SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueText;\n    (function (InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueVariableLookup;\n    (function (InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, variableName, caseSensitiveLookup) {\n            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n                && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueEvaluatableExpression;\n    (function (InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */\n        function create(range, expression) {\n            return { range: range, expression: expression };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n                && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueContext;\n    (function (InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */\n        function create(frameId, stoppedLocation) {\n            return { frameId: frameId, stoppedLocation: stoppedLocation };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */\n    var InlayHintKind;\n    (function (InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */\n        InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */\n        InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function (InlayHintLabelPart) {\n        function create(value) {\n            return { value: value };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.location === undefined || Location.is(candidate.location))\n                && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function (InlayHint) {\n        function create(position, label, kind) {\n            var result = { position: position, label: label };\n            if (kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position)\n                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function (StringValue) {\n        function createSnippet(value) {\n            return { kind: 'snippet', value: value };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function (InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return { insertText: insertText, filterText: filterText, range: range, command: command };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function (InlineCompletionList) {\n        function create(items) {\n            return { items: items };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */\n    var InlineCompletionTriggerKind;\n    (function (InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */\n        InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */\n        InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function (SelectedCompletionInfo) {\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function (InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function (WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));\n    exports.EOL = ['\\n', '\\r\\n', '\\r'];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for (var i = sortedEdits.length - 1; i >= 0; i--) {\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) {\n                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                }\n                else {\n                    throw new Error('Overlapping edit');\n                }\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) {\n                // sorted\n                return data;\n            }\n            var p = (data.length / 2) | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while (leftIdx < left.length && rightIdx < right.length) {\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) {\n                    // smaller_equal -> take left to preserve order\n                    data[i++] = left[leftIdx++];\n                }\n                else {\n                    // greater -> take right\n                    data[i++] = right[rightIdx++];\n                }\n            }\n            while (leftIdx < left.length) {\n                data[i++] = left[leftIdx++];\n            }\n            while (rightIdx < right.length) {\n                data[i++] = right[rightIdx++];\n            }\n            return data;\n        }\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for (var i = 0; i < text.length; i++) {\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = (ch === '\\r' || ch === '\\n');\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                        i++;\n                    }\n                }\n                if (isLineStart && text.length > 0) {\n                    lineOffsets.push(text.length);\n                }\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return Position.create(0, offset);\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }());\n    var Is;\n    (function (Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Line = void 0;\nclass Line {\n    constructor(document, range) {\n        this.document = document;\n        this.range = range;\n    }\n    getRange() {\n        return this.range;\n    }\n    getTextContent() {\n        return this.document.getText().substring(this.document.offsetAt(this.range.start), this.document.offsetAt(this.range.end));\n    }\n    isAfter(line) {\n        return this.range.start.line > line.range.start.line;\n    }\n    isBefore(line) {\n        return this.range.start.line < line;\n    }\n}\nexports.Line = Line;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    static isUTF8BOM(char) {\n        const uintArray = Uint8Array.from(Buffer.from(char, \"UTF-8\"));\n        return uintArray[0] === 0xEF && uintArray[1] == 0xBB && uintArray[2] == 0xBF;\n    }\n    static isWhitespace(char) {\n        return char === ' ' || char === '\\t' || Util.isNewline(char);\n    }\n    static isNewline(char) {\n        return char === '\\r' || char === '\\n';\n    }\n    static findLeadingNonWhitespace(content, escapeChar) {\n        whitespaceCheck: for (let i = 0; i < content.length; i++) {\n            switch (content.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    continue;\n                case escapeChar:\n                    escapeCheck: for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                // offset one more for \\r\\n\n                                i = j + 1;\n                                continue whitespaceCheck;\n                            case '\\n':\n                                i = j;\n                                continue whitespaceCheck;\n                            default:\n                                break escapeCheck;\n                        }\n                    }\n                    // found an escape character and then reached EOF\n                    return -1;\n                default:\n                    return i;\n            }\n        }\n        // only possible if the content is the empty string\n        return -1;\n    }\n    /**\n     * Determines if the given position is contained within the given range.\n     *\n     * @param position the position to check\n     * @param range the range to see if the position is inside of\n     */\n    static isInsideRange(position, range) {\n        if (range.start.line === range.end.line) {\n            return range.start.line === position.line\n                && range.start.character <= position.character\n                && position.character <= range.end.character;\n        }\n        else if (range.start.line === position.line) {\n            return range.start.character <= position.character;\n        }\n        else if (range.end.line === position.line) {\n            return position.character <= range.end.character;\n        }\n        return range.start.line < position.line && position.line < range.end.line;\n    }\n    static parseHeredocName(value) {\n        value = value.substring(2);\n        if (value.charAt(0) === '-') {\n            value = value.substring(1);\n        }\n        if (value.charAt(0) === '\"') {\n            if (value.charAt(value.length - 1) !== '\"') {\n                return null;\n            }\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === '\\'') {\n            if (value.charAt(value.length - 1) !== '\\'') {\n                return null;\n            }\n            value = value.substring(1, value.length - 1);\n        }\n        if (value.charAt(0) === \"<\") {\n            return null;\n        }\n        return value;\n    }\n}\nexports.Util = Util;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst vscode_languageserver_textdocument_1 = require(\"vscode-languageserver-textdocument\");\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst comment_1 = require(\"./comment\");\nconst parserDirective_1 = require(\"./parserDirective\");\nconst instruction_1 = require(\"./instruction\");\nconst add_1 = require(\"./instructions/add\");\nconst arg_1 = require(\"./instructions/arg\");\nconst cmd_1 = require(\"./instructions/cmd\");\nconst copy_1 = require(\"./instructions/copy\");\nconst env_1 = require(\"./instructions/env\");\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nconst from_1 = require(\"./instructions/from\");\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nconst label_1 = require(\"./instructions/label\");\nconst onbuild_1 = require(\"./instructions/onbuild\");\nconst run_1 = require(\"./instructions/run\");\nconst shell_1 = require(\"./instructions/shell\");\nconst stopsignal_1 = require(\"./instructions/stopsignal\");\nconst workdir_1 = require(\"./instructions/workdir\");\nconst user_1 = require(\"./instructions/user\");\nconst volume_1 = require(\"./instructions/volume\");\nconst dockerfile_1 = require(\"./dockerfile\");\nconst util_1 = require(\"./util\");\nconst main_1 = require(\"./main\");\nclass Parser {\n    constructor() {\n        this.escapeChar = null;\n    }\n    static createInstruction(document, dockerfile, escapeChar, lineRange, instruction, instructionRange) {\n        switch (instruction.toUpperCase()) {\n            case \"ADD\":\n                return new add_1.Add(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ARG\":\n                return new arg_1.Arg(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"CMD\":\n                return new cmd_1.Cmd(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"COPY\":\n                return new copy_1.Copy(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENTRYPOINT\":\n                return new entrypoint_1.Entrypoint(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ENV\":\n                return new env_1.Env(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"FROM\":\n                return new from_1.From(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"HEALTHCHECK\":\n                return new healthcheck_1.Healthcheck(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"LABEL\":\n                return new label_1.Label(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"ONBUILD\":\n                return new onbuild_1.Onbuild(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"RUN\":\n                return new run_1.Run(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"SHELL\":\n                return new shell_1.Shell(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"STOPSIGNAL\":\n                return new stopsignal_1.Stopsignal(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"WORKDIR\":\n                return new workdir_1.Workdir(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"USER\":\n                return new user_1.User(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n            case \"VOLUME\":\n                return new volume_1.Volume(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n        }\n        return new instruction_1.Instruction(document, lineRange, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getParserDirectives(document, buffer) {\n        // reset the escape directive in between runs\n        const directives = [];\n        this.escapeChar = '';\n        const offset = util_1.Util.isUTF8BOM(buffer.substring(0, 1)) ? 1 : 0;\n        directiveCheck: for (let i = offset; i < buffer.length; i++) {\n            switch (buffer.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\r':\n                case '\\n':\n                    // blank lines stop the parsing of directives immediately\n                    break directiveCheck;\n                case '#':\n                    let directiveStart = -1;\n                    let directiveEnd = -1;\n                    for (let j = i + 1; j < buffer.length; j++) {\n                        let char = buffer.charAt(j);\n                        switch (char) {\n                            case ' ':\n                            case '\\t':\n                                if (directiveStart !== -1 && directiveEnd === -1) {\n                                    directiveEnd = j;\n                                }\n                                break;\n                            case '\\r':\n                            case '\\n':\n                                break directiveCheck;\n                            case '=':\n                                let valueStart = -1;\n                                let valueEnd = -1;\n                                if (directiveEnd === -1) {\n                                    directiveEnd = j;\n                                }\n                                // assume the line ends with the file\n                                let lineEnd = buffer.length;\n                                directiveValue: for (let k = j + 1; k < buffer.length; k++) {\n                                    char = buffer.charAt(k);\n                                    switch (char) {\n                                        case '\\r':\n                                        case '\\n':\n                                            if (valueStart !== -1 && valueEnd === -1) {\n                                                valueEnd = k;\n                                            }\n                                            // line break found, reset\n                                            lineEnd = k;\n                                            break directiveValue;\n                                        case '\\t':\n                                        case ' ':\n                                            if (valueStart !== -1 && valueEnd === -1) {\n                                                valueEnd = k;\n                                            }\n                                            continue;\n                                        default:\n                                            if (valueStart === -1) {\n                                                valueStart = k;\n                                            }\n                                            break;\n                                    }\n                                }\n                                if (directiveStart === -1) {\n                                    // no directive, it's a regular comment\n                                    break directiveCheck;\n                                }\n                                if (valueStart === -1) {\n                                    // no non-whitespace characters found, highlight all the characters then\n                                    valueStart = j + 1;\n                                    valueEnd = lineEnd;\n                                }\n                                else if (valueEnd === -1) {\n                                    // reached EOF\n                                    valueEnd = buffer.length;\n                                }\n                                const lineRange = vscode_languageserver_types_1.Range.create(document.positionAt(i), document.positionAt(lineEnd));\n                                const nameRange = vscode_languageserver_types_1.Range.create(document.positionAt(directiveStart), document.positionAt(directiveEnd));\n                                const valueRange = vscode_languageserver_types_1.Range.create(document.positionAt(valueStart), document.positionAt(valueEnd));\n                                directives.push(new parserDirective_1.ParserDirective(document, lineRange, nameRange, valueRange));\n                                directiveStart = -1;\n                                if (buffer.charAt(valueEnd) === '\\r') {\n                                    // skip over the \\r\n                                    i = valueEnd + 1;\n                                }\n                                else {\n                                    i = valueEnd;\n                                }\n                                continue directiveCheck;\n                            default:\n                                if (directiveStart === -1) {\n                                    directiveStart = j;\n                                }\n                                break;\n                        }\n                    }\n                    break;\n                default:\n                    break directiveCheck;\n            }\n        }\n        return directives;\n    }\n    parse(buffer) {\n        this.document = vscode_languageserver_textdocument_1.TextDocument.create(\"\", \"\", 0, buffer);\n        this.buffer = buffer;\n        let dockerfile = new dockerfile_1.Dockerfile(this.document);\n        let directives = this.getParserDirectives(this.document, this.buffer);\n        let offset = 0;\n        this.escapeChar = '\\\\';\n        if (directives.length > 0) {\n            dockerfile.setDirectives(directives);\n            this.escapeChar = dockerfile.getEscapeCharacter();\n            // start parsing after the directives\n            offset = this.document.offsetAt(vscode_languageserver_types_1.Position.create(directives.length, 0));\n        }\n        else if (util_1.Util.isUTF8BOM(buffer.substring(0, 1))) {\n            offset = 1;\n        }\n        for (let i = offset; i < this.buffer.length; i++) {\n            const char = this.buffer.charAt(i);\n            switch (char) {\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '#':\n                    i = this.processComment(dockerfile, i);\n                    break;\n                default:\n                    i = this.processInstruction(dockerfile, char, i);\n                    break;\n            }\n        }\n        dockerfile.organizeComments();\n        return dockerfile;\n    }\n    processInstruction(dockerfile, char, start) {\n        let instruction = char;\n        let instructionEnd = -1;\n        let escapedInstruction = false;\n        instructionCheck: for (let i = start + 1; i < this.buffer.length; i++) {\n            char = this.buffer.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    escapedInstruction = true;\n                    char = this.buffer.charAt(i + 1);\n                    if (char === '\\r' || char === '\\n') {\n                        if (instructionEnd === -1) {\n                            instructionEnd = i;\n                        }\n                        i++;\n                    }\n                    else if (char === ' ' || char === '\\t') {\n                        for (let j = i + 2; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    i = j;\n                                    continue instructionCheck;\n                                default:\n                                    // found an argument, mark end of instruction\n                                    instructionEnd = i + 1;\n                                    instruction = instruction + this.escapeChar;\n                                    i = j - 2;\n                                    continue instructionCheck;\n                            }\n                        }\n                        // reached EOF\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        break instructionCheck;\n                    }\n                    else {\n                        instructionEnd = i + 1;\n                        instruction = instruction + this.escapeChar;\n                        // reset and consider it as one contiguous word\n                        escapedInstruction = false;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escapedInstruction) {\n                        // on an escaped newline, need to search for non-whitespace\n                        escapeCheck: for (let j = i + 1; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    i = j;\n                                    continue instructionCheck;\n                                default:\n                                    break escapeCheck;\n                            }\n                        }\n                        escapedInstruction = false;\n                    }\n                    if (instructionEnd === -1) {\n                        instructionEnd = i;\n                    }\n                    i = this.processArguments(dockerfile, instruction, instructionEnd, start, i);\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, i));\n                    return i;\n                case '\\r':\n                case '\\n':\n                    if (escapedInstruction) {\n                        continue;\n                    }\n                    if (instructionEnd === -1) {\n                        instructionEnd = i;\n                    }\n                    dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, i, i));\n                    return i;\n                case '#':\n                    if (escapedInstruction) {\n                        continue;\n                    }\n                default:\n                    instructionEnd = i + 1;\n                    instruction = instruction + char;\n                    escapedInstruction = false;\n                    break;\n            }\n        }\n        // reached EOF\n        if (instructionEnd === -1) {\n            instructionEnd = this.buffer.length;\n        }\n        dockerfile.addInstruction(this.createInstruction(dockerfile, instruction, start, instructionEnd, this.buffer.length));\n        return this.buffer.length;\n    }\n    processHeredocs(instruction, offset) {\n        let keyword = instruction.getKeyword();\n        if (keyword === main_1.Keyword.ONBUILD) {\n            instruction = instruction.getTriggerInstruction();\n            if (instruction === null) {\n                return offset;\n            }\n            keyword = instruction.getKeyword();\n        }\n        if (keyword !== main_1.Keyword.ADD && keyword !== main_1.Keyword.COPY && keyword !== main_1.Keyword.RUN) {\n            return offset;\n        }\n        const heredocs = [];\n        for (const arg of instruction.getArguments()) {\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && value.length > 2) {\n                const name = util_1.Util.parseHeredocName(value);\n                if (name !== null) {\n                    heredocs.push(name);\n                }\n            }\n        }\n        if (heredocs.length > 0) {\n            for (const heredoc of heredocs) {\n                offset = this.parseHeredoc(heredoc, offset);\n            }\n        }\n        return offset;\n    }\n    processArguments(dockerfile, instruction, instructionEnd, start, offset) {\n        let escaped = false;\n        argumentsCheck: for (let i = offset + 1; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case '\\r':\n                case '\\n':\n                    if (escaped) {\n                        continue;\n                    }\n                    return this.processHeredocs(this.createInstruction(dockerfile, instruction, start, instructionEnd, i), i);\n                case this.escapeChar:\n                    const next = this.buffer.charAt(i + 1);\n                    if (next === '\\n' || next === '\\r') {\n                        escaped = true;\n                        i++;\n                    }\n                    else if (next === ' ' || next === '\\t') {\n                        for (let j = i + 2; j < this.buffer.length; j++) {\n                            switch (this.buffer.charAt(j)) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    escaped = true;\n                                default:\n                                    i = j;\n                                    continue argumentsCheck;\n                            }\n                        }\n                        // reached EOF\n                        return this.buffer.length;\n                    }\n                    continue;\n                case '#':\n                    if (escaped) {\n                        i = this.processComment(dockerfile, i);\n                        continue argumentsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                default:\n                    if (escaped) {\n                        escaped = false;\n                    }\n                    break;\n            }\n        }\n        return this.buffer.length;\n    }\n    processComment(dockerfile, start) {\n        let end = this.buffer.length;\n        commentLoop: for (let i = start + 1; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case '\\r':\n                case '\\n':\n                    end = i;\n                    break commentLoop;\n            }\n        }\n        const range = vscode_languageserver_types_1.Range.create(this.document.positionAt(start), this.document.positionAt(end));\n        dockerfile.addComment(new comment_1.Comment(this.document, range));\n        return end;\n    }\n    parseHeredoc(heredocName, offset) {\n        let startWord = -1;\n        let lineStart = true;\n        for (let i = offset; i < this.buffer.length; i++) {\n            switch (this.buffer.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    lineStart = false;\n                    break;\n                case '\\r':\n                case '\\n':\n                    if (startWord !== -1 && heredocName === this.buffer.substring(startWord, i)) {\n                        return i;\n                    }\n                    startWord = -1;\n                    lineStart = true;\n                    break;\n                default:\n                    if (lineStart) {\n                        startWord = i;\n                        lineStart = false;\n                    }\n                    break;\n            }\n        }\n        return this.buffer.length;\n    }\n    createInstruction(dockerfile, instruction, start, instructionEnd, end) {\n        const startPosition = this.document.positionAt(start);\n        const instructionRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(instructionEnd));\n        const lineRange = vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(end));\n        return Parser.createInstruction(this.document, dockerfile, this.escapeChar, lineRange, instruction, instructionRange);\n    }\n}\nexports.Parser = Parser;\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = void 0;\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (changes, version) {\n            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n                var change = changes_1[_i];\n                if (FullTextDocument.isIncremental(change)) {\n                    // makes sure start is before end\n                    var range = getWellformedRange(change.range);\n                    // update content\n                    var startOffset = this.offsetAt(range.start);\n                    var endOffset = this.offsetAt(range.end);\n                    this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                    // update the offsets\n                    var startLine = Math.max(range.start.line, 0);\n                    var endLine = Math.max(range.end.line, 0);\n                    var lineOffsets = this._lineOffsets;\n                    var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                    if (endLine - startLine === addedLineOffsets.length) {\n                        for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                        }\n                    }\n                    else {\n                        if (addedLineOffsets.length < 10000) {\n                            lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));\n                        }\n                        else { // avoid too many arguments for splice\n                            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                        }\n                    }\n                    var diff = change.text.length - (endOffset - startOffset);\n                    if (diff !== 0) {\n                        for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                            lineOffsets[i] = lineOffsets[i] + diff;\n                        }\n                    }\n                }\n                else if (FullTextDocument.isFull(change)) {\n                    this._content = change.text;\n                    this._lineOffsets = undefined;\n                }\n                else {\n                    throw new Error('Unknown change event received');\n                }\n            }\n            this._version = version;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                this._lineOffsets = computeLineOffsets(this._content, true);\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return { line: 0, character: offset };\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n            return { line: line, character: offset - lineOffsets[line] };\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            if (position.character <= 0) {\n                return lineOffset;\n            }\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            var offset = Math.min(lineOffset + position.character, nextLineOffset);\n            return this.ensureBeforeEOL(offset, lineOffset);\n        };\n        FullTextDocument.prototype.ensureBeforeEOL = function (offset, lineOffset) {\n            while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n                offset--;\n            }\n            return offset;\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.isIncremental = function (event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null &&\n                typeof candidate.text === 'string' && candidate.range !== undefined &&\n                (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n        };\n        FullTextDocument.isFull = function (event) {\n            var candidate = event;\n            return candidate !== undefined && candidate !== null &&\n                typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n        };\n        return FullTextDocument;\n    }());\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new text document.\n         *\n         * @param uri The document's uri.\n         * @param languageId  The document's language Id.\n         * @param version The document's initial version number.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Updates a TextDocument by modifying its content.\n         *\n         * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n         * @param changes the changes to apply to the document.\n         * @param version the changes version for the document.\n         * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n         *\n         */\n        function update(document, changes, version) {\n            if (document instanceof FullTextDocument) {\n                document.update(changes, version);\n                return document;\n            }\n            else {\n                throw new Error('TextDocument.update: document must be created by TextDocument.create');\n            }\n        }\n        TextDocument.update = update;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = 0;\n            var spans = [];\n            for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n                var e = sortedEdits_1[_i];\n                var startOffset = document.offsetAt(e.range.start);\n                if (startOffset < lastModifiedOffset) {\n                    throw new Error('Overlapping edit');\n                }\n                else if (startOffset > lastModifiedOffset) {\n                    spans.push(text.substring(lastModifiedOffset, startOffset));\n                }\n                if (e.newText.length) {\n                    spans.push(e.newText);\n                }\n                lastModifiedOffset = document.offsetAt(e.range.end);\n            }\n            spans.push(text.substr(lastModifiedOffset));\n            return spans.join('');\n        }\n        TextDocument.applyEdits = applyEdits;\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n    function computeLineOffsets(text, isAtLineStart, textOffset) {\n        if (textOffset === void 0) { textOffset = 0; }\n        var result = isAtLineStart ? [textOffset] : [];\n        for (var i = 0; i < text.length; i++) {\n            var ch = text.charCodeAt(i);\n            if (isEOL(ch)) {\n                if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                    i++;\n                }\n                result.push(textOffset + i + 1);\n            }\n        }\n        return result;\n    }\n    function isEOL(char) {\n        return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n    }\n    function getWellformedRange(range) {\n        var start = range.start;\n        var end = range.end;\n        if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n            return { start: end, end: start };\n        }\n        return range;\n    }\n    function getWellformedEdit(textEdit) {\n        var range = getWellformedRange(textEdit.range);\n        if (range !== textEdit.range) {\n            return { newText: textEdit.newText, range: range };\n        }\n        return textEdit;\n    }\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserDirective = void 0;\nconst main_1 = require(\"./main\");\nconst line_1 = require(\"./line\");\nclass ParserDirective extends line_1.Line {\n    constructor(document, range, nameRange, valueRange) {\n        super(document, range);\n        this.nameRange = nameRange;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        return \"# \" + this.getName() + '=' + this.getValue();\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    getName() {\n        return this.document.getText().substring(this.document.offsetAt(this.nameRange.start), this.document.offsetAt(this.nameRange.end));\n    }\n    getValue() {\n        return this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n    }\n    getDirective() {\n        const directive = main_1.Directive[this.getName().toLowerCase()];\n        return directive === undefined ? null : directive;\n    }\n}\nexports.ParserDirective = ParserDirective;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Instruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst util_1 = require(\"./util\");\nconst line_1 = require(\"./line\");\nconst argument_1 = require(\"./argument\");\nconst heredoc_1 = require(\"./heredoc\");\nconst variable_1 = require(\"./variable\");\nconst main_1 = require(\"./main\");\nclass Instruction extends line_1.Line {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range);\n        this.dockerfile = dockerfile;\n        this.escapeChar = escapeChar;\n        this.instruction = instruction;\n        this.instructionRange = instructionRange;\n    }\n    toString() {\n        let value = this.getKeyword();\n        for (let arg of this.getRawArguments()) {\n            value += ' ';\n            value += arg.getValue();\n        }\n        return value;\n    }\n    getRangeContent(range) {\n        if (range === null) {\n            return null;\n        }\n        return this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n    }\n    getInstructionRange() {\n        return this.instructionRange;\n    }\n    getInstruction() {\n        return this.instruction;\n    }\n    getKeyword() {\n        return this.getInstruction().toUpperCase();\n    }\n    getArgumentsRange() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        return vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end);\n    }\n    getArgumentsRanges() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return [];\n        }\n        if (args[0].getRange().start.line === args[args.length - 1].getRange().end.line) {\n            return [vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end)];\n        }\n        let ranges = [];\n        let end = -1;\n        let startPosition = args[0].getRange().start;\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(startPosition) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra, this.document.offsetAt(args[args.length - 1].getRange().end) - this.document.offsetAt(range.start));\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        for (let i = 0; i < fullArgs.length; i++) {\n            let char = fullArgs.charAt(i);\n            if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') {\n                    whitespaceCheck: for (let j = i + 2; j < fullArgs.length; j++) {\n                        switch (fullArgs.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                if (startPosition !== null) {\n                                    ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                                }\n                                startPosition = null;\n                                start = true;\n                                comment = false;\n                                i = j;\n                                break whitespaceCheck;\n                            default:\n                                break whitespaceCheck;\n                        }\n                    }\n                }\n                else if (next === '\\r') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                        startPosition = null;\n                    }\n                    start = true;\n                    comment = false;\n                    i += 2;\n                }\n                else if (next === '\\n') {\n                    if (startPosition !== null) {\n                        ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n                    }\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                    i++;\n                }\n                else {\n                    i++;\n                }\n            }\n            else if (util_1.Util.isNewline(char)) {\n                if (comment) {\n                    startPosition = null;\n                    start = true;\n                    comment = false;\n                }\n            }\n            else {\n                if (!comment) {\n                    if (startPosition === null) {\n                        if (char === '#') {\n                            comment = true;\n                            continue;\n                        }\n                        let position = this.document.positionAt(offset + i);\n                        if (position.character !== 0) {\n                            startPosition = vscode_languageserver_types_1.Position.create(position.line, 0);\n                        }\n                    }\n                    end = i;\n                }\n            }\n        }\n        if (startPosition === null) {\n            // should only happen if the last argument is on its own line with\n            // no leading whitespace\n            ranges.push(vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + end), this.document.positionAt(offset + end + 1)));\n        }\n        else {\n            ranges.push(vscode_languageserver_types_1.Range.create(startPosition, this.document.positionAt(offset + end + 1)));\n        }\n        return ranges;\n    }\n    getRawArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        return this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, args[args.length - 1].getRange().end));\n    }\n    getArgumentsContent() {\n        let args = this.getArguments();\n        if (args.length === 0) {\n            return null;\n        }\n        let content = \"\";\n        let ranges = this.getArgumentsRanges();\n        let documentText = this.document.getText();\n        for (let range of ranges) {\n            content += documentText.substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n        }\n        return content;\n    }\n    getArguments() {\n        return this.getRawArguments();\n    }\n    getRawArguments() {\n        let args = [];\n        let range = this.getInstructionRange();\n        let extra = this.document.offsetAt(range.end) - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let offset = this.document.offsetAt(range.start) + extra;\n        let start = false;\n        let comment = false;\n        let found = -1;\n        // determines whether the parser has found a space or tab\n        // whitespace character that's a part of an escaped newline sequence\n        let escapedWhitespaceDetected = false;\n        // determines if the parser is currently in an escaped newline sequence\n        let escaping = false;\n        let escapeMarker = -1;\n        let escapedArg = \"\";\n        for (let i = 0; i < fullArgs.length; i++) {\n            let char = fullArgs.charAt(i);\n            if (util_1.Util.isWhitespace(char)) {\n                if (escaping) {\n                    escapedWhitespaceDetected = true;\n                    if (util_1.Util.isNewline(char)) {\n                        // reached a newline, any previously\n                        // detected whitespace should be ignored\n                        escapedWhitespaceDetected = false;\n                        if (comment) {\n                            // reached a newline, no longer in a comment\n                            comment = false;\n                            start = true;\n                        }\n                    }\n                    continue;\n                }\n                else if (found !== -1) {\n                    if (escapeMarker === -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + i))));\n                    }\n                    else {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                    }\n                    escapeMarker = -1;\n                    escapedArg = \"\";\n                    found = -1;\n                }\n            }\n            else if (char === this.escapeChar) {\n                let next = fullArgs.charAt(i + 1);\n                if (next === ' ' || next === '\\t') {\n                    whitespaceCheck: for (let j = i + 2; j < fullArgs.length; j++) {\n                        let newlineCheck = fullArgs.charAt(j);\n                        switch (newlineCheck) {\n                            case ' ':\n                            case '\\t':\n                                continue;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                comment = false;\n                                escaping = true;\n                                start = true;\n                                if (found !== -1) {\n                                    escapeMarker = i;\n                                }\n                                i = j;\n                                break whitespaceCheck;\n                            default:\n                                escapeMarker = i;\n                                if (found === -1) {\n                                    i = j - 1;\n                                }\n                                break whitespaceCheck;\n                        }\n                    }\n                }\n                else if (next === '\\r') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) {\n                        escapeMarker = i;\n                    }\n                    i += 2;\n                }\n                else if (next === '\\n') {\n                    comment = false;\n                    escaping = true;\n                    start = true;\n                    if (found !== -1 && escapeMarker === -1) {\n                        escapeMarker = i;\n                    }\n                    i++;\n                }\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapeMarker = -1;\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    if (next === '$') {\n                        escapedArg = escapedArg + char + next;\n                    }\n                    else if (next === '') {\n                        // reached EOF, stop processing\n                        break;\n                    }\n                    else {\n                        escapedArg = escapedArg + next;\n                    }\n                    if (found === -1) {\n                        found = i;\n                    }\n                    i++;\n                }\n            }\n            else if (!comment) {\n                if (start && char === '#') {\n                    comment = true;\n                }\n                else {\n                    if (escapedWhitespaceDetected && escapeMarker !== -1) {\n                        args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n                        escapedArg = \"\";\n                        found = -1;\n                    }\n                    escapedWhitespaceDetected = false;\n                    escaping = false;\n                    escapeMarker = -1;\n                    escapedArg = escapedArg + char;\n                    if (found === -1) {\n                        found = i;\n                    }\n                }\n                // non-whitespace character detected, reset\n                start = false;\n            }\n        }\n        if (found !== -1) {\n            if (escapeMarker === -1) {\n                args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + fullArgs.length))));\n            }\n            else {\n                args.push(new argument_1.Argument(escapedArg, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + found), this.document.positionAt(offset + escapeMarker))));\n            }\n        }\n        return args;\n    }\n    getExpandedArguments() {\n        let args = this.getArguments();\n        for (let i = 0; i < args.length; i++) {\n            const argRange = args[i].getRange();\n            let offset = this.document.offsetAt(argRange.start);\n            const variables = this.parseVariables(offset, args[i].getValue());\n            const swaps = [];\n            let requiresExpansion = false;\n            for (let variable of variables) {\n                const value = this.dockerfile.resolveVariable(variable.getName(), variable.getNameRange().start.line);\n                swaps.push(value);\n                requiresExpansion = requiresExpansion || value !== undefined;\n            }\n            if (requiresExpansion) {\n                let expanded = \"\";\n                for (let j = 0; j < swaps.length; j++) {\n                    const variableRange = variables[j].getRange();\n                    const start = this.document.offsetAt(variableRange.start);\n                    const end = this.document.offsetAt(variableRange.end);\n                    if (swaps[j]) {\n                        // replace variable with its resolved value\n                        expanded += this.document.getText().substring(offset, start);\n                        expanded += swaps[j];\n                        offset = end;\n                    }\n                    else {\n                        expanded += this.document.getText().substring(offset, end);\n                        offset = end;\n                    }\n                }\n                const argEnd = this.document.offsetAt(argRange.end);\n                if (argEnd !== offset) {\n                    // if the variable's range doesn't match the argument,\n                    // append the remaining text\n                    expanded += this.document.getText().substring(offset, argEnd);\n                }\n                args[i] = new argument_1.Argument(expanded, argRange);\n            }\n        }\n        return args;\n    }\n    getVariables() {\n        const variables = [];\n        const args = this.getRawArguments();\n        for (const arg of args) {\n            let range = arg.getRange();\n            let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n            const parsedVariables = this.parseVariables(this.document.offsetAt(arg.getRange().start), rawValue);\n            for (const parsedVariable of parsedVariables) {\n                variables.push(parsedVariable);\n            }\n        }\n        return variables;\n    }\n    parseVariables(offset, arg) {\n        let variables = [];\n        variableLoop: for (let i = 0; i < arg.length; i++) {\n            switch (arg.charAt(i)) {\n                case this.escapeChar:\n                    if (arg.charAt(i + 1) === '$') {\n                        i++;\n                    }\n                    break;\n                case '$':\n                    if (arg.charAt(i + 1) === '{') {\n                        let escapedString = \"${\";\n                        let escapedName = \"\";\n                        let nameEnd = -1;\n                        let escapedSubstitutionParameter = \"\";\n                        let substitutionStart = -1;\n                        let substitutionEnd = -1;\n                        let modifierRead = -1;\n                        nameLoop: for (let j = i + 2; j < arg.length; j++) {\n                            let char = arg.charAt(j);\n                            switch (char) {\n                                case this.escapeChar:\n                                    for (let k = j + 1; k < arg.length; k++) {\n                                        switch (arg.charAt(k)) {\n                                            case ' ':\n                                            case '\\t':\n                                            case '\\r':\n                                                // ignore whitespace\n                                                continue;\n                                            case '\\n':\n                                                // escape this newline\n                                                j = k;\n                                                continue nameLoop;\n                                        }\n                                    }\n                                    break;\n                                case '}':\n                                    escapedString += '}';\n                                    let modifier = null;\n                                    let modifierRange = null;\n                                    let substitutionParameter = modifierRead !== -1 ? escapedSubstitutionParameter : null;\n                                    let substitutionRange = null;\n                                    if (nameEnd === -1) {\n                                        nameEnd = j;\n                                    }\n                                    else if (nameEnd + 1 === j) {\n                                        modifier = \"\";\n                                        modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + nameEnd + 1), this.document.positionAt(offset + nameEnd + 1));\n                                    }\n                                    else {\n                                        if (substitutionStart === -1) {\n                                            // no substitution parameter found,\n                                            // but a modifier character existed,\n                                            // just offset the range by 1 from\n                                            // the modifier character\n                                            substitutionStart = modifierRead + 1;\n                                            substitutionEnd = modifierRead + 1;\n                                        }\n                                        else {\n                                            // offset one more from the last\n                                            // character found\n                                            substitutionEnd = substitutionEnd + 1;\n                                        }\n                                        modifier = arg.substring(modifierRead, modifierRead + 1);\n                                        modifierRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + modifierRead), this.document.positionAt(offset + modifierRead + 1));\n                                        substitutionRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + substitutionStart), this.document.positionAt(offset + substitutionEnd));\n                                    }\n                                    let start = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 2), this.document.positionAt(offset + nameEnd)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j + 1)), modifier, modifierRange, substitutionParameter, substitutionRange, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), escapedString));\n                                    i = j;\n                                    continue variableLoop;\n                                case ':':\n                                    if (nameEnd === -1) {\n                                        nameEnd = j;\n                                    }\n                                    else if (modifierRead !== -1) {\n                                        if (substitutionStart === -1) {\n                                            substitutionStart = j;\n                                            substitutionEnd = j;\n                                        }\n                                        else {\n                                            substitutionEnd = j;\n                                        }\n                                        escapedSubstitutionParameter += ':';\n                                    }\n                                    else {\n                                        modifierRead = j;\n                                    }\n                                    escapedString += ':';\n                                    break;\n                                case '\\n':\n                                case '\\r':\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    if (nameEnd === -1) {\n                                        escapedName += char;\n                                    }\n                                    else if (modifierRead !== -1) {\n                                        if (substitutionStart === -1) {\n                                            substitutionStart = j;\n                                            substitutionEnd = j;\n                                        }\n                                        else {\n                                            substitutionEnd = j;\n                                        }\n                                        escapedSubstitutionParameter += char;\n                                    }\n                                    else {\n                                        modifierRead = j;\n                                    }\n                                    escapedString += char;\n                                    break;\n                            }\n                        }\n                        // no } found, not a valid variable, stop processing\n                        break variableLoop;\n                    }\n                    else if (util_1.Util.isWhitespace(arg.charAt(i + 1)) || i === arg.length - 1) {\n                        // $ followed by whitespace or EOF, ignore this variable\n                        continue;\n                    }\n                    else {\n                        let escapedName = \"\";\n                        nameLoop: for (let j = i + 1; j < arg.length; j++) {\n                            let char = arg.charAt(j);\n                            switch (char) {\n                                case '\\r':\n                                case '\\n':\n                                case ' ':\n                                case '\\t':\n                                    continue;\n                                case '$':\n                                case '\\'':\n                                case '\"':\n                                    let varStart = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                    i = j - 1;\n                                    continue variableLoop;\n                                case this.escapeChar:\n                                    for (let k = j + 1; k < arg.length; k++) {\n                                        switch (arg.charAt(k)) {\n                                            case ' ':\n                                            case '\\t':\n                                            case '\\r':\n                                                // ignore whitespace\n                                                continue;\n                                            case '\\n':\n                                                // escape this newline\n                                                j = k;\n                                                continue nameLoop;\n                                        }\n                                    }\n                                    // reached EOF after an escape character\n                                    let start = this.document.positionAt(offset + i);\n                                    variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                                    break variableLoop;\n                            }\n                            if (char.match(/^[a-z0-9_]+$/i) === null) {\n                                let varStart = this.document.positionAt(offset + i);\n                                variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + j)), vscode_languageserver_types_1.Range.create(varStart, this.document.positionAt(offset + j)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, varStart.line) !== undefined, this.isBuildVariable(escapedName, varStart.line), '$' + escapedName));\n                                i = j - 1;\n                                continue variableLoop;\n                            }\n                            escapedName += char;\n                        }\n                        let start = this.document.positionAt(offset + i);\n                        variables.push(new variable_1.Variable(escapedName, vscode_languageserver_types_1.Range.create(this.document.positionAt(offset + i + 1), this.document.positionAt(offset + arg.length)), vscode_languageserver_types_1.Range.create(start, this.document.positionAt(offset + arg.length)), null, null, null, null, this.dockerfile.resolveVariable(escapedName, start.line) !== undefined, this.isBuildVariable(escapedName, start.line), '$' + escapedName));\n                    }\n                    break variableLoop;\n            }\n        }\n        return variables;\n    }\n    isBuildVariable(variable, line) {\n        if (this.getKeyword() === main_1.Keyword.FROM) {\n            for (const initialArg of this.dockerfile.getInitialARGs()) {\n                const arg = initialArg;\n                const property = arg.getProperty();\n                if (property && variable === property.getName()) {\n                    return true;\n                }\n            }\n            return undefined;\n        }\n        let image = this.dockerfile.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        let envs = image.getENVs();\n        for (let i = envs.length - 1; i >= 0; i--) {\n            if (envs[i].isBefore(line)) {\n                for (let property of envs[i].getProperties()) {\n                    if (property.getName() === variable) {\n                        return false;\n                    }\n                }\n            }\n        }\n        let args = image.getARGs();\n        for (let i = args.length - 1; i >= 0; i--) {\n            if (args[i].isBefore(line)) {\n                let property = args[i].getProperty();\n                if (property && property.getName() === variable) {\n                    return true;\n                }\n            }\n        }\n        return undefined;\n    }\n    createSingleLineHeredocs(args) {\n        const heredocs = [];\n        // instruction only on one line, if heredocs exist they would be incomplete\n        for (const arg of args) {\n            const value = arg.getValue();\n            if (value.startsWith(\"<<\") && util_1.Util.parseHeredocName(value) !== null) {\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n            }\n        }\n        return heredocs;\n    }\n    getName(nameRange) {\n        const content = this.document.getText(nameRange);\n        let escaping = false;\n        let name = \"\";\n        nameLoop: for (let i = 0; i < content.length; i++) {\n            const ch = content.charAt(i);\n            switch (ch) {\n                case this.escapeChar:\n                    escaping = true;\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                i = j + 1;\n                                continue nameLoop;\n                            case '\\n':\n                                i = j;\n                                continue nameLoop;\n                            default:\n                                name += content.charAt(j);\n                                i = j;\n                                continue nameLoop;\n                        }\n                    }\n                    break;\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue nameLoop;\n                            }\n                        }\n                    }\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    if (escaping) {\n                        break;\n                    }\n                default:\n                    name += ch;\n                    break;\n            }\n        }\n        return name;\n    }\n    getNameRange(startRange) {\n        const content = this.document.getText(startRange);\n        let endFound = false;\n        let searchHyphen = false;\n        let start = -1;\n        let end = -1;\n        let escaping = false;\n        let quote = null;\n        contentLoop: for (let i = 0; i < content.length; i++) {\n            const ch = content.charAt(i);\n            switch (ch) {\n                case '\"':\n                case '\\'':\n                    if (quote === ch) {\n                        break contentLoop;\n                    }\n                    quote = ch;\n                    continue;\n                case this.escapeChar:\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case '\\n':\n                                escaping = true;\n                                j = i;\n                                continue contentLoop;\n                        }\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    break;\n                case '<':\n                    if (endFound) {\n                        searchHyphen = true;\n                    }\n                    else {\n                        endFound = true;\n                    }\n                    break;\n                case '-':\n                    if (searchHyphen) {\n                        searchHyphen = false;\n                        break;\n                    }\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue contentLoop;\n                            }\n                        }\n                    }\n                default:\n                    if (start === -1) {\n                        start = i;\n                    }\n                    if (quote !== null) {\n                        end = i + 1;\n                        break;\n                    }\n                    break contentLoop;\n            }\n        }\n        if (start === -1) {\n            return vscode_languageserver_types_1.Range.create(startRange.end, startRange.end);\n        }\n        const nameStart = this.document.positionAt(this.document.offsetAt(startRange.start) + start);\n        const nameEnd = quote !== null ? this.document.positionAt(this.document.offsetAt(startRange.start) + end) : startRange.end;\n        return vscode_languageserver_types_1.Range.create(nameStart, nameEnd);\n    }\n    getHeredocs() {\n        const args = this.getArguments();\n        if (args.length === 0) {\n            return [];\n        }\n        const heredocs = [];\n        const range = this.getRange();\n        if (range.start.line === range.end.line) {\n            // instruction only on one line, if heredocs exist they would be incomplete\n            return this.createSingleLineHeredocs(args);\n        }\n        const heredocDefinitions = [];\n        let heredocsProcessed = false;\n        let escaping = false;\n        let contentStart = -1;\n        let contentEnd = -1;\n        let lineStart = -1;\n        let currentHeredoc = 0;\n        const startOffset = this.document.offsetAt(args[0].getRange().start);\n        const content = this.getRangeContent(vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end));\n        contentLoop: for (let i = 0; i < content.length; i++) {\n            switch (content.charAt(i)) {\n                case this.escapeChar:\n                    escaping = true;\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                                break;\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                i = j;\n                                continue contentLoop;\n                            default:\n                                i = j;\n                                continue contentLoop;\n                        }\n                    }\n                    break;\n                case '\\r':\n                    break;\n                case '\\n':\n                    if (escaping) {\n                        break;\n                    }\n                    if (heredocsProcessed) {\n                        if (contentStart === -1) {\n                            contentStart = i;\n                        }\n                        contentEnd = i;\n                        const arg = heredocDefinitions[currentHeredoc];\n                        const startRange = arg.getRange();\n                        const nameRange = this.getNameRange(startRange);\n                        const name = this.getName(nameRange);\n                        const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), this.document.positionAt(startOffset + i)));\n                        if (delimiterRange !== null) {\n                            const contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + lineStart - 1));\n                            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n                            contentStart = -1;\n                            currentHeredoc++;\n                        }\n                        lineStart = -1;\n                    }\n                    else {\n                        // found a newline that hasn't been escaped,\n                        // must be in a heredoc\n                        const offsetLimit = startOffset + i;\n                        for (const arg of args) {\n                            // check if this argument is on the initial line of the instruction,\n                            // note that it may not all be on the same line due to escaped newlines,\n                            // because of that we need to use offset checks instead of line checks\n                            // as an argument being on a different line in the document does not\n                            // imply it is on a different line from the Dockerfile's point of view\n                            if (this.document.offsetAt(arg.getRange().start) < offsetLimit) {\n                                if (arg.getValue().startsWith(\"<<\")) {\n                                    heredocDefinitions.push(arg);\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        heredocsProcessed = true;\n                        lineStart = -1;\n                        continue contentLoop;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaping) {\n                        break;\n                    }\n                case '#':\n                    if (escaping) {\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\n':\n                                    i = j;\n                                    continue contentLoop;\n                            }\n                        }\n                    }\n                default:\n                    if (escaping) {\n                        escaping = false;\n                    }\n                    if (heredocsProcessed) {\n                        if (contentStart === -1) {\n                            contentStart = i;\n                        }\n                        if (lineStart === -1) {\n                            lineStart = i;\n                        }\n                    }\n                    break;\n            }\n        }\n        if (heredocsProcessed) {\n            const arg = heredocDefinitions[currentHeredoc];\n            const startRange = arg.getRange();\n            const nameRange = this.getNameRange(startRange);\n            const name = this.getName(nameRange);\n            let contentRange = null;\n            // check if the last line of this instruction matches the name of the last heredoc\n            const delimiterRange = this.getDelimiterRange(arg, name, vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + lineStart), range.end));\n            if (delimiterRange === null) {\n                contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), range.end);\n            }\n            else if (contentEnd !== -1) {\n                contentRange = vscode_languageserver_types_1.Range.create(this.document.positionAt(startOffset + contentStart), this.document.positionAt(startOffset + contentEnd));\n            }\n            heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, contentRange, delimiterRange));\n            currentHeredoc++;\n            for (let i = currentHeredoc; i < heredocDefinitions.length; i++) {\n                const arg = heredocDefinitions[currentHeredoc];\n                const startRange = arg.getRange();\n                const nameRange = this.getNameRange(startRange);\n                const name = this.getName(nameRange);\n                heredocs.push(new heredoc_1.Heredoc(startRange, name, nameRange, null, null));\n                currentHeredoc++;\n            }\n        }\n        else {\n            // instruction only on one line, if heredocs exist they would be incomplete\n            return this.createSingleLineHeredocs(args);\n        }\n        return heredocs;\n    }\n    getDelimiterRange(startArg, name, candidateRange) {\n        const text = this.document.getText(candidateRange);\n        if (startArg.getValue().startsWith(\"<<-\")) {\n            // remove tabs in the front\n            let index = 0;\n            while (text.charAt(index) === '\\t') {\n                index++;\n            }\n            if (text.substring(index) === name) {\n                return vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(candidateRange.start.line, index), candidateRange.end);\n            }\n            return null;\n        }\n        return text === name ? candidateRange : null;\n    }\n}\nexports.Instruction = Instruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Heredoc = void 0;\n/**\n * Heredoc represents a here-document that has been embedded in a\n * Dockerfile.\n *\n * This API is experimental and subject to change.\n */\nclass Heredoc {\n    constructor(startRange, name, nameRange, contentRange, endRange) {\n        this.startRange = startRange;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.contentRange = contentRange;\n        this.endRange = endRange;\n    }\n    /**\n     * Returns the name of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */\n    getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range of the start operator and the name. If the\n     * here-document is initialized with <<EOT then the start range would\n     * encompass all five characters.\n     *\n     * This API is experimental and subject to change.\n     */\n    getStartRange() {\n        return this.startRange;\n    }\n    /**\n     * Returns the range of this here-document's name that is declared at\n     * the beginning of the here-document with the operator. If the\n     * here-document is initialized with <<EOT then the name range would\n     * encompass the latter three \"EOT\" characters.\n     *\n     * This API is experimental and subject to change.\n     */\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the content of this here-document. This may\n     * be null if the here-document has no content because:\n     * - the start range is the only thing that was declared\n     * - the end range was declared immediately and there is no content\n     *\n     * This API is experimental and subject to change.\n     */\n    getContentRange() {\n        return this.contentRange;\n    }\n    /**\n     * Returns the range of the here-document's name on a line that\n     * represents the end of the here-document.\n     *\n     * This API is experimental and subject to change.\n     */\n    getDelimiterRange() {\n        return this.endRange;\n    }\n}\nexports.Heredoc = Heredoc;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\nclass Variable {\n    constructor(name, nameRange, range, modifier, modifierRange, substitutionParameter, substitutionRange, defined, buildVariable, stringValue) {\n        this.name = name;\n        this.nameRange = nameRange;\n        this.range = range;\n        this.modifier = modifier;\n        this.modifierRange = modifierRange;\n        this.substitutionParameter = substitutionParameter;\n        this.substitutionRange = substitutionRange;\n        this.defined = defined;\n        this.buildVariable = buildVariable;\n        this.stringValue = stringValue;\n    }\n    toString() {\n        return this.stringValue;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the range of the entire variable. This includes the symbols for\n     * the declaration of the variable such as the $, {, and } symbols.\n     *\n     * @return the range in the document that this variable encompasses in its\n     *         entirety\n     */\n    getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the modifier character that has been set for\n     * specifying how this variable should be expanded and resolved.\n     * If this variable is ${variable:+value} then the modifier\n     * character is '+'. Will be the empty string if the variable is\n     * declared as ${variable:}. Otherwise, will be null if this\n     * variable will not use variable substitution at all (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's modifier character, or the empty\n     *         string if it does not have one, or null if this\n     *         variable will not use variable substitution\n     */\n    getModifier() {\n        return this.modifier;\n    }\n    getModifierRange() {\n        return this.modifierRange;\n    }\n    /**\n     * Returns the parameter that will be used for substitution if\n     * this variable uses modifiers to define how its value should be\n     * resolved. If this variable is ${variable:+value} then the\n     * substitution value will be 'value'. Will be the empty string\n     * if the variable is declared as ${variable:+} or some other\n     * variant where the only thing that follows the modifier\n     * character (excluding considerations of escape characters and\n     * so on) is the variable's closing bracket. May be null if this\n     * variable does not have a modifier character defined (such as\n     * ${variable} or $variable).\n     *\n     * @return this variable's substitution parameter, or the empty\n     *         string if it does not have one, or null if there is\n     *         not one defined\n     */\n    getSubstitutionParameter() {\n        return this.substitutionParameter;\n    }\n    getSubstitutionRange() {\n        return this.substitutionRange;\n    }\n    /**\n     * Returns whether this variable has been defined or not.\n     *\n     * @return true if this variable has been defined, false otherwise\n     */\n    isDefined() {\n        return this.defined;\n    }\n    isBuildVariable() {\n        return this.buildVariable === true;\n    }\n    isEnvironmentVariable() {\n        return this.buildVariable === false;\n    }\n}\nexports.Variable = Variable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Add = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Add extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n}\nexports.Add = Add;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst argument_1 = require(\"./argument\");\nconst jsonArgument_1 = require(\"./jsonArgument\");\nconst modifiableInstruction_1 = require(\"./modifiableInstruction\");\nclass JSONInstruction extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.openingBracket = null;\n        this.closingBracket = null;\n        this.jsonStrings = [];\n        const argsContent = this.getRawArgumentsContent();\n        if (argsContent === null) {\n            return;\n        }\n        const args = this.getArguments();\n        if (args.length === 1 && args[0].getValue() === \"[]\") {\n            let argRange = args[0].getRange();\n            this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character, argRange.start.line, argRange.start.character + 1));\n            this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(argRange.start.line, argRange.start.character + 1, argRange.end.line, argRange.end.character));\n            return;\n        }\n        else if (args.length === 2 && args[0].getValue() === '[' && args[1].getValue() === ']') {\n            this.openingBracket = args[0];\n            this.closingBracket = args[1];\n            return;\n        }\n        const argsOffset = document.offsetAt(this.getArgumentsRange().start);\n        let start = -1;\n        let last = \"\";\n        let quoted = false;\n        let escapedArg = \"\";\n        argsCheck: for (let i = 0; i < argsContent.length; i++) {\n            let char = argsContent.charAt(i);\n            switch (char) {\n                case '[':\n                    if (last === \"\") {\n                        this.openingBracket = new argument_1.Argument(\"[\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        last = '[';\n                    }\n                    else if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else {\n                        break argsCheck;\n                    }\n                    break;\n                case '\"':\n                    if (last === '[' || last === ',') {\n                        start = i;\n                        quoted = true;\n                        last = '\"';\n                        escapedArg = escapedArg + char;\n                        continue;\n                    }\n                    else if (last === '\"') {\n                        if (quoted) {\n                            escapedArg = escapedArg + char;\n                            // quoted string done\n                            quoted = false;\n                            this.jsonStrings.push(new jsonArgument_1.JSONArgument(escapedArg, vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start), document.positionAt(argsOffset + i + 1)), vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + start + 1), document.positionAt(argsOffset + i))));\n                            escapedArg = \"\";\n                        }\n                        else {\n                            // should be a , or a ]\n                            break argsCheck;\n                        }\n                    }\n                    else {\n                        break argsCheck;\n                    }\n                    break;\n                case ',':\n                    if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else {\n                        if (last === '\"') {\n                            last = ',';\n                        }\n                        else {\n                            break argsCheck;\n                        }\n                    }\n                    break;\n                case ']':\n                    if (quoted) {\n                        escapedArg = escapedArg + char;\n                    }\n                    else if (last !== \"\") {\n                        this.closingBracket = new argument_1.Argument(\"]\", vscode_languageserver_types_1.Range.create(document.positionAt(argsOffset + i), document.positionAt(argsOffset + i + 1)));\n                        break argsCheck;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    break;\n                case '\\\\':\n                    if (quoted) {\n                        switch (argsContent.charAt(i + 1)) {\n                            case '\"':\n                            case '\\\\':\n                                escapedArg = escapedArg + argsContent.charAt(i + 1);\n                                i++;\n                                continue;\n                            case ' ':\n                            case '\\t':\n                                escapeCheck: for (let j = i + 2; j < argsContent.length; j++) {\n                                    switch (argsContent.charAt(j)) {\n                                        case '\\r':\n                                            // offset one more for \\r\\n\n                                            j++;\n                                        case '\\n':\n                                            i = j;\n                                            continue argsCheck;\n                                        case ' ':\n                                        case '\\t':\n                                            break;\n                                        default:\n                                            break escapeCheck;\n                                    }\n                                }\n                                break;\n                            case '\\r':\n                                // offset one more for \\r\\n\n                                i++;\n                            default:\n                                i++;\n                                continue;\n                        }\n                    }\n                    else {\n                        escapeCheck: for (let j = i + 1; j < argsContent.length; j++) {\n                            switch (argsContent.charAt(j)) {\n                                case '\\r':\n                                    // offset one more for \\r\\n\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue argsCheck;\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                default:\n                                    break escapeCheck;\n                            }\n                        }\n                    }\n                    break argsCheck;\n                default:\n                    if (!quoted) {\n                        break argsCheck;\n                    }\n                    escapedArg = escapedArg + char;\n                    break;\n            }\n        }\n    }\n    stopSearchingForFlags(_value) {\n        return true;\n    }\n    getOpeningBracket() {\n        return this.openingBracket;\n    }\n    getJSONStrings() {\n        return this.jsonStrings;\n    }\n    getClosingBracket() {\n        return this.closingBracket;\n    }\n}\nexports.JSONInstruction = JSONInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ModifiableInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst flag_1 = require(\"./flag\");\nconst instruction_1 = require(\"./instruction\");\nclass ModifiableInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getFlags() {\n        if (!this.flags) {\n            this.flags = [];\n            for (let arg of this.getArguments()) {\n                let value = arg.getValue();\n                if (this.stopSearchingForFlags(value)) {\n                    return this.flags;\n                }\n                else if (value.indexOf(\"--\") === 0) {\n                    let range = arg.getRange();\n                    let rawValue = this.document.getText().substring(this.document.offsetAt(range.start), this.document.offsetAt(range.end));\n                    let nameIndex = value.indexOf('=');\n                    let index = rawValue.indexOf('=');\n                    let firstMatch = false;\n                    let secondMatch = false;\n                    let startIndex = -1;\n                    nameSearchLoop: for (let i = 0; i < rawValue.length; i++) {\n                        switch (rawValue.charAt(i)) {\n                            case '\\\\':\n                            case ' ':\n                            case '\\t':\n                            case '\\r':\n                            case '\\n':\n                                break;\n                            case '-':\n                                if (secondMatch) {\n                                    startIndex = i;\n                                    break nameSearchLoop;\n                                }\n                                else if (firstMatch) {\n                                    secondMatch = true;\n                                }\n                                else {\n                                    firstMatch = true;\n                                }\n                                break;\n                            default:\n                                startIndex = i;\n                                break nameSearchLoop;\n                        }\n                    }\n                    let nameStart = this.document.positionAt(this.document.offsetAt(range.start) + startIndex);\n                    if (index === -1) {\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2), vscode_languageserver_types_1.Range.create(nameStart, range.end), null, null));\n                    }\n                    else if (index === value.length - 1) {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, index), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), \"\", vscode_languageserver_types_1.Range.create(range.end, range.end)));\n                    }\n                    else {\n                        let nameEnd = this.document.positionAt(this.document.offsetAt(range.start) + index);\n                        this.flags.push(new flag_1.Flag(this.document, range, value.substring(2, nameIndex), vscode_languageserver_types_1.Range.create(nameStart, nameEnd), value.substring(nameIndex + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(this.document.offsetAt(range.start) + index + 1), range.end)));\n                    }\n                }\n            }\n        }\n        return this.flags;\n    }\n    getArguments() {\n        const args = super.getArguments();\n        const flags = this.getFlags();\n        if (flags.length === 0) {\n            return args;\n        }\n        for (let i = 0; i < flags.length; i++) {\n            args.shift();\n        }\n        return args;\n    }\n}\nexports.ModifiableInstruction = ModifiableInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Flag = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst flagOption_1 = require(\"./flagOption\");\nclass Flag {\n    constructor(document, range, name, nameRange, value, valueRange) {\n        this.options = [];\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n        if (this.value !== null) {\n            let offset = document.offsetAt(valueRange.start);\n            let nameStart = -1;\n            let valueStart = -1;\n            let hasOptions = false;\n            for (let i = 0; i < value.length; i++) {\n                switch (value.charAt(i)) {\n                    case '=':\n                        hasOptions = true;\n                        if (valueStart === -1) {\n                            valueStart = i + 1;\n                            break;\n                        }\n                        break;\n                    case ',':\n                        this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, i));\n                        nameStart = -1;\n                        valueStart = -1;\n                        break;\n                    default:\n                        if (nameStart === -1) {\n                            nameStart = i;\n                        }\n                        break;\n                }\n            }\n            if (hasOptions && nameStart !== -1) {\n                this.options.push(this.createFlagOption(document, value, offset, nameStart, valueStart, value.length));\n            }\n        }\n    }\n    createFlagOption(document, content, documentOffset, nameStart, valueStart, valueEnd) {\n        const optionRange = vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueEnd));\n        if (valueStart === -1) {\n            return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueEnd), optionRange, null, null);\n        }\n        return new flagOption_1.FlagOption(optionRange, content.substring(nameStart, valueStart - 1), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + nameStart), document.positionAt(documentOffset + valueStart - 1)), content.substring(valueStart, valueEnd), vscode_languageserver_types_1.Range.create(document.positionAt(documentOffset + valueStart), document.positionAt(documentOffset + valueEnd)));\n    }\n    toString() {\n        if (this.valueRange) {\n            return \"--\" + this.name + \"=\" + this.value;\n        }\n        return \"--\" + this.name;\n    }\n    /**\n     * Returns the range that encompasses this entire flag. This includes the\n     * -- prefix in the beginning to the last character of the flag's value (if\n     * it has been defined).\n     *\n     * @return the entire range of this flag\n     */\n    getRange() {\n        return this.range;\n    }\n    /**\n     * Returns the name of this flag. The name does not include the -- prefix.\n     * Thus, for HEALTHCHECK's --interval flag, interval is the flag's name and\n     * not --interval.\n     *\n     * @return this flag's name\n     */\n    getName() {\n        return this.name;\n    }\n    /**\n     * Returns the range that encompasses the flag's name\n     *\n     * @return the range containing the flag's name\n     */\n    getNameRange() {\n        return this.nameRange;\n    }\n    /**\n     * Returns the value that has been set to this flag. May be null if the\n     * flag is invalid and has no value set like a --start-period. If the flag\n     * is instead a --start-period= with an equals sign then the flag's value\n     * is the empty string.\n     *\n     * @return this flag's value if it has been defined, null otherwise\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * Returns the range that encompasses this flag's value. If no value has\n     * been set then null will be returned.\n     *\n     * @return the range containing this flag's value, or null if the flag\n     *         has no value defined\n     */\n    getValueRange() {\n        return this.valueRange;\n    }\n    getOption(name) {\n        for (const option of this.options) {\n            if (option.getName() === name) {\n                return option;\n            }\n        }\n        return null;\n    }\n    getOptions() {\n        return this.options;\n    }\n    hasOptions() {\n        return this.options.length > 0;\n    }\n}\nexports.Flag = Flag;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlagOption = void 0;\nclass FlagOption {\n    constructor(range, name, nameRange, value, valueRange) {\n        this.range = range;\n        this.name = name;\n        this.nameRange = nameRange;\n        this.value = value;\n        this.valueRange = valueRange;\n    }\n    toString() {\n        if (this.valueRange !== null) {\n            return this.name + \"=\" + this.value;\n        }\n        return this.name;\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n}\nexports.FlagOption = FlagOption;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Arg = void 0;\nconst property_1 = require(\"../property\");\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nclass Arg extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.property = null;\n        const args = this.getPropertyArguments();\n        if (args.length === 1) {\n            this.property = new property_1.Property(this.document, this.escapeChar, args[0]);\n        }\n        else {\n            this.property = null;\n        }\n    }\n    /**\n     * Returns the variable defined by this ARG. This may be null if\n     * this ARG instruction is malformed and has no variable\n     * declaration.\n     */\n    getProperty() {\n        return this.property;\n    }\n}\nexports.Arg = Arg;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Property = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst util_1 = require(\"./util\");\nclass Property {\n    constructor(document, escapeChar, arg, arg2) {\n        this.assignmentOperatorRange = null;\n        this.assignmentOperator = null;\n        this.valueRange = null;\n        this.value = null;\n        this.document = document;\n        this.escapeChar = escapeChar;\n        this.nameRange = Property.getNameRange(document, arg);\n        let value = document.getText().substring(document.offsetAt(this.nameRange.start), document.offsetAt(this.nameRange.end));\n        this.name = Property.getValue(value, escapeChar);\n        if (arg2) {\n            this.valueRange = arg2.getRange();\n            value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n            this.value = Property.getValue(value, escapeChar);\n            this.range = vscode_languageserver_types_1.Range.create(this.nameRange.start, this.valueRange.end);\n        }\n        else {\n            let argRange = arg.getRange();\n            if (this.nameRange.start.line === argRange.start.line\n                && this.nameRange.start.character === argRange.start.character\n                && this.nameRange.end.line === argRange.end.line\n                && this.nameRange.end.character === argRange.end.character) {\n            }\n            else {\n                this.valueRange = Property.getValueRange(document, arg);\n                value = document.getText().substring(document.offsetAt(this.valueRange.start), document.offsetAt(this.valueRange.end));\n                this.value = Property.getValue(value, escapeChar);\n                this.assignmentOperatorRange = vscode_languageserver_types_1.Range.create(this.nameRange.end, this.valueRange.start);\n                this.assignmentOperator = \"=\";\n            }\n            this.range = argRange;\n        }\n    }\n    getRange() {\n        return this.range;\n    }\n    getName() {\n        return this.name;\n    }\n    getNameRange() {\n        return this.nameRange;\n    }\n    getValue() {\n        return this.value;\n    }\n    getValueRange() {\n        return this.valueRange;\n    }\n    /**\n     * Retrieves the operator used for delimiting between the name and\n     * value of this property. This will either be the \"=\" character\n     * or null if a character was not used or if this property has no\n     * value defined.\n     */\n    getAssignmentOperator() {\n        return this.assignmentOperator;\n    }\n    getAssignmentOperatorRange() {\n        return this.assignmentOperatorRange;\n    }\n    /**\n     * Returns the value of this property including any enclosing\n     * single or double quotes and relevant escape characters.\n     * Escaped newlines and its associated contiguous whitespace\n     * characters however will not be returned as they are deemed to\n     * be uninteresting to clients trying to return a Dockerfile.\n     *\n     * @return the unescaped value of this property or null if this\n     *         property has no associated value\n     */\n    getUnescapedValue() {\n        if (this.valueRange === null) {\n            return null;\n        }\n        let escaped = false;\n        let rawValue = \"\";\n        let value = this.document.getText().substring(this.document.offsetAt(this.valueRange.start), this.document.offsetAt(this.valueRange.end));\n        rawLoop: for (let i = 0; i < value.length; i++) {\n            let char = value.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    for (let j = i + 1; j < value.length; j++) {\n                        switch (value.charAt(j)) {\n                            case '\\r':\n                                j++;\n                            case '\\n':\n                                escaped = true;\n                                i = j;\n                                continue rawLoop;\n                            case ' ':\n                            case '\\t':\n                                break;\n                            default:\n                                rawValue = rawValue + char;\n                                continue rawLoop;\n                        }\n                    }\n                    // this happens if there's only whitespace after the escape character\n                    rawValue = rawValue + char;\n                    break;\n                case '\\r':\n                case '\\n':\n                    break;\n                case ' ':\n                case '\\t':\n                    if (!escaped) {\n                        rawValue = rawValue + char;\n                    }\n                    break;\n                case '#':\n                    if (escaped) {\n                        for (let j = i + 1; j < value.length; j++) {\n                            switch (value.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    continue rawLoop;\n                            }\n                        }\n                    }\n                    else {\n                        rawValue = rawValue + char;\n                    }\n                    break;\n                default:\n                    rawValue = rawValue + char;\n                    escaped = false;\n                    break;\n            }\n        }\n        return rawValue;\n    }\n    static getNameRange(document, arg) {\n        let value = arg.getValue();\n        let index = value.indexOf('=');\n        if (index !== -1) {\n            let initial = value.charAt(0);\n            let before = value.charAt(index - 1);\n            // check if content before the equals sign are in quotes\n            // \"var\"=value\n            // 'var'=value\n            // otherwise, just assume it's a standard definition\n            // var=value\n            if ((initial === '\"' && before === '\"') || (initial === '\\'' && before === '\\'') || (initial !== '\"' && initial !== '\\'')) {\n                return vscode_languageserver_types_1.Range.create(arg.getRange().start, document.positionAt(document.offsetAt(arg.getRange().start) + index));\n            }\n        }\n        // no '=' found, just defined the property's name\n        return arg.getRange();\n    }\n    static getValueRange(document, arg) {\n        return vscode_languageserver_types_1.Range.create(document.positionAt(document.offsetAt(arg.getRange().start) + arg.getValue().indexOf('=') + 1), document.positionAt(document.offsetAt(arg.getRange().end)));\n    }\n    /**\n     * Returns the actual value of this key-value pair. The value will\n     * have its escape characters removed if applicable. If the value\n     * spans multiple lines and there are comments nested within the\n     * lines, they too will be removed.\n     *\n     * @return the value that this key-value pair will actually be, may\n     *         be null if no value is defined, may be the empty string\n     *         if the value only consists of whitespace\n     */\n    static getValue(value, escapeChar) {\n        let escaped = false;\n        const skip = util_1.Util.findLeadingNonWhitespace(value, escapeChar);\n        if (skip !== 0 && value.charAt(skip) === '#') {\n            // need to skip over comments\n            escaped = true;\n        }\n        value = value.substring(skip);\n        let first = value.charAt(0);\n        let last = value.charAt(value.length - 1);\n        let literal = first === '\\'' || first === '\"';\n        let inSingle = (first === '\\'' && last === '\\'');\n        let inDouble = false;\n        if (first === '\"') {\n            for (let i = 1; i < value.length; i++) {\n                if (value.charAt(i) === escapeChar) {\n                    i++;\n                }\n                else if (value.charAt(i) === '\"' && i === value.length - 1) {\n                    inDouble = true;\n                }\n            }\n        }\n        if (inSingle || inDouble) {\n            value = value.substring(1, value.length - 1);\n        }\n        let commentCheck = -1;\n        let escapedValue = \"\";\n        let start = 0;\n        parseValue: for (let i = 0; i < value.length; i++) {\n            let char = value.charAt(i);\n            switch (char) {\n                case escapeChar:\n                    if (i + 1 === value.length) {\n                        escapedValue = escapedValue + escapeChar;\n                        break parseValue;\n                    }\n                    char = value.charAt(i + 1);\n                    if (char === ' ' || char === '\\t') {\n                        whitespaceCheck: for (let j = i + 2; j < value.length; j++) {\n                            let char2 = value.charAt(j);\n                            switch (char2) {\n                                case ' ':\n                                case '\\t':\n                                    break;\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    escaped = true;\n                                    i = j;\n                                    continue parseValue;\n                                default:\n                                    if (!inDouble && !inSingle && !literal) {\n                                        if (char2 === escapeChar) {\n                                            // add the escaped character\n                                            escapedValue = escapedValue + char;\n                                            // now start parsing from the next escape character\n                                            i = i + 1;\n                                        }\n                                        else {\n                                            // the expectation is that this j = i + 2 here\n                                            escapedValue = escapedValue + char + char2;\n                                            i = j;\n                                        }\n                                        continue parseValue;\n                                    }\n                                    break whitespaceCheck;\n                            }\n                        }\n                    }\n                    if (inDouble) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        }\n                        else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        }\n                        else if (char !== '\"') {\n                            if (char === escapeChar) {\n                                i++;\n                            }\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    }\n                    else if (inSingle || literal) {\n                        if (char === '\\r') {\n                            escaped = true;\n                            i = i + 2;\n                        }\n                        else if (char === '\\n') {\n                            escaped = true;\n                            i++;\n                        }\n                        else {\n                            escapedValue = escapedValue + escapeChar;\n                        }\n                        continue parseValue;\n                    }\n                    else if (char === escapeChar) {\n                        // double escape, append one and move on\n                        escapedValue = escapedValue + escapeChar;\n                        i++;\n                    }\n                    else if (char === '\\r') {\n                        escaped = true;\n                        // offset one more for \\r\\n\n                        i = i + 2;\n                    }\n                    else if (char === '\\n') {\n                        escaped = true;\n                        i++;\n                        start = i;\n                    }\n                    else {\n                        // any other escapes are simply ignored\n                        escapedValue = escapedValue + char;\n                        i++;\n                    }\n                    break;\n                case ' ':\n                case '\\t':\n                    if (escaped && commentCheck === -1) {\n                        commentCheck = i;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n                case '\\r':\n                    i++;\n                case '\\n':\n                    if (escaped && commentCheck !== -1) {\n                        // rollback and remove the whitespace that was previously appended\n                        escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck - 1));\n                        commentCheck = -1;\n                    }\n                    break;\n                case '#':\n                    // a newline was escaped and now there's a comment\n                    if (escaped) {\n                        if (commentCheck !== -1) {\n                            // rollback and remove the whitespace that was previously appended\n                            escapedValue = escapedValue.substring(0, escapedValue.length - (i - commentCheck));\n                            commentCheck = -1;\n                        }\n                        newlineCheck: for (let j = i + 1; j < value.length; j++) {\n                            switch (value.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    break newlineCheck;\n                            }\n                        }\n                        continue parseValue;\n                    }\n                default:\n                    if (escaped) {\n                        escaped = false;\n                        commentCheck = -1;\n                    }\n                    escapedValue = escapedValue + char;\n                    break;\n            }\n        }\n        return escapedValue;\n    }\n}\nexports.Property = Property;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PropertyInstruction = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst instruction_1 = require(\"./instruction\");\nconst property_1 = require(\"./property\");\nconst argument_1 = require(\"./argument\");\nconst util_1 = require(\"./util\");\nclass PropertyInstruction extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n        this.properties = undefined;\n    }\n    getProperties() {\n        if (this.properties === undefined) {\n            let args = this.getPropertyArguments();\n            if (args.length === 0) {\n                this.properties = [];\n            }\n            else if (args.length === 1) {\n                this.properties = [new property_1.Property(this.document, this.escapeChar, args[0])];\n            }\n            else if (args.length === 2) {\n                if (args[0].getValue().indexOf('=') === -1) {\n                    this.properties = [new property_1.Property(this.document, this.escapeChar, args[0], args[1])];\n                }\n                else {\n                    this.properties = [\n                        new property_1.Property(this.document, this.escapeChar, args[0]),\n                        new property_1.Property(this.document, this.escapeChar, args[1])\n                    ];\n                }\n            }\n            else if (args[0].getValue().indexOf('=') === -1) {\n                let text = this.document.getText();\n                let start = args[1].getRange().start;\n                let end = args[args.length - 1].getRange().end;\n                text = text.substring(this.document.offsetAt(start), this.document.offsetAt(end));\n                this.properties = [new property_1.Property(this.document, this.escapeChar, args[0], new argument_1.Argument(text, vscode_languageserver_types_1.Range.create(args[1].getRange().start, args[args.length - 1].getRange().end)))];\n            }\n            else {\n                this.properties = [];\n                for (let i = 0; i < args.length; i++) {\n                    this.properties.push(new property_1.Property(this.document, this.escapeChar, args[i]));\n                }\n            }\n        }\n        return this.properties;\n    }\n    /**\n     * Goes from the back of the string and returns the first\n     * non-whitespace character that is found. If an escape character\n     * is found with newline characters, the escape character will\n     * not be considered a non-whitespace character and its index in\n     * the string will not be returned.\n     *\n     * @param content the string to search through\n     * @return the index in the string for the first non-whitespace\n     *         character when searching from the end of the string\n     */\n    findTrailingNonWhitespace(content) {\n        // loop back to find the first non-whitespace character\n        let index = content.length;\n        whitespaceCheck: for (let i = content.length - 1; i >= 0; i--) {\n            switch (content.charAt(i)) {\n                case ' ':\n                case '\\t':\n                    continue;\n                case '\\n':\n                    if (content.charAt(i - 1) === '\\r') {\n                        i = i - 1;\n                    }\n                case '\\r':\n                    newlineCheck: for (let j = i - 1; j >= 0; j--) {\n                        switch (content.charAt(j)) {\n                            case ' ':\n                            case '\\t':\n                            case '\\r':\n                            case '\\n':\n                            case this.escapeChar:\n                                continue;\n                            default:\n                                index = j;\n                                break newlineCheck;\n                        }\n                    }\n                    break whitespaceCheck;\n                default:\n                    index = i;\n                    break whitespaceCheck;\n            }\n        }\n        return index;\n    }\n    getPropertyArguments() {\n        const args = [];\n        let range = this.getInstructionRange();\n        let instructionNameEndOffset = this.document.offsetAt(range.end);\n        let extra = instructionNameEndOffset - this.document.offsetAt(range.start);\n        let content = this.getTextContent();\n        let fullArgs = content.substring(extra);\n        let start = util_1.Util.findLeadingNonWhitespace(fullArgs, this.escapeChar);\n        if (start === -1) {\n            // only whitespace found, no arguments\n            return [];\n        }\n        const startPosition = this.document.positionAt(instructionNameEndOffset + start);\n        // records whether the parser has just processed an escaped newline or not,\n        // if our starting position is not on the same line as the instruction then\n        // the start of the content is already on an escaped line\n        let escaped = range.start.line !== startPosition.line;\n        // flag to track if the last character was an escape character\n        let endingEscape = false;\n        // position before the first escape character was hit\n        let mark = -1;\n        let end = this.findTrailingNonWhitespace(fullArgs);\n        content = fullArgs.substring(start, end + 1);\n        let argStart = escaped ? -1 : 0;\n        let spaced = false;\n        argumentLoop: for (let i = 0; i < content.length; i++) {\n            let char = content.charAt(i);\n            switch (char) {\n                case this.escapeChar:\n                    if (i + 1 === content.length) {\n                        endingEscape = true;\n                        break argumentLoop;\n                    }\n                    if (!escaped) {\n                        mark = i;\n                    }\n                    switch (content.charAt(i + 1)) {\n                        case ' ':\n                        case '\\t':\n                            if (!util_1.Util.isWhitespace(content.charAt(i + 2))) {\n                                // space was escaped, continue as normal\n                                i = i + 1;\n                                continue argumentLoop;\n                            }\n                            // whitespace encountered, need to figure out if it extends to EOL\n                            whitespaceCheck: for (let j = i + 2; j < content.length; j++) {\n                                switch (content.charAt(j)) {\n                                    case '\\r':\n                                        // offset one more for \\r\\n\n                                        j++;\n                                    case '\\n':\n                                        // whitespace only, safe to skip\n                                        escaped = true;\n                                        i = j;\n                                        continue argumentLoop;\n                                    case ' ':\n                                    case '\\t':\n                                        // ignore whitespace\n                                        break;\n                                    default:\n                                        // whitespace doesn't extend to EOL, create an argument\n                                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i + 2))));\n                                        argStart = j;\n                                        break whitespaceCheck;\n                                }\n                            }\n                            // go back and start processing the encountered non-whitespace character\n                            i = argStart - 1;\n                            continue argumentLoop;\n                        case '\\r':\n                            // offset one more for \\r\\n\n                            i++;\n                        case '\\n':\n                            // immediately followed by a newline, skip the newline\n                            escaped = true;\n                            i = i + 1;\n                            continue argumentLoop;\n                        case this.escapeChar:\n                            // double escape found, skip it and move on\n                            if (argStart === -1) {\n                                argStart = i;\n                            }\n                            i = i + 1;\n                            continue argumentLoop;\n                        default:\n                            if (argStart === -1) {\n                                argStart = i;\n                            }\n                            // non-whitespace encountered, skip the escape and process the\n                            // character normally\n                            continue argumentLoop;\n                    }\n                case '\\'':\n                case '\"':\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    if (argStart === -1) {\n                        argStart = i;\n                    }\n                    for (let j = i + 1; j < content.length; j++) {\n                        switch (content.charAt(j)) {\n                            case char:\n                                if (content.charAt(j + 1) !== ' ' && content.charAt(j + 1) !== '') {\n                                    // there is more content after this quote,\n                                    // continue so that it is all processed as\n                                    // one single argument\n                                    i = j;\n                                    continue argumentLoop;\n                                }\n                                args.push(new argument_1.Argument(content.substring(argStart, j + 1), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + j + 1))));\n                                i = j;\n                                argStart = -1;\n                                continue argumentLoop;\n                            case this.escapeChar:\n                                j++;\n                                break;\n                        }\n                    }\n                    break argumentLoop;\n                case ' ':\n                case '\\t':\n                    if (escaped) {\n                        // consider there to be a space only if an argument\n                        // is not spanning multiple lines\n                        if (argStart !== -1) {\n                            spaced = true;\n                        }\n                    }\n                    else if (argStart !== -1) {\n                        args.push(new argument_1.Argument(content.substring(argStart, i), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + i))));\n                        argStart = -1;\n                    }\n                    break;\n                case '\\r':\n                    // offset one more for \\r\\n\n                    i++;\n                case '\\n':\n                    spaced = false;\n                    break;\n                case '#':\n                    if (escaped) {\n                        // a newline was escaped and now there's a comment\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case '\\r':\n                                    j++;\n                                case '\\n':\n                                    i = j;\n                                    spaced = false;\n                                    continue argumentLoop;\n                            }\n                        }\n                        // went to the end without finding a newline,\n                        // the comment was the last line in the instruction,\n                        // just stop parsing, create an argument if needed\n                        if (argStart !== -1) {\n                            let value = content.substring(argStart, mark);\n                            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n                            argStart = -1;\n                        }\n                        break argumentLoop;\n                    }\n                    else if (argStart === -1) {\n                        argStart = i;\n                    }\n                    break;\n                default:\n                    if (spaced) {\n                        this.createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start);\n                        // reset to start a new argument\n                        argStart = i;\n                        spaced = false;\n                    }\n                    escaped = false;\n                    if (argStart === -1) {\n                        argStart = i;\n                    }\n                    // variable detected\n                    if (char === '$' && content.charAt(i + 1) === '{') {\n                        let singleQuotes = false;\n                        let doubleQuotes = false;\n                        let escaped = false;\n                        for (let j = i + 1; j < content.length; j++) {\n                            switch (content.charAt(j)) {\n                                case this.escapeChar:\n                                    escaped = true;\n                                    break;\n                                case '\\r':\n                                case '\\n':\n                                    break;\n                                case '\\'':\n                                    singleQuotes = !singleQuotes;\n                                    escaped = false;\n                                    break;\n                                case '\"':\n                                    doubleQuotes = !doubleQuotes;\n                                    escaped = false;\n                                    break;\n                                case ' ':\n                                case '\\t':\n                                    if (escaped || singleQuotes || doubleQuotes) {\n                                        break;\n                                    }\n                                    i = j - 1;\n                                    continue argumentLoop;\n                                case '}':\n                                    i = j;\n                                    continue argumentLoop;\n                                default:\n                                    escaped = false;\n                                    break;\n                            }\n                        }\n                        break argumentLoop;\n                    }\n                    break;\n            }\n        }\n        if (argStart !== -1 && argStart !== content.length) {\n            let end = endingEscape ? content.length - 1 : content.length;\n            let value = content.substring(argStart, end);\n            args.push(new argument_1.Argument(value, vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + end))));\n        }\n        return args;\n    }\n    createSpacedArgument(argStart, args, content, mark, instructionNameEndOffset, start) {\n        if (argStart !== -1) {\n            args.push(new argument_1.Argument(content.substring(argStart, mark), vscode_languageserver_types_1.Range.create(this.document.positionAt(instructionNameEndOffset + start + argStart), this.document.positionAt(instructionNameEndOffset + start + mark))));\n        }\n    }\n}\nexports.PropertyInstruction = PropertyInstruction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cmd = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Cmd extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Cmd = Cmd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Copy = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Copy extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getFromFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"from\" ? flags[0] : null;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */\n    getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Copy = Copy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Env = void 0;\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nclass Env extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Env = Env;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Entrypoint = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Entrypoint extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Entrypoint = Entrypoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.From = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst modifiableInstruction_1 = require(\"../modifiableInstruction\");\nclass From extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    getImage() {\n        return this.getRangeContent(this.getImageRange());\n    }\n    /**\n     * Returns the name of the image that will be used as the base image.\n     *\n     * @return the base image's name, or null if unspecified\n     */\n    getImageName() {\n        return this.getRangeContent(this.getImageNameRange());\n    }\n    /**\n     * Returns the range that covers the name of the image used by\n     * this instruction.\n     *\n     * @return the range of the name of this instruction's argument,\n     *         or null if no image has been specified\n     */\n    getImageNameRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let registryRange = this.getRegistryRange();\n            if (registryRange) {\n                range.start = this.document.positionAt(this.document.offsetAt(registryRange.end) + 1);\n            }\n            let tagRange = this.getImageTagRange();\n            let digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) {\n                    range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n                }\n            }\n            else {\n                range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            }\n            return range;\n        }\n        return null;\n    }\n    /**\n     * Returns the range that covers the image argument of this\n     * instruction. This includes the tag or digest of the image if\n     * it has been specified by the instruction.\n     *\n     * @return the range of the image argument, or null if no image\n     *         has been specified\n     */\n    getImageRange() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0].getRange() : null;\n    }\n    getImageTag() {\n        return this.getRangeContent(this.getImageTagRange());\n    }\n    /**\n     * Returns the range in the document that the tag of the base\n     * image encompasses.\n     *\n     * @return the base image's tag's range in the document, or null\n     *         if no tag has been specified\n     */\n    getImageTagRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const rangeStartOffset = this.document.offsetAt(range.start);\n            const content = this.getRangeContent(range);\n            const atIndex = this.indexOf(rangeStartOffset, content, '@');\n            const slashIndex = content.indexOf('/');\n            if (atIndex === -1) {\n                const colonIndex = this.lastIndexOf(rangeStartOffset, content, ':');\n                if (colonIndex > slashIndex) {\n                    return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + colonIndex + 1, range.end.line, range.end.character);\n                }\n            }\n            const subcontent = content.substring(0, atIndex);\n            const subcolonIndex = subcontent.indexOf(':');\n            if (subcolonIndex === -1) {\n                return null;\n            }\n            if (slashIndex === -1) {\n                // slash not found suggests no registry and no namespace defined\n                return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + atIndex));\n            }\n            // both colon and slash found, check if it is a port\n            if (subcolonIndex < slashIndex) {\n                return null;\n            }\n            return vscode_languageserver_types_1.Range.create(this.document.positionAt(rangeStartOffset + subcolonIndex + 1), this.document.positionAt(rangeStartOffset + subcontent.length));\n        }\n        return null;\n    }\n    getImageDigest() {\n        return this.getRangeContent(this.getImageDigestRange());\n    }\n    /**\n     * Returns the range in the document that the digest of the base\n     * image encompasses.\n     *\n     * @return the base image's digest's range in the document, or null\n     *         if no digest has been specified\n     */\n    getImageDigestRange() {\n        let range = this.getImageRange();\n        if (range) {\n            let content = this.getRangeContent(range);\n            let index = this.lastIndexOf(this.document.offsetAt(range.start), content, '@');\n            if (index !== -1) {\n                return vscode_languageserver_types_1.Range.create(range.start.line, range.start.character + index + 1, range.end.line, range.end.character);\n            }\n        }\n        return null;\n    }\n    indexOf(documentOffset, content, searchString) {\n        let index = content.indexOf(searchString);\n        const variables = this.getVariables();\n        for (let i = 0; i < variables.length; i++) {\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                const offset = this.document.offsetAt(variableRange.end) - documentOffset;\n                const substring = content.substring(offset);\n                const subIndex = substring.indexOf(searchString);\n                if (subIndex === -1) {\n                    return -1;\n                }\n                index = subIndex + offset;\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    lastIndexOf(documentOffset, content, searchString) {\n        let index = content.lastIndexOf(searchString);\n        const variables = this.getVariables();\n        for (let i = 0; i < variables.length; i++) {\n            const position = documentOffset + index;\n            const variableRange = variables[i].getRange();\n            if (this.document.offsetAt(variableRange.start) < position && position < this.document.offsetAt(variableRange.end)) {\n                index = content.substring(0, index).lastIndexOf(searchString);\n                if (index === -1) {\n                    return -1;\n                }\n                i = -1;\n                continue;\n            }\n        }\n        return index;\n    }\n    getRegistry() {\n        return this.getRangeContent(this.getRegistryRange());\n    }\n    getRegistryRange() {\n        const range = this.getImageRange();\n        if (range) {\n            const tagRange = this.getImageTagRange();\n            const digestRange = this.getImageDigestRange();\n            if (tagRange === null) {\n                if (digestRange !== null) {\n                    range.end = this.document.positionAt(this.document.offsetAt(digestRange.start) - 1);\n                }\n            }\n            else {\n                range.end = this.document.positionAt(this.document.offsetAt(tagRange.start) - 1);\n            }\n            const content = this.getRangeContent(range);\n            const rangeStart = this.document.offsetAt(range.start);\n            const startingSlashIndex = this.indexOf(rangeStart, content, '/');\n            if (startingSlashIndex === -1) {\n                return null;\n            }\n            const portIndex = this.indexOf(rangeStart, content, ':');\n            const dotIndex = this.indexOf(rangeStart, content, '.');\n            // hostname detected\n            if (portIndex !== -1 || dotIndex !== -1) {\n                return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            }\n            const registry = content.substring(0, startingSlashIndex);\n            // localhost registry detected\n            if (registry === 'localhost') {\n                return vscode_languageserver_types_1.Range.create(range.start, this.document.positionAt(rangeStart + startingSlashIndex));\n            }\n        }\n        return null;\n    }\n    getBuildStage() {\n        let range = this.getBuildStageRange();\n        return range === null ? null : this.getRangeContent(range);\n    }\n    getBuildStageRange() {\n        let args = this.getArguments();\n        if (args.length > 2 && args[1].getValue().toUpperCase() === \"AS\") {\n            return args[2].getRange();\n        }\n        return null;\n    }\n    getPlatformFlag() {\n        let flags = super.getFlags();\n        return flags.length === 1 && flags[0].getName() === \"platform\" ? flags[0] : null;\n    }\n}\nexports.From = From;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Healthcheck = void 0;\nconst modifiableInstruction_1 = require(\"../modifiableInstruction\");\nclass Healthcheck extends modifiableInstruction_1.ModifiableInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        argument = argument.toUpperCase();\n        return argument === \"CMD\" || argument === \"NONE\";\n    }\n    getSubcommand() {\n        let args = this.getArguments();\n        return args.length !== 0 ? args[0] : null;\n    }\n}\nexports.Healthcheck = Healthcheck;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Label = void 0;\nconst propertyInstruction_1 = require(\"../propertyInstruction\");\nconst util_1 = require(\"../util\");\nclass Label extends propertyInstruction_1.PropertyInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getVariables() {\n        const variables = super.getVariables();\n        const properties = this.getProperties();\n        // iterate over all of this LABEL's properties\n        for (const property of properties) {\n            const value = property.getUnescapedValue();\n            // check if the value is contained in single quotes,\n            // single quotes would indicate a literal value\n            if (value !== null && value.length > 2 && value.charAt(0) === '\\'' && value.charAt(value.length - 1) === '\\'') {\n                const range = property.getValueRange();\n                for (let i = 0; i < variables.length; i++) {\n                    // if a variable is in a single quote, remove it from the list\n                    if (util_1.Util.isInsideRange(variables[i].getRange().start, range)) {\n                        variables.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return variables;\n    }\n    getProperties() {\n        return super.getProperties();\n    }\n}\nexports.Label = Label;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Onbuild = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst parser_1 = require(\"../parser\");\nconst instruction_1 = require(\"../instruction\");\nclass Onbuild extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    getTrigger() {\n        let trigger = this.getTriggerWord();\n        return trigger === null ? null : trigger.toUpperCase();\n    }\n    getTriggerWord() {\n        return this.getRangeContent(this.getTriggerRange());\n    }\n    getTriggerRange() {\n        let args = this.getArguments();\n        return args.length > 0 ? args[0].getRange() : null;\n    }\n    getTriggerInstruction() {\n        let triggerRange = this.getTriggerRange();\n        if (triggerRange === null) {\n            return null;\n        }\n        let args = this.getArguments();\n        return parser_1.Parser.createInstruction(this.document, this.dockerfile, this.escapeChar, vscode_languageserver_types_1.Range.create(args[0].getRange().start, this.getRange().end), this.getTriggerWord(), triggerRange);\n    }\n}\nexports.Onbuild = Onbuild;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Run = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Run extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    stopSearchingForFlags(argument) {\n        return argument.indexOf(\"--\") === -1;\n    }\n    /**\n     * Returns there here-documents that are defined in this RUN\n     * instruction.\n     *\n     * This API is experimental and subject to change.\n     */\n    getHeredocs() {\n        return super.getHeredocs();\n    }\n}\nexports.Run = Run;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Shell = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Shell extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Shell = Shell;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Stopsignal = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass Stopsignal extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Stopsignal = Stopsignal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Workdir = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass Workdir extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n    /**\n     * Returns the path that has been defined. Note that this path may\n     * be absolute or relative depending on what was written in the\n     * instruction.\n     *\n     * @return the working directory's path, or null if this\n     *         instruction has no arguments\n     */\n    getPath() {\n        return this.getArgumentsContent();\n    }\n    /**\n     * Returns the absolute path that this instruction resolves to. The\n     * function will inspect prior WORKDIR instructions in the current\n     * image or another build stage in the Dockerfile to try to\n     * determine this.\n     *\n     * @return the absolute path of the working directory, or null if\n     *         this instruction has no arguments, or undefined if it\n     *         cannot be determined because only relative paths could be\n     *         found\n     */\n    getAbsolutePath() {\n        const path = this.getPath();\n        if (path === null || path.startsWith(\"/\")) {\n            return path;\n        }\n        const startLine = this.getRange().start.line;\n        const hierarchy = this.dockerfile.getStageHierarchy(startLine);\n        for (let i = hierarchy.length - 1; i >= 0; i--) {\n            const workdirs = hierarchy[i].getWORKDIRs();\n            for (let j = workdirs.length - 1; j >= 0; j--) {\n                if (workdirs[j].getRange().start.line < startLine) {\n                    const parent = workdirs[j].getAbsolutePath();\n                    if (parent === undefined || parent === null) {\n                        return undefined;\n                    }\n                    return parent.endsWith(\"/\") ? parent + path : parent + \"/\" + path;\n                }\n            }\n        }\n        return undefined;\n    }\n}\nexports.Workdir = Workdir;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.User = void 0;\nconst instruction_1 = require(\"../instruction\");\nclass User extends instruction_1.Instruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.User = User;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Volume = void 0;\nconst jsonInstruction_1 = require(\"../jsonInstruction\");\nclass Volume extends jsonInstruction_1.JSONInstruction {\n    constructor(document, range, dockerfile, escapeChar, instruction, instructionRange) {\n        super(document, range, dockerfile, escapeChar, instruction, instructionRange);\n    }\n}\nexports.Volume = Volume;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dockerfile = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst ast = require(\"./main\");\nconst imageTemplate_1 = require(\"./imageTemplate\");\nconst from_1 = require(\"./instructions/from\");\nconst util_1 = require(\"./util\");\nconst main_1 = require(\"./main\");\nclass Dockerfile extends imageTemplate_1.ImageTemplate {\n    constructor(document) {\n        super();\n        this.initialInstructions = new imageTemplate_1.ImageTemplate();\n        this.buildStages = [];\n        this.directives = [];\n        /**\n         * Whether a FROM instruction has been added to this Dockerfile or not.\n         */\n        this.foundFrom = false;\n        this.document = document;\n    }\n    getEscapeCharacter() {\n        for (const directive of this.directives) {\n            if (directive.getDirective() === ast.Directive.escape) {\n                const value = directive.getValue();\n                if (value === '\\\\' || value === '`') {\n                    return value;\n                }\n            }\n        }\n        return '\\\\';\n    }\n    getInitialARGs() {\n        return this.initialInstructions.getARGs();\n    }\n    getContainingImage(position) {\n        let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), this.document.positionAt(this.document.getText().length));\n        if (!util_1.Util.isInsideRange(position, range)) {\n            // not inside the document, invalid position\n            return null;\n        }\n        if (this.initialInstructions.getComments().length > 0 || this.initialInstructions.getInstructions().length > 0) {\n            if (util_1.Util.isInsideRange(position, this.initialInstructions.getRange())) {\n                return this.initialInstructions;\n            }\n        }\n        for (const buildStage of this.buildStages) {\n            if (util_1.Util.isInsideRange(position, buildStage.getRange())) {\n                return buildStage;\n            }\n        }\n        return this;\n    }\n    addInstruction(instruction) {\n        if (instruction.getKeyword() === main_1.Keyword.FROM) {\n            this.currentBuildStage = new imageTemplate_1.ImageTemplate();\n            this.buildStages.push(this.currentBuildStage);\n            this.foundFrom = true;\n        }\n        else if (!this.foundFrom) {\n            this.initialInstructions.addInstruction(instruction);\n        }\n        if (this.foundFrom) {\n            this.currentBuildStage.addInstruction(instruction);\n        }\n        super.addInstruction(instruction);\n    }\n    setDirectives(directives) {\n        this.directives = directives;\n    }\n    getDirective() {\n        return this.directives.length === 0 ? null : this.directives[0];\n    }\n    getDirectives() {\n        return this.directives;\n    }\n    resolveVariable(variable, line) {\n        for (let from of this.getFROMs()) {\n            let range = from.getRange();\n            if (range.start.line <= line && line <= range.end.line) {\n                // resolve the FROM variable against the initial ARGs\n                let initialARGs = new imageTemplate_1.ImageTemplate();\n                for (let instruction of this.initialInstructions.getARGs()) {\n                    initialARGs.addInstruction(instruction);\n                }\n                return initialARGs.resolveVariable(variable, line);\n            }\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) {\n            return undefined;\n        }\n        let resolvedVariable = image.resolveVariable(variable, line);\n        if (resolvedVariable === null) {\n            // refers to an uninitialized ARG variable,\n            // try resolving it against the initial ARGs then\n            let initialARGs = new imageTemplate_1.ImageTemplate();\n            for (let instruction of this.initialInstructions.getARGs()) {\n                initialARGs.addInstruction(instruction);\n            }\n            return initialARGs.resolveVariable(variable, line);\n        }\n        return resolvedVariable;\n    }\n    getAvailableVariables(currentLine) {\n        if (this.getInstructionAt(currentLine) instanceof from_1.From) {\n            let variables = [];\n            for (let arg of this.getInitialARGs()) {\n                let property = arg.getProperty();\n                if (property) {\n                    variables.push(property.getName());\n                }\n            }\n            return variables;\n        }\n        let image = this.getContainingImage(vscode_languageserver_types_1.Position.create(currentLine, 0));\n        return image ? image.getAvailableVariables(currentLine) : [];\n    }\n    getParentStage(image) {\n        const templateFrom = image.getFROM();\n        const imageName = templateFrom === null ? null : templateFrom.getImageName();\n        if (imageName === null) {\n            return null;\n        }\n        for (const from of this.getFROMs()) {\n            if (from.getBuildStage() === imageName) {\n                const range = from.getRange();\n                // on the same line then it's an image that shares the name as the build stage\n                if (range.start.line === templateFrom.getRange().start.line) {\n                    return null;\n                }\n                return this.getContainingImage(range.start);\n            }\n        }\n        return null;\n    }\n    getStageHierarchy(line) {\n        const image = this.getContainingImage(vscode_languageserver_types_1.Position.create(line, 0));\n        if (image === null) {\n            return [];\n        }\n        const stages = [image];\n        let stage = this.getParentStage(image);\n        while (stage !== null) {\n            stages.splice(0, 0, stage);\n            stage = this.getParentStage(stage);\n        }\n        return stages;\n    }\n    getAvailableWorkingDirectories(line) {\n        const availableDirectories = new Set();\n        for (const image of this.getStageHierarchy(line)) {\n            for (const workdir of image.getWORKDIRs()) {\n                if (workdir.getRange().end.line < line) {\n                    let directory = workdir.getAbsolutePath();\n                    if (directory !== undefined && directory !== null) {\n                        if (!directory.endsWith(\"/\")) {\n                            directory += \"/\";\n                        }\n                        availableDirectories.add(directory);\n                    }\n                }\n            }\n        }\n        return Array.from(availableDirectories);\n    }\n    /**\n     * Internally reorganize the comments in the Dockerfile and allocate\n     * them to the relevant build stages that they belong to.\n     */\n    organizeComments() {\n        const comments = this.getComments();\n        for (let i = 0; i < comments.length; i++) {\n            if (util_1.Util.isInsideRange(comments[i].getRange().end, this.initialInstructions.getRange())) {\n                this.initialInstructions.addComment(comments[i]);\n            }\n            else {\n                for (const buildStage of this.buildStages) {\n                    if (util_1.Util.isInsideRange(comments[i].getRange().start, buildStage.getRange())) {\n                        buildStage.addComment(comments[i]);\n                    }\n                }\n            }\n        }\n    }\n    getRange() {\n        const comments = this.getComments();\n        const instructions = this.getInstructions();\n        let range = null;\n        if (comments.length === 0) {\n            if (instructions.length > 0) {\n                range = vscode_languageserver_types_1.Range.create(instructions[0].getRange().start, instructions[instructions.length - 1].getRange().end);\n            }\n        }\n        else if (instructions.length === 0) {\n            range = vscode_languageserver_types_1.Range.create(comments[0].getRange().start, comments[comments.length - 1].getRange().end);\n        }\n        else {\n            const commentStart = comments[0].getRange().start;\n            const commentEnd = comments[comments.length - 1].getRange().end;\n            const instructionStart = instructions[0].getRange().start;\n            const instructionEnd = instructions[instructions.length - 1].getRange().end;\n            if (commentStart.line < instructionStart.line) {\n                if (commentEnd.line < instructionEnd.line) {\n                    range = vscode_languageserver_types_1.Range.create(commentStart, instructionEnd);\n                }\n                range = vscode_languageserver_types_1.Range.create(commentStart, commentEnd);\n            }\n            else if (commentEnd.line < instructionEnd.line) {\n                range = vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n            }\n            else {\n                range = vscode_languageserver_types_1.Range.create(instructionStart, commentEnd);\n            }\n        }\n        if (range === null) {\n            if (this.directives.length === 0) {\n                return null;\n            }\n            return this.directives[0].getRange();\n        }\n        else if (this.directives.length === 0) {\n            return range;\n        }\n        return vscode_languageserver_types_1.Range.create(this.directives[0].getRange().start, range.end);\n    }\n}\nexports.Dockerfile = Dockerfile;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Remy Suen. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageTemplate = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst arg_1 = require(\"./instructions/arg\");\nconst cmd_1 = require(\"./instructions/cmd\");\nconst copy_1 = require(\"./instructions/copy\");\nconst env_1 = require(\"./instructions/env\");\nconst entrypoint_1 = require(\"./instructions/entrypoint\");\nconst from_1 = require(\"./instructions/from\");\nconst healthcheck_1 = require(\"./instructions/healthcheck\");\nconst onbuild_1 = require(\"./instructions/onbuild\");\nconst util_1 = require(\"./util\");\nconst workdir_1 = require(\"./instructions/workdir\");\nclass ImageTemplate {\n    constructor() {\n        this.comments = [];\n        this.instructions = [];\n    }\n    addComment(comment) {\n        this.comments.push(comment);\n    }\n    getComments() {\n        return this.comments;\n    }\n    addInstruction(instruction) {\n        this.instructions.push(instruction);\n    }\n    getInstructions() {\n        return this.instructions;\n    }\n    getInstructionAt(line) {\n        for (let instruction of this.instructions) {\n            if (util_1.Util.isInsideRange(vscode_languageserver_types_1.Position.create(line, 0), instruction.getRange())) {\n                return instruction;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets all the ARG instructions that are defined in this image.\n     */\n    getARGs() {\n        let args = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof arg_1.Arg) {\n                args.push(instruction);\n            }\n        }\n        return args;\n    }\n    /**\n     * Gets all the CMD instructions that are defined in this image.\n     */\n    getCMDs() {\n        let cmds = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof cmd_1.Cmd) {\n                cmds.push(instruction);\n            }\n        }\n        return cmds;\n    }\n    /**\n     * Gets all the COPY instructions that are defined in this image.\n     */\n    getCOPYs() {\n        let copies = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof copy_1.Copy) {\n                copies.push(instruction);\n            }\n        }\n        return copies;\n    }\n    /**\n     * Gets all the ENTRYPOINT instructions that are defined in this image.\n     */\n    getENTRYPOINTs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof entrypoint_1.Entrypoint) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    /**\n     * Gets all the ENV instructions that are defined in this image.\n     */\n    getENVs() {\n        let args = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof env_1.Env) {\n                args.push(instruction);\n            }\n        }\n        return args;\n    }\n    getFROM() {\n        for (const instruction of this.instructions) {\n            if (instruction instanceof from_1.From) {\n                return instruction;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets all the FROM instructions that are defined in this image.\n     */\n    getFROMs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof from_1.From) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    /**\n     * Gets all the HEALTHCHECK instructions that are defined in this image.\n     */\n    getHEALTHCHECKs() {\n        let froms = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof healthcheck_1.Healthcheck) {\n                froms.push(instruction);\n            }\n        }\n        return froms;\n    }\n    getWORKDIRs() {\n        const workdirs = [];\n        for (const instruction of this.instructions) {\n            if (instruction instanceof workdir_1.Workdir) {\n                workdirs.push(instruction);\n            }\n        }\n        return workdirs;\n    }\n    getOnbuildTriggers() {\n        let triggers = [];\n        for (let instruction of this.instructions) {\n            if (instruction instanceof onbuild_1.Onbuild) {\n                let trigger = instruction.getTriggerInstruction();\n                if (trigger) {\n                    triggers.push(trigger);\n                }\n            }\n        }\n        return triggers;\n    }\n    getAvailableVariables(currentLine) {\n        const variables = [];\n        for (const arg of this.getARGs()) {\n            if (arg.isBefore(currentLine)) {\n                const property = arg.getProperty();\n                if (property) {\n                    const variable = property.getName();\n                    if (variables.indexOf(variable) === -1) {\n                        variables.push(variable);\n                    }\n                }\n            }\n        }\n        for (const env of this.getENVs()) {\n            if (env.isBefore(currentLine)) {\n                for (const property of env.getProperties()) {\n                    const variable = property.getName();\n                    if (variables.indexOf(variable) === -1) {\n                        variables.push(variable);\n                    }\n                }\n            }\n        }\n        return variables;\n    }\n    /**\n     * Resolves a variable with the given name at the specified line\n     * to its value. If null is returned, then the variable has been\n     * defined but no value was given. If undefined is returned, then\n     * a variable with the given name has not been defined yet as of\n     * the given line.\n     *\n     * @param variable the name of the variable to resolve\n     * @param line the line number that the variable is on, zero-based\n     * @return the value of the variable as defined by an ARG or ENV\n     *         instruction, or null if no value has been specified, or\n     *         undefined if a variable with the given name has not\n     *         been defined\n     */\n    resolveVariable(variable, line) {\n        let envs = this.getENVs();\n        for (let i = envs.length - 1; i >= 0; i--) {\n            if (envs[i].isBefore(line)) {\n                for (let property of envs[i].getProperties()) {\n                    if (property.getName() === variable) {\n                        return property.getValue();\n                    }\n                }\n            }\n        }\n        let args = this.getARGs();\n        for (let i = args.length - 1; i >= 0; i--) {\n            if (args[i].isBefore(line)) {\n                let property = args[i].getProperty();\n                if (property && property.getName() === variable) {\n                    return property.getValue();\n                }\n            }\n        }\n        return undefined;\n    }\n    getRange() {\n        const instructions = this.getInstructions();\n        if (instructions.length === 0) {\n            // all templates should have instructions, this only happens for\n            // the initial set of instruction\n            return vscode_languageserver_types_1.Range.create(0, 0, 0, 0);\n        }\n        const instructionStart = instructions[0].getRange().start;\n        const instructionEnd = instructions[instructions.length - 1].getRange().end;\n        return vscode_languageserver_types_1.Range.create(instructionStart, instructionEnd);\n    }\n    contains(position) {\n        const range = this.getRange();\n        if (range === null) {\n            return false;\n        }\n        return util_1.Util.isInsideRange(position, range);\n    }\n}\nexports.ImageTemplate = ImageTemplate;\n","import spawnPlease from 'spawn-please'\nimport cp, { type ChildProcess } from 'child_process';\n\nexport async function run(command: string, args: string[]) {\n    try {\n        return await spawnPlease(command, args);\n    } catch (error) {\n        console.error(`Error running command: ${command} ${args.join(' ')}`);\n        throw error;\n    }\n}\n\nexport async function runPiped([command1, args1]: [string, string[]], [command2, args2]: [string, string[]]) {\n    const cp1 = cp.spawn(command1, args1, { stdio: ['inherit', 'pipe', 'inherit'] });\n    const cp2 = cp.spawn(command2, args2, { stdio: ['pipe', 'inherit', 'inherit'] });\n\n    cp1.stdout.pipe(cp2.stdin);\n\n    await Promise.all([assertSuccess(cp1), assertSuccess(cp2)]);\n}\n\nfunction assertSuccess(cp: ChildProcess) {\n    return new Promise<void>((resolve, reject) => {\n        cp.on('error', (error) => {\n            reject(error);\n        });\n        cp.on('close', (code) => {\n            if (code !== 0) {\n                reject(new Error(`process exited with code ${code}`));\n            }\n            resolve();\n        });\n    });\n}\n","const spawn = require('cross-spawn')\n\n/** Spawns a child process, as long as you ask nicely.\n * \n * @param {string} command - The shell command to execute.\n * @param {string[]} [args] - An array of arguments that are given after the command.\n * @param {{ rejectOnError?: boolean, stdin?: string, stderr?: (data: string) => void, stdout?: (data: string) => void }} [options] - Options.\n * @param {any} [spawnOptions] - Options that are passed directly to child_process.spawn. Also supports stdin: string.\n * @returns {Promise<{ stdout: string, stderr: string }>}\n */\nconst spawnPlease = (command, args, options={}, spawnOptions={}) => {\n  // defaults\n  if (options.rejectOnError === undefined) {\n    options.rejectOnError = true\n  }\n\n  let stdout = ''\n  let stderr = ''\n  const child = spawn(command, args, spawnOptions)\n\n  return new Promise((resolve, reject) => {\n    if (options.stdin !== undefined && options.stdin != null) {\n      child.stdin.write(options.stdin)\n    }\n    child.stdin.end()\n\n    child.stdout.on('data', data => {\n      stdout += data\n      if (options.stdout) options.stdout(data)\n    })\n\n    child.stderr.on('data', data => {\n      stderr += data\n      if (options.stderr) options.stderr(data)\n    })\n\n    if (options.rejectOnError) {\n      child.addListener('error', reject)\n    }\n\n    child.on('close', code => {\n      if (code !== 0 && options.rejectOnError) {\n        reject(stderr)\n      } else {\n        resolve({ stdout, stderr })\n      }\n    })\n  })\n}\n\nmodule.exports = spawnPlease\n","'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n","'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n","'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n","'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n","'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n","'use strict';\nmodule.exports = /^#!(.*)/;\n","'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n","import { promises as fs } from 'fs';\nimport path from 'path';\nimport {CacheOptions, Opts, getCacheMap, getMountArgsString, getTargetPath, getBuilder} from './opts.js';\nimport { run, runPiped } from './run.js';\n\nasync function extractCache(cacheSource: string, cacheOptions: CacheOptions, scratchDir: string, containerImage: string, builder: string) {\n    // Prepare Timestamp for Layer Cache Busting\n    const date = new Date().toISOString();\n\n    await fs.mkdir(scratchDir, { recursive: true });\n    await fs.writeFile(path.join(scratchDir, 'buildstamp'), date);\n\n    // Prepare Dancefile to Access Caches\n    const targetPath = getTargetPath(cacheOptions);\n    const mountArgs = getMountArgsString(cacheOptions);\n\n    const dancefileContent = `\nFROM ${containerImage}\nCOPY buildstamp buildstamp\nRUN --mount=${mountArgs} \\\n    mkdir -p /var/dance-cache/ \\\n    && cp -p -R ${targetPath}/. /var/dance-cache/ || true\n`;\n    await fs.writeFile(path.join(scratchDir, 'Dancefile.extract'), dancefileContent);\n    console.log(dancefileContent);\n\n    // Extract Data into Docker Image\n    await run('docker', ['buildx', 'build', '--builder', builder, '-f', path.join(scratchDir, 'Dancefile.extract'), '--tag', 'dance:extract', '--load', scratchDir]);\n\n    // Create Extraction Image\n    try {\n        await run('docker', ['rm', '-f', 'cache-container']);\n    } catch (error) {\n        // Ignore error if container does not exist\n    }\n    await run('docker', ['create', '-ti', '--name', 'cache-container', 'dance:extract']);\n\n    // Unpack Docker Image into Scratch\n    await runPiped(\n        ['docker', ['cp', '-L', 'cache-container:/var/dance-cache', '-']],\n        ['tar', ['-H', 'posix', '-x', '-C', scratchDir]]\n    );\n\n    // Move Cache into Its Place\n    await run('sudo', ['rm', '-rf', cacheSource]);\n    await fs.rename(path.join(scratchDir, 'dance-cache'), cacheSource);\n}\n\nexport async function extractCaches(opts: Opts) {\n    if (opts[\"skip-extraction\"]) {\n        console.log(\"skip-extraction is set. Skipping extraction step...\");\n        return;\n    }\n\n    const cacheMap = await getCacheMap(opts);\n    const scratchDir = opts['scratch-dir'];\n    const containerImage = opts['utility-image'];\n    const builder = getBuilder(opts);\n\n    // Extract Caches for each source-target pair\n    for (const [cacheSource, cacheOptions] of Object.entries(cacheMap)) {\n        await extractCache(cacheSource, cacheOptions, scratchDir, containerImage, builder);\n    }\n}\n"],"names":["__parcelExternal0","__parcelExternal1","__parcelExternal2","__parcelExternal3","__parcelExternal4","__parcelExternal5","__parcelExternal6","__parcelExternal7","__parcelExternal8","__parcelExternal9","__parcelExternal10","modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","_fs","_os","_osDefault","interopDefault","_injectCacheJs","_extractCacheJs","_optsJs","main","args","opts","parseOpts","help","extract","extractCaches","process","undefined","env","GITHUB_STATE","promises","appendFile","default","EOL","injectCaches","argv","catch","console","error","stack","exit","defineInteropFlag","export","_path","_pathDefault","_runJs","_coreJs","injectCache","cacheSource","cacheOptions","scratchDir","containerImage","builder","rm","recursive","force","mkdir","date","Date","toISOString","writeFile","join","targetPath","getTargetPath","mountArgs","getMountArgsString","ownershipCommand","uid","getUID","gid","getGID","dancefileContent","log","run","notice","cacheMap","getCacheMap","getBuilder","entries","_mri","_mriDefault","_dockerfileAst","getInput","string","boolean","alias","warning","JSON","stringify","getCacheMapFromDockerfile","dockerfilePath","bindRoot","dockerfileContent","readFile","dockerfile","DockerfileParser","parse","getInstructions","filter","getKeyword","flag","getFlags","getName","getOption","getValue","toString","target","keys","cacheMapFromDockerfile","e","otherOptions","map","key","value","toArr","any","Array","isArray","k","arr","arg","val","out","_","j","idx","len","alibi","strict","unknown","defaults","concat","splice","push","slice","charCodeAt","substring","indexOf","repeat","toVal","old","nxt","String","shift","a","__esModule","exportAll","source","dest","forEach","prototype","hasOwnProperty","enumerable","destName","ExitCode","__createBinding","create","o","m","k2","__setModuleDefault","v","__importStar","mod","result","__awaiter","thisArg","_arguments","P","generator","Promise","reject","fulfilled","step","next","rejected","done","adopt","then","apply","getIDToken","getState","saveState","group","endGroup","startGroup","info","debug","isDebug","setFailed","setCommandEcho","setOutput","getBooleanInput","getMultilineInput","addPath","setSecret","exportVariable","command_1","file_command_1","utils_1","os","path","oidc_utils_1","options","replace","toUpperCase","required","trimWhitespace","trim","message","properties","issueCommand","toCommandProperties","issue","convertedVal","toCommandValue","delimiter","commandValue","secret","inputPath","split","trueValue","includes","falseValue","TypeError","stdout","write","enabled","exitCode","Failure","fn","aud","OidcClient","summary_1","summary","summary_2","markdownSummary","command","cmd","Command","constructor","s","cmdStr","CMD_STRING","first","input","annotationProperties","title","file","line","startLine","endLine","col","startColumn","endColumn","fs","filePath","existsSync","appendFileSync","encoding","http_client_1","auth_1","core_1","createHttpClient","allowRetry","maxRetry","HttpClient","BearerCredentialHandler","getRequestToken","allowRetries","maxRetries","token","getIDTokenUrl","runtimeUrl","getCall","id_token_url","_a","httpclient","id_token","getJson","statusCode","audience","encodedAudience","encodeURIComponent","HttpCodes","Headers","MediaTypes","tunnel","http","https","pm","getProxyUrl","serverUrl","proxyUrl","URL","href","HttpRedirectCodes","MovedPermanently","ResourceMoved","SeeOther","TemporaryRedirect","PermanentRedirect","HttpResponseRetryCodes","BadGateway","ServiceUnavailable","GatewayTimeout","RetryableHttpVerbs","HttpClientError","setPrototypeOf","HttpClientResponse","readBody","output","Buffer","alloc","on","chunk","isHttps","requestUrl","parsedUrl","protocol","userAgent","handlers","requestOptions","_ignoreSslError","_allowRedirects","_allowRedirectDowngrade","_maxRedirects","_allowRetries","_maxRetries","_keepAlive","_disposed","ignoreSslError","_socketTimeout","socketTimeout","allowRedirects","allowRedirectDowngrade","maxRedirects","Math","max","keepAlive","additionalHeaders","request","del","post","data","patch","put","head","sendStream","verb","stream","Accept","_getExistingOrDefaultHeader","ApplicationJson","_processResponse","postJson","obj","ContentType","putJson","patchJson","headers","response","_prepareRequest","maxTries","numTries","requestRaw","Unauthorized","authenticationHandler","canHandleAuthentication","handleAuthentication","redirectsRemaining","redirectUrl","parsedRedirectUrl","hostname","header","toLowerCase","_performExponentialBackoff","dispose","_agent","destroy","requestRawWithCallback","onResult","socket","byteLength","callbackCalled","handleResult","req","httpModule","msg","sock","setTimeout","end","pipe","getAgent","_getAgent","method","usingSsl","host","port","parseInt","pathname","search","_mergeHeaders","agent","handler","prepareRequest","lowercaseKeys","reduce","c","assign","_default","clientHeader","useProxy","_proxyAgent","maxSockets","globalAgent","tunnelAgent","agentOptions","proxy","username","password","proxyAuth","overHttps","httpsOverHttps","httpsOverHttp","httpOverHttps","httpOverHttp","Agent","rejectUnauthorized","retryNumber","ms","ExponentialBackoffTimeSlice","pow","min","dateTimeDeserializer","isNaN","valueOf","contents","NotFound","deserializeDates","checkBypass","reqUrl","reqPort","noProxy","Number","upperReqHosts","upperNoProxyItem","some","proxyVar","tls","events","util","TunnelingAgent","proxyOptions","defaultMaxSockets","requests","sockets","localAddress","toOptions","pending","onSocket","removeSocket","createSecureSocket","cb","createSocket","hostHeader","getHeader","tlsOptions","mergeOptions","servername","secureSocket","connect","arguments","overrides","keyLen","defaultPort","inherits","EventEmitter","addRequest","onFree","emit","onCloseOrRemove","removeListener","placeholder","connectOptions","connectReq","onConnect","removeAllListeners","useChunkedEncodingByDefault","once","upgrade","nextTick","cause","pos","NODE_DEBUG","test","unshift","BasicCredentialHandler","from","httpClient","requestInfo","objs","PersonalAccessTokenCredentialHandler","SUMMARY_DOCS_URL","SUMMARY_ENV_VAR","os_1","fs_1","access","_summary","_buffer","_filePath","pathFromEnv","constants","R_OK","W_OK","wrap","tag","content","attrs","htmlAttrs","overwrite","writeFunc","emptyBuffer","clear","isEmptyBuffer","addRaw","text","addEOL","addCodeBlock","lang","element","addList","items","ordered","listItems","item","addTable","rows","tableBody","row","cells","cell","colspan","rowspan","addDetails","label","addImage","src","alt","width","height","addHeading","level","allowedTag","addSeparator","addBreak","addQuote","cite","addLink","DefaultVariables","Directive","Keyword","Workdir","Volume","User","Stopsignal","Shell","Run","PropertyInstruction","Onbuild","ModifiableInstruction","Label","JSONInstruction","Heredoc","Healthcheck","From","Env","Entrypoint","Copy","Cmd","Arg","Add","Variable","Property","ParserDirective","Line","Instruction","Flag","Comment","JSONArgument","Argument","argument_1","jsonArgument_1","comment_1","parser_1","flag_1","instruction_1","line_1","parserDirective_1","property_1","variable_1","add_1","arg_1","cmd_1","copy_1","entrypoint_1","env_1","from_1","healthcheck_1","heredoc_1","jsonInstruction_1","label_1","modifiableInstruction_1","onbuild_1","propertyInstruction_1","run_1","shell_1","stopsignal_1","user_1","volume_1","workdir_1","parser","Parser","range","getRange","isAfter","position","start","character","isBefore","jsonRange","getJSONRange","getJSONValue","vscode_languageserver_types_1","util_1","document","getContent","getContentRange","getText","offsetAt","startOffset","raw","Util","isWhitespace","charAt","Range","positionAt","factory","exports1","TextDocument","WorkspaceFolder","InlineCompletionContext","SelectedCompletionInfo","InlineCompletionTriggerKind","InlineCompletionList","InlineCompletionItem","StringValue","InlayHint","InlayHintLabelPart","InlayHintKind","InlineValueContext","InlineValueEvaluatableExpression","InlineValueVariableLookup","InlineValueText","SemanticTokens","SemanticTokenModifiers","SemanticTokenTypes","SelectionRange","DocumentLink","FormattingOptions","CodeLens","CodeAction","CodeActionContext","CodeActionTriggerKind","CodeActionKind","DocumentSymbol","WorkspaceSymbol","SymbolInformation","SymbolTag","SymbolKind","DocumentHighlight","DocumentHighlightKind","SignatureInformation","ParameterInformation","Hover","MarkedString","CompletionList","CompletionItem","CompletionItemLabelDetails","InsertTextMode","InsertReplaceEdit","CompletionItemTag","InsertTextFormat","CompletionItemKind","MarkupContent","MarkupKind","TextDocumentItem","OptionalVersionedTextDocumentIdentifier","VersionedTextDocumentIdentifier","TextDocumentIdentifier","WorkspaceChange","WorkspaceEdit","DeleteFile","RenameFile","CreateFile","TextDocumentEdit","AnnotatedTextEdit","ChangeAnnotationIdentifier","ChangeAnnotation","TextEdit","Diagnostic","CodeDescription","DiagnosticTag","DiagnosticSeverity","DiagnosticRelatedInformation","FoldingRange","FoldingRangeKind","ColorPresentation","ColorInformation","Color","LocationLink","Location","Position","uinteger","integer","URI","DocumentUri","is","MIN_VALUE","MAX_VALUE","Is","objectLiteral","candidate","one","two","three","four","uri","targetUri","targetRange","targetSelectionRange","originSelectionRange","red","green","blue","alpha","numberRange","color","textEdit","additionalTextEdits","typedArray","Imports","Region","startCharacter","endCharacter","kind","collapsedText","defined","location","Warning","Information","Hint","Unnecessary","Deprecated","severity","relatedInformation","number","codeDescription","_i","newText","insert","needsConfirmation","description","annotation","annotationId","textDocument","edits","ignoreIfExists","oldUri","newUri","ignoreIfNotExists","changes","documentChanges","every","change","TextEditChangeImpl","changeAnnotations","edit","assertChangeAnnotations","manage","delete","add","all","ChangeAnnotations","annotations","_annotations","_counter","_size","configurable","idOrAnnotation","nextId","workspaceEdit","_this","_textEditChanges","_workspaceEdit","_changeAnnotations","textEditChange","initDocumentChanges","size","getTextEditChange","version","textDocumentEdit","initChanges","createFile","optionsOrAnnotation","operation","renameFile","deleteFile","languageId","PlainText","Markdown","Text","Method","Function","Constructor","Field","Class","Interface","Unit","Value","Enum","Snippet","File","Reference","Folder","EnumMember","Constant","Struct","Event","Operator","TypeParameter","asIs","adjustIndentation","detail","isIncomplete","fromPlainText","plainText","language","documentation","parameters","Read","Write","Namespace","Package","Boolean","Key","Null","containerName","selectionRange","children","deprecated","tags","Empty","QuickFix","Refactor","RefactorExtract","RefactorInline","RefactorRewrite","Source","SourceOrganizeImports","SourceFixAll","Invoked","Automatic","diagnostics","only","triggerKind","kindOrCommandOrEdit","checkKind","isPreferred","tabSize","insertSpaces","resultId","variableName","caseSensitiveLookup","expression","frameId","stoppedLocation","Type","Parameter","tooltip","textEdits","paddingLeft","paddingRight","createSnippet","insertText","filterText","selectedCompletionInfo","FullTextDocument","lineCount","func","applyEdits","sortedEdits","mergeSort","compare","p","left","right","leftIdx","rightIdx","ret","b","diff","lastModifiedOffset","endOffset","_uri","_languageId","_version","_content","_lineOffsets","update","event","getLineOffsets","lineOffsets","isLineStart","ch","offset","low","high","mid","floor","lineOffset","nextLineOffset","check","getTextContent","isUTF8BOM","char","uintArray","Uint8Array","isNewline","findLeadingNonWhitespace","escapeChar","whitespaceCheck","escapeCheck","isInsideRange","parseHeredocName","vscode_languageserver_textdocument_1","dockerfile_1","main_1","createInstruction","lineRange","instruction","instructionRange","getParserDirectives","buffer","directives","directiveCheck","directiveStart","directiveEnd","valueStart","valueEnd","lineEnd","directiveValue","nameRange","valueRange","Dockerfile","setDirectives","getEscapeCharacter","processComment","processInstruction","organizeComments","instructionEnd","escapedInstruction","instructionCheck","processArguments","addInstruction","processHeredocs","keyword","ONBUILD","getTriggerInstruction","ADD","COPY","RUN","heredocs","getArguments","startsWith","heredoc","parseHeredoc","escaped","argumentsCheck","commentLoop","addComment","heredocName","startWord","lineStart","startPosition","__spreadArray","to","pack","ar","l","changes_1","isIncremental","getWellformedRange","addedLineOffsets","computeLineOffsets","isFull","ensureBeforeEOL","isEOL","rangeLength","isAtLineStart","textOffset","getWellformedEdit","spans","sortedEdits_1","substr","getNameRange","getValueRange","getDirective","directive","getRawArguments","getRangeContent","getInstructionRange","getInstruction","getArgumentsRange","getArgumentsRanges","ranges","extra","fullArgs","comment","getRawArgumentsContent","getArgumentsContent","documentText","found","escapedWhitespaceDetected","escaping","escapeMarker","escapedArg","getExpandedArguments","argRange","variables","parseVariables","swaps","requiresExpansion","variable","resolveVariable","expanded","variableRange","argEnd","getVariables","rawValue","parsedVariable","variableLoop","escapedString","escapedName","nameEnd","escapedSubstitutionParameter","substitutionStart","substitutionEnd","modifierRead","nameLoop","modifier","modifierRange","substitutionParameter","substitutionRange","isBuildVariable","varStart","match","FROM","initialArg","getInitialARGs","property","getProperty","image","getContainingImage","envs","getENVs","getProperties","getARGs","createSingleLineHeredocs","startRange","endFound","searchHyphen","quote","contentLoop","nameStart","getHeredocs","heredocDefinitions","heredocsProcessed","contentStart","contentEnd","currentHeredoc","delimiterRange","getDelimiterRange","contentRange","offsetLimit","startArg","candidateRange","index","endRange","getStartRange","buildVariable","stringValue","getModifier","getModifierRange","getSubstitutionParameter","getSubstitutionRange","isDefined","isEnvironmentVariable","stopSearchingForFlags","argument","openingBracket","closingBracket","jsonStrings","argsContent","argsOffset","last","quoted","argsCheck","_value","getOpeningBracket","getJSONStrings","getClosingBracket","flags","nameIndex","firstMatch","secondMatch","startIndex","nameSearchLoop","flagOption_1","hasOptions","createFlagOption","documentOffset","optionRange","FlagOption","option","getOptions","getPropertyArguments","arg2","assignmentOperatorRange","assignmentOperator","getAssignmentOperator","getAssignmentOperatorRange","getUnescapedValue","rawLoop","initial","before","skip","literal","inSingle","inDouble","commentCheck","escapedValue","parseValue","char2","newlineCheck","findTrailingNonWhitespace","instructionNameEndOffset","endingEscape","mark","argStart","spaced","argumentLoop","createSpacedArgument","singleQuotes","doubleQuotes","getFromFlag","getImage","getImageRange","getImageName","getImageNameRange","registryRange","getRegistryRange","tagRange","getImageTagRange","digestRange","getImageDigestRange","getImageTag","rangeStartOffset","atIndex","slashIndex","colonIndex","lastIndexOf","subcontent","subcolonIndex","getImageDigest","searchString","subIndex","getRegistry","rangeStart","startingSlashIndex","portIndex","dotIndex","registry","getBuildStage","getBuildStageRange","getPlatformFlag","getSubcommand","getTrigger","trigger","getTriggerWord","getTriggerRange","triggerRange","getPath","getAbsolutePath","hierarchy","getStageHierarchy","workdirs","getWORKDIRs","endsWith","ast","imageTemplate_1","ImageTemplate","initialInstructions","buildStages","foundFrom","escape","getComments","buildStage","currentBuildStage","getDirectives","getFROMs","initialARGs","resolvedVariable","getAvailableVariables","currentLine","getInstructionAt","getParentStage","templateFrom","getFROM","imageName","stages","stage","getAvailableWorkingDirectories","availableDirectories","Set","workdir","directory","comments","instructions","commentStart","commentEnd","instructionStart","getCMDs","cmds","getCOPYs","copies","getENTRYPOINTs","froms","getHEALTHCHECKs","getOnbuildTriggers","triggers","contains","runPiped","_spawnPlease","_spawnPleaseDefault","_childProcess","_childProcessDefault","command1","args1","command2","args2","cp1","spawn","stdio","cp2","stdin","assertSuccess","cp","spawnOptions","rejectOnError","stderr","child","addListener","enoent","parsed","spawned","hookChildProcess","sync","spawnSync","verifyENOENTSync","status","_parse","_enoent","resolveCommand","readShebang","isWin","platform","isExecutableRegExp","isCmdShimRegExp","original","shell","parseNonShell","commandFile","detectShebang","shebang","needsShell","forceShell","needsDoubleEscapeMetaChars","normalize","shellCommand","comspec","windowsVerbatimArguments","which","getPathKey","resolveCommandAttempt","withoutPathExt","resolved","cwd","hasCustomCwd","shouldSwitchCwd","chdir","disabled","pathExt","isWindows","OSTYPE","COLON","isexe","getNotFoundError","getPathInfo","opt","colon","pathEnv","PATH","pathExtExe","PATHEXT","ppRaw","pathPart","pCmd","subStep","ii","ext","er","cur","ex","nothrow","core","ignoreErrors","TESTING_WINDOWS","checkStat","statSync","stat","isSymbolicLink","isFile","pathext","myUid","myGid","u","g","mode","getuid","getgid","pathKey","environment","reverse","find","metaCharsRegExp","doubleEscapeMetaChars","shebangCommand","fd","openSync","readSync","closeSync","shebangRegex","binary","pop","notFoundError","syscall","errno","spawnargs","verifyENOENT","originalEmit","arg1","extractCache","rename","parcelRequire86b4"],"version":3,"file":"index.js.map","sourceRoot":"../"}